<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BookJam - Note Editor</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Noto+Sans+KR:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: 'Orbitron', 'Noto Sans KR', sans-serif;
            background: linear-gradient(135deg, #0F2027 0%, #203A43 50%, #2C5364 100%);
            color: white;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #control-panel {
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            padding: 15px 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            border-bottom: 2px solid rgba(102, 126, 234, 0.5);
            max-height: 120px;
            overflow-y: auto;
        }

        .control-group {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        label {
            font-size: 12px;
            color: #aaa;
            white-space: nowrap;
        }

        input[type="file"] {
            display: none;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            white-space: nowrap;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.6);
        }

        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        input[type="number"], input[type="text"], select {
            padding: 6px 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
        }

        input[type="number"] {
            width: 80px;
        }

        input[type="text"] {
            width: 150px;
        }

        select {
            width: 120px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }

        #editor-container {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }

        #left-sidebar {
            width: 200px;
            background: rgba(0, 0, 0, 0.9);
            border-right: 2px solid rgba(102, 126, 234, 0.3);
            padding: 15px;
            overflow-y: auto;
        }

        #left-sidebar h3 {
            margin-bottom: 10px;
            color: #667eea;
            font-size: 14px;
        }

        .sidebar-section {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-box {
            background: rgba(102, 126, 234, 0.15);
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 10px;
            line-height: 1.5;
        }

        #editor-canvas {
            flex: 1;
            background: #0a0a0a;
            position: relative;
        }

        #editor-canvas canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        #right-sidebar {
            width: 220px;
            background: rgba(0, 0, 0, 0.9);
            border-left: 2px solid rgba(102, 126, 234, 0.3);
            padding: 15px;
            overflow-y: auto;
        }

        #right-sidebar h3 {
            margin-bottom: 10px;
            color: #667eea;
            font-size: 14px;
        }

        .info-item {
            margin: 8px 0;
            font-size: 12px;
        }

        .info-item strong {
            color: #667eea;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .stat-box {
            background: rgba(102, 126, 234, 0.1);
            padding: 8px;
            border-radius: 4px;
            text-align: center;
        }

        .stat-box .label {
            font-size: 10px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .stat-box .value {
            font-size: 16px;
            font-weight: bold;
            color: #667eea;
        }

        .key-hint {
            background: rgba(102, 126, 234, 0.2);
            padding: 10px;
            border-radius: 6px;
            margin-top: 15px;
            font-size: 11px;
            line-height: 1.6;
        }

        .density-graph, #minimap {
            width: 100%;
            height: 80px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 6px;
            margin-top: 10px;
            border: 1px solid rgba(102, 126, 234, 0.3);
        }

        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        #loading-overlay.show {
            display: flex;
        }

        .loading-content {
            text-align: center;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <h2 id="loading-text">ë¶„ì„ ì¤‘...</h2>
            <p id="loading-detail">ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”</p>
        </div>
    </div>

    <div id="container">
        <div id="control-panel">
            <div class="control-group">
                <label for="file-input" class="btn btn-primary">ğŸ“ ìŒì› ë¡œë“œ</label>
                <input type="file" id="file-input" accept="audio/*">
                <span id="file-name" style="font-size: 11px;">íŒŒì¼ ì—†ìŒ</span>
            </div>

            <div class="control-group">
                <label>BPM:</label>
                <input type="number" id="bpm-input" value="0" min="60" max="240" step="0.5">
                <button class="btn btn-primary" id="override-bpm-btn" style="padding: 6px 10px; font-size: 10px;" disabled>ì ìš©</button>
                <button class="btn btn-success" id="tap-bpm-btn" style="padding: 6px 10px; font-size: 10px;" disabled>ğŸµ Tap</button>
            </div>

            <div class="control-group">
                <label>Offset:</label>
                <input type="number" id="offset-input" value="0" step="0.01" style="width: 70px;">
                <button class="btn btn-primary" id="offset-minus-btn" style="padding: 6px 8px; font-size: 10px;" disabled>-0.01</button>
                <button class="btn btn-primary" id="offset-plus-btn" style="padding: 6px 8px; font-size: 10px;" disabled>+0.01</button>
                <button class="btn btn-success" id="mark-beat-btn" style="padding: 6px 10px; font-size: 10px;" disabled>1ë°•</button>
            </div>

            <div class="control-group">
                <label>ì œëª©:</label>
                <input type="text" id="title-input" placeholder="Title">
            </div>

            <div class="control-group">
                <label>ë‚œì´ë„:</label>
                <select id="difficulty-select">
                    <option value="Easy">Easy</option>
                    <option value="Normal">Normal</option>
                    <option value="Hard" selected>Hard</option>
                    <option value="Expert">Expert</option>
                </select>
            </div>

            <div class="control-group">
                <button class="btn btn-primary" id="play-btn" disabled>â–¶ ì¬ìƒ</button>
                <button class="btn btn-danger" id="stop-btn" disabled>â¹ ì •ì§€</button>
            </div>

            <div class="control-group">
                <button class="btn btn-success" id="regen-btn" disabled>ğŸ”„ ì¬ìƒì„±</button>
                <button class="btn btn-success" id="save-btn" disabled>ğŸ’¾ ì €ì¥</button>
                <label for="load-chart-input" class="btn btn-primary" id="load-chart-btn" disabled>ğŸ“‚ ë¶ˆëŸ¬ì˜¤ê¸°</label>
                <input type="file" id="load-chart-input" accept=".json">
                <button class="btn btn-primary" id="toggle-onset-btn" disabled>ğŸ‘ï¸ Onset</button>
            </div>

            <div class="control-group">
                <button class="btn btn-danger" id="delete-note-btn" disabled>ğŸ—‘ï¸ ë…¸íŠ¸ ì‚­ì œ</button>
                <button class="btn btn-primary" id="edit-mode-btn" disabled>âœï¸ í¸ì§‘ëª¨ë“œ</button>
                <span id="edit-mode-status" style="font-size: 11px; color: #aaa;">ì¼ë°˜ëª¨ë“œ</span>
            </div>
        </div>

        <div id="editor-container">
            <div id="left-sidebar">
                <div class="sidebar-section">
                    <h3>ğŸ¯ Pure Onset ì‹œìŠ¤í…œ</h3>
                    <div class="info-box">
                        <strong>í™•ë¥  ì—†ìŒ! 1:1 ë§¤í•‘!</strong><br>
                        <br>
                        <strong>âœ… ì›ìƒ· = ë…¸íŠ¸:</strong><br>
                        â€¢ Onset ê°ì§€ â†’ ë¬´ì¡°ê±´ ë…¸íŠ¸<br>
                        â€¢ í™•ë¥ /ëœë¤ ì™„ì „ ì œê±°<br>
                        â€¢ BPM ê·¸ë¦¬ë“œì— ìŠ¤ëƒ… (1/16ë°•)<br>
                        <br>
                        <strong>ğŸ§ ì•…ê¸°ë³„ ìë™ ë§¤í•‘:</strong><br>
                        â€¢ Kick â†’ ì™¼ì† (Dâ†”F)<br>
                        â€¢ Snare â†’ ì˜¤ë¥¸ì† (Jâ†”K)<br>
                        â€¢ Hi-hat â†’ ì˜¤ë¥¸ì† (Jâ†”K)<br>
                        <br>
                        <strong>ë‚œì´ë„ = Threshold:</strong><br>
                        Easy: ê°•í•œ ë¹„íŠ¸ë§Œ<br>
                        Hard: ì¤‘ê°„ ë¹„íŠ¸ê¹Œì§€<br>
                        Expert: ì•½í•œ ë¹„íŠ¸ê¹Œì§€
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>ğŸ‘ï¸ Onset ì‹œê°í™”</h3>
                    <div class="info-box">
                        <strong>ğŸ” Onset ë²„íŠ¼:</strong><br>
                        ê°ì§€ëœ ë¹„íŠ¸ë¥¼ ì‹œê°í™”!<br>
                        <br>
                        <strong>ìƒ‰ìƒ ì˜ë¯¸:</strong><br>
                        <span style="color: #00FFFF;">â— ì²­ë¡ìƒ‰</span> - ë…¸íŠ¸ ìƒì„±ë¨<br>
                        <span style="color: #FFFF00;">â— ë…¸ë€ìƒ‰</span> - ì¤‘ê°„ ê°•ë„<br>
                        <span style="color: #FFA500;">â— ì£¼í™©ìƒ‰</span> - ì•½í•œ ë¹„íŠ¸<br>
                        <br>
                        <strong>ì•…ê¸° í‘œì‹œ:</strong><br>
                        <span style="color: #FF6B6B;">K</span> = Kick (í‚¥ë“œëŸ¼)<br>
                        <span style="color: #4ECDC4;">S</span> = Snare (ìŠ¤ë„¤ì–´)<br>
                        <span style="color: #FFE66D;">H</span> = Hi-hat (í•˜ì´í–‡)<br>
                        <br>
                        ì²­ë¡ìƒ‰ ì„ ì´ ë…¸íŠ¸ì™€ ì¼ì¹˜í•˜ëŠ”ì§€<br>
                        í™•ì¸í•´ì„œ íƒ€ì´ë° ê²€ì¦!
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>âš™ï¸ ìˆ˜ë™ ì¡°ì •</h3>
                    <div class="info-box">
                        <strong>ğŸµ Tap BPM:</strong><br>
                        ì¬ìƒí•˜ë©° 1ë°•ë§ˆë‹¤ í´ë¦­<br>
                        â†’ ìë™ìœ¼ë¡œ BPM ê³„ì‚°<br>
                        <br>
                        <strong>1ë°• ë²„íŠ¼:</strong><br>
                        ì¬ìƒ ì¤‘ 1ë°•ì—ì„œ í´ë¦­<br>
                        â†’ Offset ìë™ ì„¤ì •<br>
                        <br>
                        <strong>ë¯¸ì„¸ì¡°ì •:</strong><br>
                        â€¢ +/- ë²„íŠ¼ìœ¼ë¡œ 0.01ì´ˆì”©<br>
                        â€¢ ë…¸íŠ¸ê°€ í° ì„ ì— ë§ê²Œ<br>
                        <br>
                        <strong>ìˆœì„œ:</strong><br>
                        1. Tap BPMìœ¼ë¡œ BPM ì¸¡ì •<br>
                        2. "ì ìš©" í´ë¦­<br>
                        3. ì¬ìƒí•˜ë©° 1ë°• ë²„íŠ¼<br>
                        4. +/- ë¡œ ë¯¸ì„¸ì¡°ì •
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>ë ˆì¸ ë§¤í•‘</h3>
                    <div class="info-box">
                        <strong>ğŸ® ë””ì œì´ë§¥ìŠ¤ íŒ¨í„´!</strong><br>
                        <br>
                        <strong>Kick:</strong> ì™¼ì† (Dâ†”F)<br>
                        <strong>Snare:</strong> ì˜¤ë¥¸ì† (Jâ†”K)<br>
                        <strong>Hi-hat:</strong> ì˜¤ë¥¸ì† (Jâ†”K)<br>
                        <br>
                        <strong>ê°•ë°•:</strong> ì™¼ì†â†”ì˜¤ë¥¸ì† êµëŒ€<br>
                        <strong>ì•½ë°•:</strong> ê°™ì€ ì† ì—°íƒ€<br>
                        <strong>Space:</strong> ê±°ì˜ ì•ˆ ì”€<br>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>ë‚œì´ë„ë³„ íŠ¹ì„±</h3>
                    <div class="info-box">
                        <strong>Easy:</strong> 1/2ë°•ì (downbeat)<br>
                        <strong>Normal:</strong> 1/4ë°•ì<br>
                        <strong>Hard:</strong> 1/4 + 1/8ë°•ì<br>
                        <strong>Expert:</strong> 1/4+1/8+1/16ë°•ì<br>
                        <br>
                        <strong>ë°€ë„ ì¡°ì ˆ:</strong><br>
                        Chorus 130%, Verse 100%<br>
                        Break 60%, Intro 40%
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>ìˆ˜ë™ ì¡°ì •</h3>
                    <div class="info-box">
                        ì¬ìƒí•˜ë©° ë…¸íŠ¸ ì¶”ê°€:<br>
                        D, F, Space, J, K<br>
                        <br>
                        Delete: ë§ˆì§€ë§‰ ì‚­ì œ<br>
                        ğŸ”„ ì¬ìƒì„±: ìƒˆë¡œ ìƒì„±
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>âœï¸ í¸ì§‘ ëª¨ë“œ (E)</h3>
                    <div class="info-box">
                        <strong>ë…¸íŠ¸ ì„ íƒ:</strong><br>
                        â€¢ ë…¸íŠ¸ í´ë¦­ìœ¼ë¡œ ì„ íƒ/í•´ì œ<br>
                        â€¢ ESC: ì„ íƒ í•´ì œ<br>
                        <br>
                        <strong>ì„ íƒëœ ë…¸íŠ¸ í¸ì§‘:</strong><br>
                        â€¢ D/F/Space/J/K: ë ˆì¸ ì´ë™<br>
                        â€¢ â†/â†’: íƒ€ì´ë° ì¡°ì • (Â±10ms)<br>
                        â€¢ Delete/Backspace: ì‚­ì œ<br>
                        <br>
                        <strong>ë‹¨ì¶•í‚¤:</strong><br>
                        â€¢ E: í¸ì§‘ëª¨ë“œ í† ê¸€<br>
                        â€¢ Ctrl+S: ì°¨íŠ¸ ì €ì¥
                    </div>
                </div>
            </div>

            <div id="editor-canvas"></div>

            <div id="right-sidebar">
                <h3>CHART INFO</h3>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="label">NOTES</div>
                        <div class="value" id="note-count">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">NPS</div>
                        <div class="value" id="nps-display">0.0</div>
                    </div>
                </div>

                <div style="margin-top: 15px;">
                    <div class="info-item">
                        ì‹œê°„: <strong id="current-time">0.00s</strong>
                    </div>
                    <div class="info-item">
                        ë°•ì: <strong id="current-beat">0</strong>
                    </div>
                    <div class="info-item">
                        ìƒíƒœ: <strong id="status">ëŒ€ê¸° ì¤‘</strong>
                    </div>
                    <div class="info-item">
                        BPM: <strong id="detected-bpm">-</strong>
                    </div>
                </div>

                <h3 style="margin-top: 20px;">DENSITY</h3>
                <canvas id="density-graph" class="density-graph"></canvas>

                <h3 style="margin-top: 20px;">MINIMAP</h3>
                <canvas id="minimap"></canvas>

                <div class="key-hint">
                    <strong>ğŸ¹ ë‹¨ì¶•í‚¤</strong><br>
                    <kbd>D F Space J K</kbd> ë…¸íŠ¸<br>
                    <kbd>Delete</kbd> ì‚­ì œ<br>
                    <kbd>Space</kbd> ì¬ìƒ/ì •ì§€<br>
                    <br>
                    <strong>ğŸ’¡ ì‚¬ìš©ë²•</strong><br>
                    1. ìŒì›ë§Œ ë¡œë“œí•˜ì„¸ìš”!<br>
                    2. ìë™ìœ¼ë¡œ ë¶„ì„ë©ë‹ˆë‹¤<br>
                    3. ë°”ë¡œ ì¬ìƒ ê°€ëŠ¥!<br>
                    4. Offsetìœ¼ë¡œ ë¯¸ì„¸ì¡°ì •
                </div>
            </div>
        </div>
    </div>

    <script src="https://pixijs.download/release/pixi.js"></script>
    <script>
        const LANES = [
            { key: 'KeyD', index: 0, color: 0xFF6B6B, label: 'D' },
            { key: 'KeyF', index: 1, color: 0x4ECDC4, label: 'F' },
            { key: 'Space', index: 2, color: 0xFFE66D, label: 'â£' },
            { key: 'KeyJ', index: 3, color: 0x95E1D3, label: 'J' },
            { key: 'KeyK', index: 4, color: 0xF38181, label: 'K' }
        ];

        const editorState = {
            notes: [],
            audioContext: null,
            audioBuffer: null,
            audioSource: null,
            startTime: 0,
            currentTime: 0,
            isPlaying: false,
            bpm: 0,
            offset: 0,
            title: '',
            difficulty: 'Hard',
            duration: 0,
            onsets: [],  // Overall onset strengths
            onsetTimes: [],
            bassOnsets: [],   // Bass line (40-100Hz) - Task #3
            kickOnsets: [],   // Kick drum (100-150Hz) - Task #3
            snareOnsets: [],  // Snare drum (mid freq)
            hihatOnsets: [],  // Hi-hat (high freq)
            melodyOnsets: [],  // Melody (200-2000Hz, spectral flux) - Task #1
            musicStructure: [], // Music structure sections (Intro/Verse/Chorus) - Task #2
            showOnsets: false,   // Toggle onset visualization
            editMode: false,     // Edit mode for note selection/editing
            selectedNotes: new Set(),  // Set of selected note indices
            audioFileName: ''    // Original audio file name
        };

        let app, gameContainer, notesContainer, gridContainer, beatGridContainer, onsetMarkersContainer;
        let GAME_WIDTH, GAME_HEIGHT, LANE_WIDTH, JUDGMENT_LINE_Y;

        function showLoading(text, detail = '') {
            document.getElementById('loading-text').textContent = text;
            document.getElementById('loading-detail').textContent = detail;
            document.getElementById('loading-overlay').classList.add('show');
        }

        function hideLoading() {
            document.getElementById('loading-overlay').classList.remove('show');
        }

        function calculateDimensions() {
            const canvas = document.getElementById('editor-canvas');
            GAME_WIDTH = canvas.clientWidth;
            GAME_HEIGHT = canvas.clientHeight;
            LANE_WIDTH = GAME_WIDTH / LANES.length;
            JUDGMENT_LINE_Y = GAME_HEIGHT - 100;
        }

        window.addEventListener('load', async () => {
            setupUI();
            await initEditor();
        });

        function setupUI() {
            document.getElementById('file-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    document.getElementById('file-name').textContent = file.name.substring(0, 20);
                    document.getElementById('title-input').value = file.name.replace(/\.[^/.]+$/, "");
                    editorState.title = file.name.replace(/\.[^/.]+$/, "");
                    editorState.audioFileName = file.name;  // ì˜¤ë””ì˜¤ íŒŒì¼ ì´ë¦„ ì €ì¥
                    await loadAndAnalyzeAudio(file);
                }
            });

            document.getElementById('play-btn').addEventListener('click', togglePlayback);
            document.getElementById('stop-btn').addEventListener('click', stopPlayback);
            document.getElementById('save-btn').addEventListener('click', saveChart);
            document.getElementById('load-chart-input').addEventListener('change', loadChart);
            document.getElementById('regen-btn').addEventListener('click', regenerateNotes);

            document.getElementById('override-bpm-btn').addEventListener('click', () => {
                const newBPM = parseFloat(document.getElementById('bpm-input').value);
                if (newBPM >= 60 && newBPM <= 240) {
                    editorState.bpm = newBPM;
                    regenerateNotes();
                    console.log(`âœï¸ BPM manually adjusted to ${newBPM}`);
                } else {
                    alert('BPMì€ 60-240 ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤.');
                }
            });

            document.getElementById('offset-input').addEventListener('change', (e) => {
                editorState.offset = parseFloat(e.target.value);
                regenerateNotes();
                console.log(`âœï¸ Offset manually adjusted to ${editorState.offset.toFixed(3)}s`);
            });

            document.getElementById('offset-minus-btn').addEventListener('click', () => {
                editorState.offset -= 0.01;
                document.getElementById('offset-input').value = editorState.offset.toFixed(3);
                regenerateNotes();
                console.log(`âœï¸ Offset: ${editorState.offset.toFixed(3)}s`);
            });

            document.getElementById('offset-plus-btn').addEventListener('click', () => {
                editorState.offset += 0.01;
                document.getElementById('offset-input').value = editorState.offset.toFixed(3);
                regenerateNotes();
                console.log(`âœï¸ Offset: ${editorState.offset.toFixed(3)}s`);
            });

            // Tap BPM ê¸°ëŠ¥
            let tapTimes = [];
            document.getElementById('tap-bpm-btn').addEventListener('click', () => {
                const now = Date.now();
                tapTimes.push(now);

                // ìµœê·¼ 8ë²ˆì˜ íƒ­ë§Œ ìœ ì§€
                if (tapTimes.length > 8) {
                    tapTimes.shift();
                }

                if (tapTimes.length >= 2) {
                    // íƒ­ ê°„ê²©ì˜ í‰ê·  ê³„ì‚°
                    const intervals = [];
                    for (let i = 1; i < tapTimes.length; i++) {
                        intervals.push(tapTimes[i] - tapTimes[i - 1]);
                    }
                    const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                    const bpm = 60000 / avgInterval;  // ms to BPM

                    document.getElementById('bpm-input').value = bpm.toFixed(1);
                    console.log(`ğŸµ Tap BPM: ${bpm.toFixed(1)} (${tapTimes.length} taps)`);
                }

                // 5ì´ˆ ì´ìƒ íƒ­ ì•ˆ í•˜ë©´ ë¦¬ì…‹
                setTimeout(() => {
                    const lastTap = tapTimes[tapTimes.length - 1];
                    if (Date.now() - lastTap > 5000) {
                        tapTimes = [];
                        console.log('Tap BPM reset');
                    }
                }, 5000);
            });

            // Mark Beat ê¸°ëŠ¥ (1ë°• ìœ„ì¹˜ í‘œì‹œ)
            document.getElementById('mark-beat-btn').addEventListener('click', () => {
                if (editorState.isPlaying) {
                    const currentTime = editorState.currentTime;
                    document.getElementById('offset-input').value = currentTime.toFixed(3);
                    editorState.offset = currentTime;
                    regenerateNotes();
                    console.log(`âœï¸ Marked beat at ${currentTime.toFixed(3)}s as offset`);
                } else {
                    alert('ì¬ìƒ ì¤‘ì— 1ë°•ì—ì„œ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”!');
                }
            });

            document.getElementById('difficulty-select').addEventListener('change', (e) => {
                editorState.difficulty = e.target.value;
                if (editorState.audioBuffer) {
                    regenerateNotes();
                }
            });

            // Toggle Onset Visualization
            document.getElementById('toggle-onset-btn').addEventListener('click', () => {
                editorState.showOnsets = !editorState.showOnsets;
                const btn = document.getElementById('toggle-onset-btn');
                if (editorState.showOnsets) {
                    btn.textContent = 'ğŸ‘ï¸ Onset ON';
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-success');
                    console.log('ğŸ” Onset visualization enabled');
                } else {
                    btn.textContent = 'ğŸ‘ï¸ Onset';
                    btn.classList.remove('btn-success');
                    btn.classList.add('btn-primary');
                    console.log('ğŸ” Onset visualization disabled');
                }
            });

            // Toggle Edit Mode
            document.getElementById('edit-mode-btn').addEventListener('click', toggleEditMode);

            // Delete Selected Notes
            document.getElementById('delete-note-btn').addEventListener('click', deleteSelectedNotes);

            window.addEventListener('keydown', handleKeyDown);
        }

        function handleKeyDown(e) {
            const activeElement = document.activeElement;
            const isTyping = activeElement.tagName === 'INPUT';

            if (!isTyping) {
                // í¸ì§‘ ëª¨ë“œì—ì„œ ì„ íƒëœ ë…¸íŠ¸ í¸ì§‘
                if (editorState.editMode && editorState.selectedNotes.size > 0) {
                    // Delete/Backspace: ì„ íƒëœ ë…¸íŠ¸ ì‚­ì œ
                    if (e.code === 'Delete' || e.code === 'Backspace') {
                        e.preventDefault();
                        deleteSelectedNotes();
                        return;
                    }

                    // ë ˆì¸ ë³€ê²½: D(0), F(1), Space(2), J(3), K(4)
                    const laneMap = { 'KeyD': 0, 'KeyF': 1, 'Space': 2, 'KeyJ': 3, 'KeyK': 4 };
                    if (laneMap.hasOwnProperty(e.code)) {
                        e.preventDefault();
                        moveSelectedNotesToLane(laneMap[e.code]);
                        return;
                    }

                    // íƒ€ì´ë° ë¯¸ì„¸ ì¡°ì •: ArrowLeft (ì•ìœ¼ë¡œ), ArrowRight (ë’¤ë¡œ)
                    if (e.code === 'ArrowLeft') {
                        e.preventDefault();
                        adjustSelectedNotesTiming(-0.01);  // 10ms ì•ìœ¼ë¡œ
                        return;
                    }
                    if (e.code === 'ArrowRight') {
                        e.preventDefault();
                        adjustSelectedNotesTiming(0.01);  // 10ms ë’¤ë¡œ
                        return;
                    }

                    // Escape: ì„ íƒ í•´ì œ
                    if (e.code === 'Escape') {
                        e.preventDefault();
                        editorState.selectedNotes.clear();
                        console.log('âœ… ëª¨ë“  ë…¸íŠ¸ ì„ íƒ í•´ì œ');
                        return;
                    }
                }

                // ì¼ë°˜ ëª¨ë“œ ë‹¨ì¶•í‚¤
                if (e.code === 'Space') {
                    e.preventDefault();
                    togglePlayback();
                    return;
                }

                if (e.code === 'Delete' || e.code === 'Backspace') {
                    e.preventDefault();
                    deleteLastNote();
                    return;
                }

                const lane = LANES.find(l => l.key === e.code);
                if (lane && editorState.isPlaying) {
                    e.preventDefault();
                    const time = editorState.currentTime;
                    addNote(lane.index, time);
                    showKeyFlash(lane.index);
                }

                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    saveChart();
                }

                // E: í¸ì§‘ ëª¨ë“œ í† ê¸€
                if (e.code === 'KeyE') {
                    e.preventDefault();
                    toggleEditMode();
                }
            }
        }

        async function loadAndAnalyzeAudio(file) {
            try {
                showLoading('ìŒì› ë¡œë”© ì¤‘...', 'ì˜¤ë””ì˜¤ ë””ì½”ë”©');

                if (!editorState.audioContext) {
                    editorState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                const arrayBuffer = await file.arrayBuffer();
                editorState.audioBuffer = await editorState.audioContext.decodeAudioData(arrayBuffer);
                editorState.duration = editorState.audioBuffer.duration;

                showLoading('BPM ë¶„ì„ ì¤‘...', 'í…œí¬ ë° ë¹„íŠ¸ ê°ì§€');

                // BPM ë° ì²« ë¹„íŠ¸ ì˜¤í”„ì…‹ ìë™ ê°ì§€
                const { bpm: detectedBPM, offset: detectedOffset, onsets, onsetTimes, bassOnsets, kickOnsets, snareOnsets, hihatOnsets, melodyOnsets, musicStructure } = await detectBPMAndOffset(editorState.audioBuffer);
                editorState.bpm = detectedBPM;
                editorState.offset = detectedOffset;
                editorState.onsets = onsets;
                editorState.onsetTimes = onsetTimes;
                editorState.bassOnsets = bassOnsets;   // Task #3
                editorState.kickOnsets = kickOnsets;
                editorState.snareOnsets = snareOnsets;
                editorState.hihatOnsets = hihatOnsets;
                editorState.melodyOnsets = melodyOnsets; // Task #1
                editorState.musicStructure = musicStructure; // Task #2

                document.getElementById('bpm-input').value = detectedBPM.toFixed(1);
                document.getElementById('offset-input').value = detectedOffset.toFixed(3);
                document.getElementById('detected-bpm').textContent = detectedBPM.toFixed(1);

                showLoading('ë…¸íŠ¸ ìƒì„± ì¤‘...', 'ë‚œì´ë„: ' + editorState.difficulty);

                // ìë™ ë…¸íŠ¸ ìƒì„±
                generateNotes();

                hideLoading();

                document.getElementById('status').textContent = 'ì¤€ë¹„ ì™„ë£Œ!';
                document.getElementById('play-btn').disabled = false;
                document.getElementById('stop-btn').disabled = false;
                document.getElementById('regen-btn').disabled = false;
                document.getElementById('save-btn').disabled = false;
                document.getElementById('load-chart-btn').disabled = false;
                document.getElementById('edit-mode-btn').disabled = false;
                document.getElementById('override-bpm-btn').disabled = false;
                document.getElementById('offset-minus-btn').disabled = false;
                document.getElementById('offset-plus-btn').disabled = false;
                document.getElementById('tap-bpm-btn').disabled = false;
                document.getElementById('mark-beat-btn').disabled = false;
                document.getElementById('toggle-onset-btn').disabled = false;

                alert(`âœ¨ ë¶„ì„ ì™„ë£Œ!\n\nBPM: ${detectedBPM.toFixed(1)}\nOffset: ${detectedOffset.toFixed(3)}s\në…¸íŠ¸: ${editorState.notes.length}ê°œ\në‚œì´ë„: ${editorState.difficulty}\n\nì¬ìƒ ë²„íŠ¼ì„ ëˆŒëŸ¬ í™•ì¸í•˜ì„¸ìš”!\nâ€» ë°•ìê°€ ì•ˆë§ìœ¼ë©´ BPMì´ë‚˜ Offsetì„ ìˆ˜ë™ ì¡°ì •í•˜ì„¸ìš”.`);

            } catch (error) {
                hideLoading();
                console.error('Error:', error);
                alert('ì˜¤ë””ì˜¤ ë¡œë“œ ì‹¤íŒ¨: ' + error.message);
            }
        }

        // BPM ë° ì²« ë¹„íŠ¸ ì˜¤í”„ì…‹ ìë™ ê°ì§€ + FFT ê¸°ë°˜ ì£¼íŒŒìˆ˜ ë¶„ì„
        async function detectBPMAndOffset(audioBuffer) {
            const sampleRate = audioBuffer.sampleRate;
            const channelData = audioBuffer.getChannelData(0);

            console.log('Starting advanced BPM detection with FFT analysis...');

            // 1. FFT ê¸°ë°˜ Onset Strength Envelope ê³„ì‚°
            const fftSize = 2048;  // FFT window size (power of 2)
            const hopSize = Math.floor(fftSize / 2); // 50% overlap

            // ì „ì²´ onset + ì£¼íŒŒìˆ˜ ëŒ€ì—­ë³„ onset + ë©œë¡œë”” ì •ë³´
            const onsetStrengths = [];
            const onsetTimes = [];
            const bassOnsets = [];      // ë² ì´ìŠ¤ ë¼ì¸ (40-100Hz) - Task #3
            const kickOnsets = [];      // í‚¥ë“œëŸ¼ (100-150Hz) - Task #3
            const snareOnsets = [];     // ìŠ¤ë„¤ì–´ (150-4000Hz)
            const hihatOnsets = [];     // í•˜ì´í–‡ (4000-12000Hz)
            const melodyStrengths = []; // ë©œë¡œë”” (200-2000Hz, spectral flux) - Task #1

            console.log(`Using simplified frequency band analysis with bass separation (Task #3)`);

            // ì´ì „ ìŠ¤í™íŠ¸ëŸ¼ ì €ì¥ (Spectral Flux ê³„ì‚°ìš©)
            let prevSpectrum = null;

            // ê° windowë§ˆë‹¤ ê°„ì†Œí™”ëœ ì£¼íŒŒìˆ˜ ëŒ€ì—­ ë¶„ì„ ìˆ˜í–‰
            // (ì „ì²´ DFT ëŒ€ì‹  í•„ìš”í•œ ì£¼íŒŒìˆ˜ ëŒ€ì—­ë§Œ ê³„ì‚° - í›¨ì”¬ ë¹ ë¦„)
            for (let i = 0; i < channelData.length - fftSize; i += hopSize) {
                const time = i / sampleRate;

                // í˜„ì¬ window ì¶”ì¶œ ë° RMS ê¸°ë°˜ ëŒ€ì—­ë³„ ì—ë„ˆì§€ ê³„ì‚°
                let bassEnergy = 0;   // Task #3: Bass line (very low freq)
                let kickEnergy = 0;   // Task #3: Kick drum (low freq)
                let snareEnergy = 0;
                let hihatEnergy = 0;
                let melodyEnergy = 0;
                let zeroCrossings = 0; // Zero-crossing rate for melody pitch detection
                let prevSample = 0;

                // Task #3: ê°„ì†Œí™”ëœ í•„í„°ë±…í¬ ë°©ì‹ - Bassì™€ Kick ë¶„ë¦¬ + Zero-Crossing for melody
                for (let j = 0; j < fftSize; j++) {
                    const sample = channelData[i + j];
                    const sampleSq = sample * sample;

                    // Zero-crossing detection (ë©œë¡œë”” pitch ë³€í™” ê°ì§€)
                    if (j > 0 && prevSample * sample < 0) {
                        zeroCrossings++;
                    }
                    prevSample = sample;

                    // Task #3: ì´ˆì €ì£¼íŒŒ ì—ë„ˆì§€ (Bass line: ì•ìª½ 1/16)
                    if (j < fftSize / 16) {
                        bassEnergy += sampleSq;
                    }
                    // Task #3: ì €ì£¼íŒŒ ì—ë„ˆì§€ (Kick: 1/16 ~ 1/8)
                    else if (j < fftSize / 8) {
                        kickEnergy += sampleSq;
                    }
                    // ì¤‘ì£¼íŒŒ ì—ë„ˆì§€ (Snare/Melody: 1/8 ~ 1/2)
                    else if (j < fftSize / 2) {
                        snareEnergy += sampleSq;
                        melodyEnergy += sampleSq * 2.0; // ë©œë¡œë”” ëŒ€ì—­
                    }
                    // ê³ ì£¼íŒŒ ì—ë„ˆì§€ (Hihat: ë‚˜ë¨¸ì§€)
                    else {
                        hihatEnergy += sampleSq;
                    }
                }

                // Zero-crossing rateë¥¼ ë©œë¡œë”” ì—ë„ˆì§€ì— ë°˜ì˜
                // ë†’ì€ ZCR = ë†’ì€ ì£¼íŒŒìˆ˜ = ë©œë¡œë””/ë³´ì»¬ ê°€ëŠ¥ì„± ë†’ìŒ
                const zcr = zeroCrossings / fftSize;
                if (zcr > 0.1 && zcr < 0.4) {  // ë©œë¡œë”” ë²”ìœ„ì˜ ZCR (ë„ˆë¬´ ë‚®ìœ¼ë©´ Bass, ë„ˆë¬´ ë†’ìœ¼ë©´ ë…¸ì´ì¦ˆ)
                    melodyEnergy *= (1 + zcr * 5); // ZCRì— ë¹„ë¡€í•´ì„œ ë©œë¡œë”” ì—ë„ˆì§€ ì¦í­
                }

                // Normalize by window size
                bassEnergy = Math.sqrt(bassEnergy / fftSize);   // Task #3
                kickEnergy = Math.sqrt(kickEnergy / fftSize);   // Task #3
                snareEnergy = Math.sqrt(snareEnergy / fftSize);
                hihatEnergy = Math.sqrt(hihatEnergy / fftSize);
                melodyEnergy = Math.sqrt(melodyEnergy / fftSize);

                // Onset detection: ì´ì „ í”„ë ˆì„ê³¼ì˜ ì°¨ì´ ê³„ì‚°
                let onset = 0;
                let bassOnset = 0;   // Task #3
                let kickOnset = 0;
                let snareOnset = 0;
                let hihatOnset = 0;
                let melodyOnset = 0;

                if (prevSpectrum !== null) {
                    // Energy difference (positive only)
                    const totalEnergy = bassEnergy + kickEnergy + snareEnergy + hihatEnergy + melodyEnergy;
                    const prevTotalEnergy = prevSpectrum[0] + prevSpectrum[1] + prevSpectrum[2] + prevSpectrum[3] + prevSpectrum[4];

                    onset = Math.max(0, totalEnergy - prevTotalEnergy);
                    bassOnset = Math.max(0, bassEnergy - prevSpectrum[0]); // Task #3
                    kickOnset = Math.max(0, kickEnergy - prevSpectrum[1]); // Task #3
                    snareOnset = Math.max(0, snareEnergy - prevSpectrum[2]);
                    hihatOnset = Math.max(0, hihatEnergy - prevSpectrum[3]);

                    // Task #1: ë©œë¡œë”” onset - ì—ë„ˆì§€ ë³€í™”ê°€ ì¶©ë¶„íˆ í´ ë•Œë§Œ
                    const melodyDiff = melodyEnergy - prevSpectrum[4];
                    if (melodyDiff > prevSpectrum[4] * 0.2) {  // ì´ì „ ëŒ€ë¹„ 20% ì´ìƒ ì¦ê°€
                        melodyOnset = melodyDiff;
                    } else {
                        melodyOnset = 0;  // ì‘ì€ ë³€í™”ëŠ” ë¬´ì‹œ
                    }
                }

                onsetStrengths.push(onset);
                bassOnsets.push(bassOnset);   // Task #3
                kickOnsets.push(kickOnset);
                snareOnsets.push(snareOnset);
                hihatOnsets.push(hihatOnset);
                melodyStrengths.push(melodyOnset); // Task #1
                onsetTimes.push(time);

                // Store current energies for next iteration (Task #3: 5 bands now)
                prevSpectrum = [bassEnergy, kickEnergy, snareEnergy, hihatEnergy, melodyEnergy];
            }

            // 2. Normalize onset strengths
            const maxOnset = Math.max(...onsetStrengths);
            const maxBass = Math.max(...bassOnsets);   // Task #3
            const maxKick = Math.max(...kickOnsets);
            const maxSnare = Math.max(...snareOnsets);
            const maxHihat = Math.max(...hihatOnsets);
            const maxMelody = Math.max(...melodyStrengths);

            const normalizedOnsets = onsetStrengths.map(o => o / maxOnset);
            const normalizedBass = bassOnsets.map(o => o / maxBass);   // Task #3
            const normalizedKick = kickOnsets.map(o => o / maxKick);
            const normalizedSnare = snareOnsets.map(o => o / maxSnare);
            const normalizedHihat = hihatOnsets.map(o => o / maxHihat);
            const normalizedMelody = melodyStrengths.map(o => o / maxMelody); // Task #1

            // Calculate onset statistics
            const strongOnsets = normalizedOnsets.filter(o => o > 0.3).length;
            const bassCount = normalizedBass.filter(o => o > 0.3).length;   // Task #3
            const kickCount = normalizedKick.filter(o => o > 0.3).length;
            const snareCount = normalizedSnare.filter(o => o > 0.3).length;
            const hihatCount = normalizedHihat.filter(o => o > 0.3).length;
            const melodyCount = normalizedMelody.filter(o => o > 0.3).length; // Task #1

            console.log(`Calculated ${normalizedOnsets.length} onset frames`);
            console.log(`Strong onsets (>0.3): ${strongOnsets}`);
            console.log(`Frequency bands - Bass: ${bassCount}, Kick: ${kickCount}, Snare: ${snareCount}, Hihat: ${hihatCount}, Melody: ${melodyCount}`);

            // 3. Autocorrelation for tempo detection
            const minBPM = 60;
            const maxBPM = 200;
            const minInterval = Math.floor((60 / maxBPM) / (hopSize / sampleRate));
            const maxInterval = Math.floor((60 / minBPM) / (hopSize / sampleRate));

            let bestCorr = 0;
            let bestLag = 0;

            // Calculate autocorrelation with normalization
            for (let lag = minInterval; lag <= maxInterval; lag++) {
                let corr = 0;
                let norm = 0;

                for (let i = 0; i < normalizedOnsets.length - lag; i++) {
                    corr += normalizedOnsets[i] * normalizedOnsets[i + lag];
                    norm += normalizedOnsets[i] * normalizedOnsets[i];
                }

                // Normalize correlation
                if (norm > 0) {
                    corr = corr / Math.sqrt(norm);
                }

                if (corr > bestCorr) {
                    bestCorr = corr;
                    bestLag = lag;
                }
            }

            // 4. Calculate BPM from best lag
            const beatInterval = bestLag * (hopSize / sampleRate);
            let detectedBPM = 60 / beatInterval;

            console.log(`Raw BPM: ${detectedBPM.toFixed(1)}, Correlation: ${bestCorr.toFixed(3)}`);

            // 5. BPM adjustment (handle octave errors)
            // Try multiples and divisions to find the most musical tempo
            const candidates = [detectedBPM, detectedBPM * 2, detectedBPM / 2, detectedBPM * 3, detectedBPM / 3];
            let finalBPM = detectedBPM;

            for (const candidate of candidates) {
                if (candidate >= 80 && candidate <= 180) {
                    finalBPM = candidate;
                    break;
                }
            }

            // Round to nearest 0.5
            finalBPM = Math.round(finalBPM * 2) / 2;

            console.log(`Final BPM: ${finalBPM}`);

            // 6. First beat offset detection (improved)
            // Find the first ANY onset (ìŒì•…ì˜ ì‹¤ì œ ì‹œì‘ì ) - not just strong ones!
            const threshold = 0.1; // 10% of max (ì•½í•œ ë¹„íŠ¸ë„ ê°ì§€)
            let firstBeatIndex = -1;

            for (let i = 0; i < normalizedOnsets.length; i++) {
                if (normalizedOnsets[i] > threshold) {
                    firstBeatIndex = i;
                    break;
                }
            }

            const firstBeatTime = firstBeatIndex !== -1 ? onsetTimes[firstBeatIndex] : 0;

            // Align to beat grid
            const beatDuration = 60 / finalBPM;

            // IMPORTANT: BPM ê·¸ë¦¬ë“œì— ë§ì¶°ì„œ offset ê³„ì‚°
            // firstBeatTimeì„ ê°€ì¥ ê°€ê¹Œìš´ ë°•ìì— ì •ë ¬
            const beatPosition = Math.round(firstBeatTime / beatDuration);
            let offset = beatPosition * beatDuration;

            // í•˜ì§€ë§Œ ìŒì•…ì´ ì•„ì˜ˆ ì²˜ìŒë¶€í„° ì‹œì‘í•œë‹¤ë©´ offset = 0
            if (firstBeatTime < beatDuration * 2) {
                offset = 0;
                console.log(`First beat at ${firstBeatTime.toFixed(3)}s (very early), setting offset to 0`);
            } else {
                console.log(`First beat at ${firstBeatTime.toFixed(3)}s, aligned offset: ${offset.toFixed(3)}s`);
            }

            // ì²« 4ë§ˆë””ì˜ ê°•í•œ ë¹„íŠ¸ë“¤ì„ ì¶œë ¥í•´ì„œ í™•ì¸
            console.log('First 4 measures strong beats:');
            for (let i = 0; i < Math.min(16, normalizedOnsets.length); i++) {
                if (normalizedOnsets[i] > 0.4) {
                    const beatPos = (onsetTimes[i] - offset) / beatDuration;
                    console.log(`  ${onsetTimes[i].toFixed(2)}s (beat ${beatPos.toFixed(2)}) - strength ${normalizedOnsets[i].toFixed(2)}`);
                }
            }

            // 7. Music Structure Recognition (Task #2)
            // ì—ë„ˆì§€ ë³€í™”ë¥¼ ë¶„ì„í•´ì„œ ê³¡ì˜ êµ¬ì¡°(Intro/Verse/Chorus)ë¥¼ ê°ì§€
            const musicStructure = detectMusicStructure(normalizedOnsets, onsetTimes, audioBuffer.duration, finalBPM);
            console.log(`Detected ${musicStructure.length} music sections`);

            return {
                bpm: finalBPM,
                offset: offset,
                confidence: bestCorr,
                onsets: normalizedOnsets,      // Overall onset strengths
                onsetTimes: onsetTimes,
                bassOnsets: normalizedBass,    // Bass line onsets (40-100Hz) - Task #3
                kickOnsets: normalizedKick,    // Kick drum onsets (100-150Hz) - Task #3
                snareOnsets: normalizedSnare,  // Snare drum onsets (150-4000Hz)
                hihatOnsets: normalizedHihat,  // Hi-hat onsets (4000-12000Hz)
                melodyOnsets: normalizedMelody, // Melody onsets (200-2000Hz) - Task #1
                musicStructure: musicStructure  // Music structure sections - Task #2
            };
        }

        // Task #2: Music Structure Detection
        // ì—ë„ˆì§€ ë ˆë²¨ ë³€í™”ë¥¼ ë¶„ì„í•˜ì—¬ ê³¡ì˜ êµ¬ì¡°(Intro/Verse/Chorus/Bridge/Outro)ë¥¼ ê°ì§€
        function detectMusicStructure(onsets, onsetTimes, duration, bpm) {
            const sections = [];

            // ì—ë„ˆì§€ë¥¼ ì¼ì • ì‹œê°„ ë‹¨ìœ„ë¡œ í‰ê· ë‚´ì„œ ë¶„ì„ (4ë§ˆë”” = 16ë°•ì ë‹¨ìœ„)
            const beatDuration = 60 / bpm;
            const sectionDuration = beatDuration * 16; // 4ë§ˆë””
            const numSections = Math.ceil(duration / sectionDuration);

            console.log(`Analyzing music structure: ${numSections} sections (${sectionDuration.toFixed(1)}s each)`);

            // ê° ì„¹ì…˜ì˜ í‰ê·  ì—ë„ˆì§€ ê³„ì‚°
            const sectionEnergies = [];
            for (let i = 0; i < numSections; i++) {
                const startTime = i * sectionDuration;
                const endTime = Math.min((i + 1) * sectionDuration, duration);

                // ì´ ì‹œê°„ ë²”ìœ„ì˜ onsetë“¤ì˜ í‰ê·  ì—ë„ˆì§€
                const sectionOnsets = onsets.filter((_, idx) => {
                    const t = onsetTimes[idx];
                    return t >= startTime && t < endTime;
                });

                const avgEnergy = sectionOnsets.length > 0
                    ? sectionOnsets.reduce((sum, o) => sum + o, 0) / sectionOnsets.length
                    : 0;

                sectionEnergies.push(avgEnergy);
            }

            // ì „ì²´ ê³¡ì˜ í‰ê· /ìµœëŒ€ ì—ë„ˆì§€
            const avgEnergy = sectionEnergies.reduce((sum, e) => sum + e, 0) / sectionEnergies.length;
            const maxEnergy = Math.max(...sectionEnergies);

            console.log(`Energy stats - Avg: ${avgEnergy.toFixed(3)}, Max: ${maxEnergy.toFixed(3)}`);

            // ê° ì„¹ì…˜ì„ ë¶„ë¥˜
            for (let i = 0; i < numSections; i++) {
                const startTime = i * sectionDuration;
                const endTime = Math.min((i + 1) * sectionDuration, duration);
                const energy = sectionEnergies[i];
                const energyRatio = energy / avgEnergy;

                let sectionType = 'Verse';
                let densityMultiplier = 1.0;

                // ì—ë„ˆì§€ ë ˆë²¨ë¡œ ì„¹ì…˜ íƒ€ì… íŒë‹¨ (ë””ì œì´ë§¥ìŠ¤ ìŠ¤íƒ€ì¼ ë°€ë„)
                if (i === 0 && energyRatio < 0.7) {
                    // ì²« ì„¹ì…˜ì´ ë‚®ì€ ì—ë„ˆì§€ â†’ Intro
                    sectionType = 'Intro';
                    densityMultiplier = 0.4; // ë…¸íŠ¸ ë°€ë„ 40% (ë” ë‚®ì¶¤)
                } else if (i === numSections - 1 && energyRatio < 0.7) {
                    // ë§ˆì§€ë§‰ ì„¹ì…˜ì´ ë‚®ì€ ì—ë„ˆì§€ â†’ Outro
                    sectionType = 'Outro';
                    densityMultiplier = 0.5; // ë…¸íŠ¸ ë°€ë„ 50% (ë” ë‚®ì¶¤)
                } else if (energyRatio > 1.3) {
                    // í‰ê· ë³´ë‹¤ 30% ë†’ì€ ì—ë„ˆì§€ â†’ Chorus (ì ˆì •)
                    sectionType = 'Chorus';
                    densityMultiplier = 1.3; // ë…¸íŠ¸ ë°€ë„ 130% (ì¤„ì„)
                } else if (energyRatio > 1.1) {
                    // í‰ê· ë³´ë‹¤ 10% ë†’ì€ ì—ë„ˆì§€ â†’ Pre-Chorus
                    sectionType = 'Pre-Chorus';
                    densityMultiplier = 1.1; // ë…¸íŠ¸ ë°€ë„ 110% (ì¤„ì„)
                } else if (energyRatio < 0.8) {
                    // í‰ê· ë³´ë‹¤ ë‚®ì€ ì—ë„ˆì§€ â†’ Break/Bridge
                    sectionType = 'Break';
                    densityMultiplier = 0.6; // ë…¸íŠ¸ ë°€ë„ 60% (ë” ë‚®ì¶¤)
                } else {
                    // í‰ê·  ì—ë„ˆì§€ â†’ Verse
                    sectionType = 'Verse';
                    densityMultiplier = 1.0; // ë…¸íŠ¸ ë°€ë„ 100%
                }

                sections.push({
                    startTime: startTime,
                    endTime: endTime,
                    type: sectionType,
                    energy: energy,
                    densityMultiplier: densityMultiplier
                });

                console.log(`Section ${i}: ${startTime.toFixed(1)}-${endTime.toFixed(1)}s | ${sectionType} | Energy: ${energy.toFixed(3)} (${(energyRatio * 100).toFixed(0)}%) | Density: ${(densityMultiplier * 100).toFixed(0)}%`);
            }

            return sections;
        }

        function generateNotes() {
            editorState.notes = [];

            const beatDuration = 60 / editorState.bpm;

            console.log(`ğŸ¯ Pure Onset-Based Generation: BPM ${editorState.bpm}`);
            console.log(`âš ï¸ í™•ë¥  ì—†ìŒ! Onsetë§Œ ë³´ê³  1:1 ë…¸íŠ¸ ìƒì„±`);

            // ë‚œì´ë„ë³„ Onset thresholdë§Œ ì„¤ì • (í™•ë¥  ì œê±°!)
            const difficultySettings = {
                'Easy': {
                    threshold: 0.30,  // ê°•í•œ ë¹„íŠ¸ë§Œ
                    description: 'ê°•í•œ ë¹„íŠ¸ë§Œ'
                },
                'Normal': {
                    threshold: 0.20,  // ì¤‘ê°„ ë¹„íŠ¸
                    description: 'ì¤‘ê°„ ë¹„íŠ¸'
                },
                'Hard': {
                    threshold: 0.15,  // ì•½í•œ ë¹„íŠ¸ê¹Œì§€ (ë” ë‚®ì¶¤!)
                    description: 'ì•½í•œ ë¹„íŠ¸ê¹Œì§€'
                },
                'Expert': {
                    threshold: 0.10,  // ë§¤ìš° ì•½í•œ ë¹„íŠ¸ê¹Œì§€
                    description: 'ë§¤ìš° ì•½í•œ ë¹„íŠ¸ê¹Œì§€'
                }
            };

            const settings = difficultySettings[editorState.difficulty];
            console.log(`Difficulty: ${editorState.difficulty} - ${settings.description}, Threshold: ${settings.threshold}`);

            if (!editorState.onsets || editorState.onsets.length === 0) {
                console.error('No onset data available!');
                alert('Onset ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ìŒì›ì„ ë‹¤ì‹œ ë¡œë“œí•˜ì„¸ìš”.');
                return;
            }

            let lastLane = 0;  // ë ˆì¸ êµëŒ€ íŒ¨í„´ìš©
            let lastLeftLane = 0;  // ì™¼ì† ë§ˆì§€ë§‰ ë ˆì¸ (D/F êµëŒ€ìš©)
            let lastRightLane = 3;  // ì˜¤ë¥¸ì† ë§ˆì§€ë§‰ ë ˆì¸ (J/K êµëŒ€ìš©)
            let processedOnsets = 0;
            let skippedWeak = 0;
            let skippedDuplicate = 0;

            console.log(`Processing ${editorState.onsets.length} onsets...`);

            // Onset ì§ì ‘ ìˆœíšŒ (BPM ê·¸ë¦¬ë“œ ë¬´ì‹œ!)
            for (let i = 0; i < editorState.onsets.length; i++) {
                const onsetStrength = editorState.onsets[i];
                const onsetTime = editorState.onsetTimes[i];

                processedOnsets++;

                // 1. Threshold ì²´í¬ (ë‚œì´ë„ë³„)
                if (onsetStrength < settings.threshold) {
                    skippedWeak++;
                    continue;
                }

                // 2. ìŒì› ë²”ìœ„ ì²´í¬
                if (onsetTime < 0 || onsetTime > editorState.duration) {
                    continue;
                }

                // 3. BPM ê·¸ë¦¬ë“œì— ìŠ¤ëƒ… (ê°€ì¥ ê°€ê¹Œìš´ 1/16ë°•)
                const beatPosition = (onsetTime - editorState.offset) / beatDuration;
                const snapDivisor = 16;
                const snappedBeat = Math.round(beatPosition * snapDivisor) / snapDivisor;
                const snappedTime = snappedBeat * beatDuration + editorState.offset;

                // 4. ìœ íš¨ ë²”ìœ„ ì¬í™•ì¸
                if (snappedTime < 0 || snappedTime > editorState.duration) {
                    continue;
                }

                // 5. ì¤‘ë³µ ë°©ì§€ (50ms ì´ë‚´)
                const isDuplicate = editorState.notes.some(note =>
                    Math.abs(note.time - snappedTime) < 0.05
                );
                if (isDuplicate) {
                    skippedDuplicate++;
                    continue;
                }

                // 6. ë ˆì¸ ê²°ì • - ë“œëŸ¼ íƒ€ì… ê¸°ë°˜ + ì¢Œìš° ê· í˜•
                let lane = 0;
                const kickStrength = editorState.kickOnsets[i] || 0;
                const snareStrength = editorState.snareOnsets[i] || 0;
                const hihatStrength = editorState.hihatOnsets[i] || 0;
                const maxDrumStrength = Math.max(kickStrength, snareStrength, hihatStrength);

                let isLeftHand = (lastLane === 0 || lastLane === 1);

                if (kickStrength === maxDrumStrength && kickStrength > 0.15) {
                    // Kick â†’ ì™¼ì† êµëŒ€ (Dâ†”F) - ì™¼ì† ì „ìš© íŠ¸ë˜ì»¤ ì‚¬ìš©!
                    lane = (lastLeftLane === 0) ? 1 : 0;  // Dâ†”F í™•ì‹¤í•œ êµëŒ€
                    lastLeftLane = lane;  // ì™¼ì† ë§ˆì§€ë§‰ ë ˆì¸ ì—…ë°ì´íŠ¸
                } else if (snareStrength === maxDrumStrength && snareStrength > 0.15) {
                    // Snare â†’ ì˜¤ë¥¸ì† êµëŒ€ (Jâ†”K) - ì˜¤ë¥¸ì† ì „ìš© íŠ¸ë˜ì»¤ ì‚¬ìš©!
                    lane = (lastRightLane === 3) ? 4 : 3;  // Jâ†”K í™•ì‹¤í•œ êµëŒ€
                    lastRightLane = lane;  // ì˜¤ë¥¸ì† ë§ˆì§€ë§‰ ë ˆì¸ ì—…ë°ì´íŠ¸
                } else if (hihatStrength === maxDrumStrength && hihatStrength > 0.15) {
                    // Hi-hat â†’ ì˜¤ë¥¸ì† êµëŒ€ (Jâ†”K)
                    lane = (lastRightLane === 3) ? 4 : 3;
                    lastRightLane = lane;
                } else {
                    // ë“œëŸ¼ì´ ëª…í™•í•˜ì§€ ì•Šìœ¼ë©´ ì¢Œìš° êµëŒ€ (ê· í˜• ìœ ì§€)
                    if (isLeftHand) {
                        // ì™¼ì† â†’ ì˜¤ë¥¸ì†ìœ¼ë¡œ
                        lane = (lastRightLane === 3) ? 4 : 3;
                        lastRightLane = lane;
                    } else {
                        // ì˜¤ë¥¸ì† â†’ ì™¼ì†ìœ¼ë¡œ
                        lane = (lastLeftLane === 0) ? 1 : 0;
                        lastLeftLane = lane;
                    }
                }

                // 7. ë…¸íŠ¸ ì¶”ê°€ (í™•ë¥  ì—†ì´ ë¬´ì¡°ê±´!)
                editorState.notes.push({
                    time: parseFloat(snappedTime.toFixed(3)),
                    lane: lane
                });

                lastLane = lane;
            }

            editorState.notes.sort((a, b) => a.time - b.time);

            console.log(`âœ… Generated ${editorState.notes.length} notes`);
            console.log(`ğŸ“Š Stats:`);
            console.log(`   - Processed onsets: ${processedOnsets}`);
            console.log(`   - Created notes: ${editorState.notes.length}`);
            console.log(`   - Skipped (too weak): ${skippedWeak}`);
            console.log(`   - Skipped (duplicate): ${skippedDuplicate}`);

            if (editorState.notes.length > 0) {
                const firstNote = editorState.notes[0];
                const lastNote = editorState.notes[editorState.notes.length - 1];
                console.log(`â±ï¸ First: ${firstNote.time.toFixed(3)}s, Last: ${lastNote.time.toFixed(3)}s`);

                // ë ˆì¸ ë¶„í¬ í†µê³„
                const laneCounts = [0, 0, 0, 0, 0];
                editorState.notes.forEach(note => laneCounts[note.lane]++);
                const totalNotes = editorState.notes.length;
                console.log(`ğŸ¹ Lane distribution:`);
                console.log(`   D(0): ${laneCounts[0]} (${(laneCounts[0]/totalNotes*100).toFixed(1)}%)`);
                console.log(`   F(1): ${laneCounts[1]} (${(laneCounts[1]/totalNotes*100).toFixed(1)}%)`);
                console.log(`   Space(2): ${laneCounts[2]} (${(laneCounts[2]/totalNotes*100).toFixed(1)}%)`);
                console.log(`   J(3): ${laneCounts[3]} (${(laneCounts[3]/totalNotes*100).toFixed(1)}%)`);
                console.log(`   K(4): ${laneCounts[4]} (${(laneCounts[4]/totalNotes*100).toFixed(1)}%)`);

                // NPS (Notes Per Second) ê³„ì‚°
                const nps = (editorState.notes.length / editorState.duration).toFixed(2);
                console.log(`ğŸ“ˆ Average NPS: ${nps}`);
            }

            updateStats();
        }

        function regenerateNotes() {
            if (!editorState.audioBuffer) {
                alert('ë¨¼ì € ìŒì›ì„ ë¡œë“œí•˜ì„¸ìš”.');
                return;
            }

            if (confirm('ë…¸íŠ¸ë¥¼ ë‹¤ì‹œ ìƒì„±í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                generateNotes();
                alert(`ğŸ”„ ì¬ìƒì„± ì™„ë£Œ!\n\në…¸íŠ¸: ${editorState.notes.length}ê°œ\në‚œì´ë„: ${editorState.difficulty}`);
            }
        }

        async function initEditor() {
            calculateDimensions();

            app = new PIXI.Application();
            await app.init({
                width: GAME_WIDTH,
                height: GAME_HEIGHT,
                backgroundColor: 0x0a0a0a,
                antialias: true,
                resolution: window.devicePixelRatio || 1
            });

            document.getElementById('editor-canvas').appendChild(app.canvas);

            gameContainer = new PIXI.Container();
            gridContainer = new PIXI.Container();
            beatGridContainer = new PIXI.Container();
            onsetMarkersContainer = new PIXI.Container();
            notesContainer = new PIXI.Container();

            app.stage.addChild(gameContainer);
            app.stage.addChild(gridContainer);
            app.stage.addChild(beatGridContainer);
            app.stage.addChild(onsetMarkersContainer);
            app.stage.addChild(notesContainer);

            drawLanes();
            drawJudgmentLine();

            app.ticker.add(editorLoop);

            window.addEventListener('resize', () => {
                calculateDimensions();
                if (app) {
                    app.renderer.resize(GAME_WIDTH, GAME_HEIGHT);
                    gameContainer.removeChildren();
                    gridContainer.removeChildren();
                    drawLanes();
                    drawJudgmentLine();
                }
            });
        }

        function drawLanes() {
            for (let i = 0; i < LANES.length; i++) {
                const lane = new PIXI.Graphics();

                lane.rect(i * LANE_WIDTH, 0, LANE_WIDTH, GAME_HEIGHT / 2);
                lane.fill({ color: 0x16213e, alpha: 0.2 });

                lane.rect(i * LANE_WIDTH, GAME_HEIGHT / 2, LANE_WIDTH, GAME_HEIGHT / 2);
                lane.fill({ color: 0x16213e, alpha: 0.4 });

                lane.moveTo(i * LANE_WIDTH, 0);
                lane.lineTo(i * LANE_WIDTH, GAME_HEIGHT);
                lane.stroke({ color: LANES[i].color, width: 2, alpha: 0.5 });

                gameContainer.addChild(lane);

                const keyText = new PIXI.Text({
                    text: LANES[i].label,
                    style: {
                        fontSize: 28,
                        fill: LANES[i].color,
                        fontWeight: 'bold',
                        fontFamily: 'Orbitron'
                    }
                });
                keyText.anchor.set(0.5);
                keyText.x = i * LANE_WIDTH + LANE_WIDTH / 2;
                keyText.y = GAME_HEIGHT - 30;
                gameContainer.addChild(keyText);
            }
        }

        function drawJudgmentLine() {
            const line = new PIXI.Graphics();
            line.moveTo(0, JUDGMENT_LINE_Y);
            line.lineTo(GAME_WIDTH, JUDGMENT_LINE_Y);
            line.stroke({ color: 0xFFFFFF, width: 4 });

            const glow = new PIXI.Graphics();
            glow.moveTo(0, JUDGMENT_LINE_Y);
            glow.lineTo(GAME_WIDTH, JUDGMENT_LINE_Y);
            glow.stroke({ color: 0xFFFFFF, width: 20, alpha: 0.2 });

            gameContainer.addChild(glow);
            gameContainer.addChild(line);
        }

        function addNote(laneIndex, time) {
            const note = {
                time: parseFloat(time.toFixed(3)),
                lane: laneIndex
            };

            editorState.notes.push(note);
            editorState.notes.sort((a, b) => a.time - b.time);
            updateStats();
        }

        function deleteLastNote() {
            if (editorState.notes.length > 0) {
                editorState.notes.pop();
                updateStats();
            }
        }

        function showKeyFlash(laneIndex) {
            const flash = new PIXI.Graphics();
            flash.rect(laneIndex * LANE_WIDTH, JUDGMENT_LINE_Y - 50, LANE_WIDTH, 100);
            flash.fill({ color: LANES[laneIndex].color, alpha: 0.6 });
            gameContainer.addChild(flash);

            setTimeout(() => {
                gameContainer.removeChild(flash);
            }, 100);
        }

        function togglePlayback() {
            if (editorState.isPlaying) {
                pausePlayback();
            } else {
                startPlayback();
            }
        }

        function startPlayback() {
            if (!editorState.audioBuffer) {
                alert('ë¨¼ì € ìŒì›ì„ ë¡œë“œí•˜ì„¸ìš”.');
                return;
            }

            if (editorState.audioSource) {
                editorState.audioSource.stop();
            }

            editorState.audioSource = editorState.audioContext.createBufferSource();
            editorState.audioSource.buffer = editorState.audioBuffer;
            editorState.audioSource.connect(editorState.audioContext.destination);

            const offset = editorState.currentTime || 0;
            editorState.audioSource.start(0, offset);
            editorState.startTime = editorState.audioContext.currentTime - offset;
            editorState.isPlaying = true;

            document.getElementById('status').textContent = 'ì¬ìƒ ì¤‘';
            document.getElementById('play-btn').textContent = 'â¸ ì¼ì‹œì •ì§€';

            editorState.audioSource.onended = () => {
                stopPlayback();
            };
        }

        function pausePlayback() {
            if (editorState.audioSource) {
                editorState.audioSource.stop();
                editorState.audioSource = null;
            }
            editorState.isPlaying = false;
            document.getElementById('status').textContent = 'ì¼ì‹œì •ì§€';
            document.getElementById('play-btn').textContent = 'â–¶ ì¬ìƒ';
        }

        function stopPlayback() {
            if (editorState.audioSource) {
                editorState.audioSource.stop();
                editorState.audioSource = null;
            }
            editorState.isPlaying = false;
            editorState.currentTime = 0;
            document.getElementById('status').textContent = 'ì •ì§€';
            document.getElementById('play-btn').textContent = 'â–¶ ì¬ìƒ';
        }

        function editorLoop(ticker) {
            if (editorState.isPlaying && editorState.audioContext) {
                editorState.currentTime = editorState.audioContext.currentTime - editorState.startTime;
                document.getElementById('current-time').textContent = editorState.currentTime.toFixed(2) + 's';

                if (editorState.bpm > 0) {
                    const currentBeat = Math.floor((editorState.currentTime - editorState.offset) / (60 / editorState.bpm)) + 1;
                    document.getElementById('current-beat').textContent = currentBeat;
                }
            }

            // Draw beat grid lines
            beatGridContainer.removeChildren();
            if (editorState.bpm > 0) {
                const beatDuration = 60 / editorState.bpm;
                const NOTE_SPEED = 200;

                // Draw beat lines within visible range
                const visibleTime = GAME_HEIGHT / NOTE_SPEED;
                const startBeat = Math.floor((editorState.currentTime - editorState.offset) / beatDuration);
                const endBeat = Math.ceil((editorState.currentTime + visibleTime - editorState.offset) / beatDuration);

                for (let beat = startBeat; beat <= endBeat; beat++) {
                    const beatTime = beat * beatDuration + editorState.offset;
                    const timeDiff = beatTime - editorState.currentTime;
                    const lineY = JUDGMENT_LINE_Y - timeDiff * NOTE_SPEED;

                    if (lineY > -10 && lineY < GAME_HEIGHT + 10) {
                        const line = new PIXI.Graphics();

                        // Different colors for different beat types
                        if (beat % 4 === 0) {
                            // Measure line (white, thick)
                            line.moveTo(0, lineY);
                            line.lineTo(GAME_WIDTH, lineY);
                            line.stroke({ color: 0xFFFFFF, width: 2, alpha: 0.4 });
                        } else {
                            // Regular beat line (gray, thin)
                            line.moveTo(0, lineY);
                            line.lineTo(GAME_WIDTH, lineY);
                            line.stroke({ color: 0x888888, width: 1, alpha: 0.2 });
                        }

                        beatGridContainer.addChild(line);
                    }
                }
            }

            // Draw onset markers if enabled
            onsetMarkersContainer.removeChildren();
            if (editorState.showOnsets && editorState.onsets && editorState.onsets.length > 0) {
                const NOTE_SPEED = 200;
                const visibleTime = GAME_HEIGHT / NOTE_SPEED;

                // Get difficulty threshold to show which onsets become notes
                const difficultyThresholds = {
                    'Easy': 0.6,
                    'Normal': 0.45,
                    'Hard': 0.35,
                    'Expert': 0.25
                };
                const threshold = difficultyThresholds[editorState.difficulty] || 0.35;

                for (let i = 0; i < editorState.onsets.length; i++) {
                    const onsetTime = editorState.onsetTimes[i];
                    const onsetStrength = editorState.onsets[i];
                    const timeDiff = onsetTime - editorState.currentTime;

                    // Only draw onsets in visible range
                    if (Math.abs(timeDiff) > visibleTime) continue;

                    const lineY = JUDGMENT_LINE_Y - timeDiff * NOTE_SPEED;

                    if (lineY > -10 && lineY < GAME_HEIGHT + 10) {
                        const line = new PIXI.Graphics();

                        // Color based on onset strength
                        let color, alpha, width;
                        if (onsetStrength >= threshold) {
                            // Strong onset (becomes a note) - bright cyan
                            color = 0x00FFFF;
                            alpha = 0.8;
                            width = 3;
                        } else if (onsetStrength >= threshold * 0.7) {
                            // Medium onset - yellow
                            color = 0xFFFF00;
                            alpha = 0.5;
                            width = 2;
                        } else if (onsetStrength >= threshold * 0.4) {
                            // Weak onset - orange
                            color = 0xFFA500;
                            alpha = 0.3;
                            width = 1;
                        } else {
                            // Very weak - skip to reduce clutter
                            continue;
                        }

                        line.moveTo(0, lineY);
                        line.lineTo(GAME_WIDTH, lineY);
                        line.stroke({ color: color, width: width, alpha: alpha });

                        // Add drum type indicator on the right
                        if (onsetStrength >= threshold) {
                            const kickStrength = editorState.kickOnsets[i] || 0;
                            const snareStrength = editorState.snareOnsets[i] || 0;
                            const hihatStrength = editorState.hihatOnsets[i] || 0;
                            const maxDrumStrength = Math.max(kickStrength, snareStrength, hihatStrength);

                            let drumIndicator = '';
                            let indicatorColor = 0xFFFFFF;
                            if (kickStrength === maxDrumStrength && maxDrumStrength > 0.2) {
                                drumIndicator = 'K';
                                indicatorColor = 0xFF6B6B;
                            } else if (snareStrength === maxDrumStrength && maxDrumStrength > 0.2) {
                                drumIndicator = 'S';
                                indicatorColor = 0x4ECDC4;
                            } else if (hihatStrength === maxDrumStrength && maxDrumStrength > 0.2) {
                                drumIndicator = 'H';
                                indicatorColor = 0xFFE66D;
                            }

                            if (drumIndicator) {
                                const text = new PIXI.Text({
                                    text: drumIndicator,
                                    style: {
                                        fontSize: 12,
                                        fill: indicatorColor,
                                        fontWeight: 'bold',
                                        fontFamily: 'Orbitron'
                                    }
                                });
                                text.anchor.set(0, 0.5);
                                text.x = GAME_WIDTH - 20;
                                text.y = lineY;
                                onsetMarkersContainer.addChild(text);
                            }
                        }

                        onsetMarkersContainer.addChild(line);
                    }
                }
            }

            notesContainer.removeChildren();

            const NOTE_HEIGHT = 20;
            const NOTE_SPEED = 200;

            for (let i = 0; i < editorState.notes.length; i++) {
                const note = editorState.notes[i];
                const timeDiff = note.time - editorState.currentTime;
                const noteY = JUDGMENT_LINE_Y - timeDiff * NOTE_SPEED;

                if (noteY > -50 && noteY < GAME_HEIGHT + 50) {
                    const noteSprite = new PIXI.Graphics();
                    noteSprite.roundRect(0, 0, LANE_WIDTH - 10, NOTE_HEIGHT, 8);

                    let noteColor = LANES[note.lane].color;

                    // ì„ íƒëœ ë…¸íŠ¸ëŠ” ë°ê²Œ í‘œì‹œ
                    const isSelected = editorState.selectedNotes.has(i);
                    const alpha = isSelected ? 1.0 : 0.9;
                    noteSprite.fill({ color: noteColor, alpha: alpha });

                    noteSprite.roundRect(0, 0, LANE_WIDTH - 10, NOTE_HEIGHT, 8);

                    // ì„ íƒëœ ë…¸íŠ¸ëŠ” ë…¸ë€ìƒ‰ í…Œë‘ë¦¬
                    const strokeColor = isSelected ? 0xFFFF00 : 0xFFFFFF;
                    const strokeWidth = isSelected ? 4 : 2;
                    noteSprite.stroke({ color: strokeColor, width: strokeWidth, alpha: isSelected ? 1.0 : 0.5 });

                    noteSprite.x = note.lane * LANE_WIDTH + 5;
                    noteSprite.y = noteY - NOTE_HEIGHT / 2;

                    // í¸ì§‘ ëª¨ë“œì—ì„œ í´ë¦­ ê°€ëŠ¥í•˜ë„ë¡ ì„¤ì •
                    if (editorState.editMode) {
                        noteSprite.interactive = true;
                        noteSprite.cursor = 'pointer';
                        noteSprite.eventMode = 'static';

                        noteSprite.on('pointerdown', (event) => {
                            if (editorState.selectedNotes.has(i)) {
                                editorState.selectedNotes.delete(i);
                                console.log(`âŒ ë…¸íŠ¸ ì„ íƒ í•´ì œ: ${i} (ì‹œê°„: ${note.time.toFixed(3)}s, ë ˆì¸: ${note.lane})`);
                            } else {
                                editorState.selectedNotes.add(i);
                                console.log(`âœ… ë…¸íŠ¸ ì„ íƒ: ${i} (ì‹œê°„: ${note.time.toFixed(3)}s, ë ˆì¸: ${note.lane})`);
                            }
                            console.log(`   ì´ ì„ íƒëœ ë…¸íŠ¸: ${editorState.selectedNotes.size}ê°œ`);
                        });
                    }

                    notesContainer.addChild(noteSprite);
                }
            }

            updateMinimap();
        }

        function updateStats() {
            document.getElementById('note-count').textContent = editorState.notes.length;

            if (editorState.duration > 0) {
                const nps = (editorState.notes.length / editorState.duration).toFixed(1);
                document.getElementById('nps-display').textContent = nps;
            }

            updateDensityGraph();
        }

        function updateDensityGraph() {
            const canvas = document.getElementById('density-graph');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (editorState.duration === 0 || editorState.notes.length === 0) return;

            const windowSize = 1;
            const windows = Math.ceil(editorState.duration / windowSize);
            const densities = [];

            for (let i = 0; i < windows; i++) {
                const start = i * windowSize;
                const end = (i + 1) * windowSize;
                const count = editorState.notes.filter(n => n.time >= start && n.time < end).length;
                densities.push(count);
            }

            const maxDensity = Math.max(...densities, 1);

            ctx.fillStyle = '#667eea';
            densities.forEach((density, i) => {
                const x = (i / windows) * canvas.width;
                const width = canvas.width / windows;
                const height = (density / maxDensity) * canvas.height;
                const y = canvas.height - height;

                ctx.fillRect(x, y, width, height);
            });

            if (editorState.duration > 0) {
                const x = (editorState.currentTime / editorState.duration) * canvas.width;
                ctx.strokeStyle = '#FF6B6B';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
        }

        function updateMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (editorState.duration === 0) return;

            editorState.notes.forEach(note => {
                const x = (note.time / editorState.duration) * canvas.width;
                const y = (note.lane / LANES.length) * canvas.height;
                const width = Math.max(2, canvas.width / 100);
                const height = canvas.height / LANES.length;

                let color = `#${LANES[note.lane].color.toString(16).padStart(6, '0')}`;

                ctx.fillStyle = color;
                ctx.fillRect(x, y, width, height);
            });

            const x = (editorState.currentTime / editorState.duration) * canvas.width;
            ctx.strokeStyle = '#FF6B6B';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }

        function saveChart() {
            const title = editorState.title || 'Untitled';
            const bpm = editorState.bpm;
            const difficulty = editorState.difficulty;

            const chartData = {
                title,
                bpm,
                offset: editorState.offset,
                difficulty,
                duration: editorState.duration,
                lanes: LANES.length,
                notes: editorState.notes,
                audioFileName: editorState.audioFileName,  // ì˜¤ë””ì˜¤ íŒŒì¼ ì´ë¦„ ì €ì¥
                metadata: {
                    nps: (editorState.notes.length / editorState.duration).toFixed(2),
                    noteCount: editorState.notes.length,
                    createdAt: new Date().toISOString(),
                    editor: 'BEAT MASTER Auto'
                }
            };

            const dataStr = JSON.stringify(chartData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);

            const link = document.createElement('a');
            link.href = url;
            link.download = `${title.replace(/[^a-z0-9]/gi, '_')}_${difficulty}_chart.json`;
            link.click();

            URL.revokeObjectURL(url);
            alert('ì°¨íŠ¸ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
        }

        function loadChart() {
            const input = document.getElementById('load-chart-input');
            const file = input.files[0];

            if (!file) {
                alert('íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const chartData = JSON.parse(e.target.result);

                    // ì°¨íŠ¸ ë°ì´í„° ë¡œë“œ
                    editorState.notes = chartData.notes || [];
                    editorState.bpm = chartData.bpm || 120;
                    editorState.offset = chartData.offset || 0;
                    editorState.title = chartData.title || 'Untitled';
                    editorState.difficulty = chartData.difficulty || 'Hard';
                    editorState.duration = chartData.duration || 0;
                    editorState.audioFileName = chartData.audioFileName || '';

                    // UI ì—…ë°ì´íŠ¸
                    document.getElementById('bpm-input').value = editorState.bpm;
                    document.getElementById('offset-input').value = editorState.offset;
                    document.getElementById('title-input').value = editorState.title;
                    document.getElementById('difficulty-select').value = editorState.difficulty;

                    // ë…¸íŠ¸ ì¬ë Œë”ë§
                    updateStats();

                    // ì˜¤ë””ì˜¤ê°€ ë¡œë“œë˜ì–´ ìˆìœ¼ë©´ í™”ë©´ ì—…ë°ì´íŠ¸
                    if (editorState.audioBuffer) {
                        render();
                    }

                    alert(`ì°¨íŠ¸ ë¡œë“œ ì™„ë£Œ!\në…¸íŠ¸: ${editorState.notes.length}ê°œ\n${chartData.audioFileName ? 'ì˜¤ë””ì˜¤ íŒŒì¼: ' + chartData.audioFileName : 'ì˜¤ë””ì˜¤ íŒŒì¼ì„ ë³„ë„ë¡œ ë¡œë“œí•´ì£¼ì„¸ìš”.'}`);

                    // ì…ë ¥ ì´ˆê¸°í™”
                    input.value = '';
                } catch (error) {
                    console.error('ì°¨íŠ¸ ë¡œë“œ ì‹¤íŒ¨:', error);
                    alert('ì°¨íŠ¸ íŒŒì¼ì„ ì½ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                }
            };

            reader.readAsText(file);
        }

        function toggleEditMode() {
            editorState.editMode = !editorState.editMode;
            const btn = document.getElementById('edit-mode-btn');
            const statusText = document.getElementById('edit-mode-status');
            const deleteBtn = document.getElementById('delete-note-btn');

            if (editorState.editMode) {
                btn.textContent = 'âœï¸ í¸ì§‘ì¤‘';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-success');
                statusText.textContent = 'í¸ì§‘ëª¨ë“œ (ë…¸íŠ¸ í´ë¦­)';
                statusText.style.color = '#38ef7d';
                deleteBtn.disabled = false;
                console.log('âœï¸ í¸ì§‘ ëª¨ë“œ í™œì„±í™”: ë…¸íŠ¸ë¥¼ í´ë¦­í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”');
            } else {
                btn.textContent = 'âœï¸ í¸ì§‘ëª¨ë“œ';
                btn.classList.remove('btn-success');
                btn.classList.add('btn-primary');
                statusText.textContent = 'ì¼ë°˜ëª¨ë“œ';
                statusText.style.color = '#aaa';
                deleteBtn.disabled = true;
                editorState.selectedNotes.clear();
                console.log('âœï¸ ì¼ë°˜ ëª¨ë“œë¡œ ì „í™˜');
            }
        }

        function deleteSelectedNotes() {
            if (editorState.selectedNotes.size === 0) {
                alert('ì‚­ì œí•  ë…¸íŠ¸ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }

            const count = editorState.selectedNotes.size;
            if (!confirm(`ì„ íƒí•œ ${count}ê°œì˜ ë…¸íŠ¸ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                return;
            }

            // ì„ íƒëœ ì¸ë±ìŠ¤ë¥¼ ë°°ì—´ë¡œ ë³€í™˜í•˜ê³  ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬ (ë’¤ì—ì„œë¶€í„° ì‚­ì œ)
            const selectedIndices = Array.from(editorState.selectedNotes).sort((a, b) => b - a);

            for (const index of selectedIndices) {
                editorState.notes.splice(index, 1);
            }

            editorState.selectedNotes.clear();
            updateStats();
            render();

            console.log(`ğŸ—‘ï¸ ${count}ê°œì˜ ë…¸íŠ¸ ì‚­ì œë¨. ë‚¨ì€ ë…¸íŠ¸: ${editorState.notes.length}ê°œ`);
            alert(`${count}ê°œì˜ ë…¸íŠ¸ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`);
        }

        function getNoteAtPosition(x, y) {
            // í™”ë©´ ì¢Œí‘œë¥¼ ê²Œì„ ì¢Œí‘œë¡œ ë³€í™˜
            const lane = Math.floor(x / LANE_WIDTH);
            if (lane < 0 || lane >= LANES.length) return -1;

            // í˜„ì¬ ì‹œê°„ ê¸°ì¤€ìœ¼ë¡œ ë…¸íŠ¸ ì°¾ê¸°
            const clickTime = editorState.currentTime + (JUDGMENT_LINE_Y - y) / (GAME_HEIGHT * 0.8);

            // í´ë¦­ ìœ„ì¹˜ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ë…¸íŠ¸ ì°¾ê¸° (0.5ì´ˆ ë²”ìœ„ ë‚´)
            let closestIndex = -1;
            let closestDistance = 0.5;  // ìµœëŒ€ 0.5ì´ˆ ë²”ìœ„

            for (let i = 0; i < editorState.notes.length; i++) {
                const note = editorState.notes[i];
                if (note.lane === lane) {
                    const distance = Math.abs(note.time - clickTime);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestIndex = i;
                    }
                }
            }

            return closestIndex;
        }

        function moveSelectedNotesToLane(targetLane) {
            if (editorState.selectedNotes.size === 0) return;

            const selectedIndices = Array.from(editorState.selectedNotes);
            for (const index of selectedIndices) {
                if (editorState.notes[index]) {
                    editorState.notes[index].lane = targetLane;
                }
            }

            updateStats();
            console.log(`ğŸ”„ ${selectedIndices.length}ê°œ ë…¸íŠ¸ë¥¼ ë ˆì¸ ${targetLane}(${LANES[targetLane].label})ë¡œ ì´ë™`);
        }

        function adjustSelectedNotesTiming(delta) {
            if (editorState.selectedNotes.size === 0) return;

            const selectedIndices = Array.from(editorState.selectedNotes);
            for (const index of selectedIndices) {
                if (editorState.notes[index]) {
                    editorState.notes[index].time += delta;
                    // ìµœì†Œ 0ì´ˆ ì œí•œ
                    if (editorState.notes[index].time < 0) {
                        editorState.notes[index].time = 0;
                    }
                }
            }

            // ë…¸íŠ¸ë¥¼ ì‹œê°„ìˆœìœ¼ë¡œ ì¬ì •ë ¬
            editorState.notes.sort((a, b) => a.time - b.time);

            updateStats();
            console.log(`â±ï¸ ${selectedIndices.length}ê°œ ë…¸íŠ¸ íƒ€ì´ë° ì¡°ì •: ${delta > 0 ? '+' : ''}${(delta * 1000).toFixed(0)}ms`);
        }
    </script>
</body>
</html>
