<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BookJam - Note Editor</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Noto+Sans+KR:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: 'Orbitron', 'Noto Sans KR', sans-serif;
            background: linear-gradient(135deg, #0F2027 0%, #203A43 50%, #2C5364 100%);
            color: white;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #control-panel {
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            padding: 15px 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            border-bottom: 2px solid rgba(102, 126, 234, 0.5);
            max-height: 120px;
            overflow-y: auto;
        }

        .control-group {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        label {
            font-size: 12px;
            color: #aaa;
            white-space: nowrap;
        }

        input[type="file"] {
            display: none;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            white-space: nowrap;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.6);
        }

        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        input[type="number"], input[type="text"], select {
            padding: 6px 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
        }

        input[type="number"] {
            width: 80px;
        }

        input[type="text"] {
            width: 150px;
        }

        select {
            width: 120px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }

        #editor-container {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }

        #left-sidebar {
            width: 200px;
            background: rgba(0, 0, 0, 0.9);
            border-right: 2px solid rgba(102, 126, 234, 0.3);
            padding: 15px;
            overflow-y: auto;
        }

        #left-sidebar h3 {
            margin-bottom: 10px;
            color: #667eea;
            font-size: 14px;
        }

        .sidebar-section {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-box {
            background: rgba(102, 126, 234, 0.15);
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 10px;
            line-height: 1.5;
        }

        #editor-canvas {
            flex: 1;
            background: #0a0a0a;
            position: relative;
        }

        #editor-canvas canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        #right-sidebar {
            width: 220px;
            background: rgba(0, 0, 0, 0.9);
            border-left: 2px solid rgba(102, 126, 234, 0.3);
            padding: 15px;
            overflow-y: auto;
        }

        #right-sidebar h3 {
            margin-bottom: 10px;
            color: #667eea;
            font-size: 14px;
        }

        .info-item {
            margin: 8px 0;
            font-size: 12px;
        }

        .info-item strong {
            color: #667eea;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .stat-box {
            background: rgba(102, 126, 234, 0.1);
            padding: 8px;
            border-radius: 4px;
            text-align: center;
        }

        .stat-box .label {
            font-size: 10px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .stat-box .value {
            font-size: 16px;
            font-weight: bold;
            color: #667eea;
        }

        .key-hint {
            background: rgba(102, 126, 234, 0.2);
            padding: 10px;
            border-radius: 6px;
            margin-top: 15px;
            font-size: 11px;
            line-height: 1.6;
        }

        .density-graph, #minimap {
            width: 100%;
            height: 80px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 6px;
            margin-top: 10px;
            border: 1px solid rgba(102, 126, 234, 0.3);
        }

        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        #loading-overlay.show {
            display: flex;
        }

        .loading-content {
            text-align: center;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <h2 id="loading-text">Î∂ÑÏÑù Ï§ë...</h2>
            <p id="loading-detail">Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî</p>
        </div>
    </div>

    <div id="container">
        <div id="control-panel">
            <div class="control-group">
                <label for="file-input" class="btn btn-primary">üìÅ ÏùåÏõê Î°úÎìú</label>
                <input type="file" id="file-input" accept="audio/*">
                <span id="file-name" style="font-size: 11px;">ÌååÏùº ÏóÜÏùå</span>
            </div>

            <div class="control-group">
                <label>BPM:</label>
                <input type="number" id="bpm-input" value="0" min="60" max="240" step="0.5">
                <button class="btn btn-primary" id="override-bpm-btn" style="padding: 6px 10px; font-size: 10px;" disabled>Ï†ÅÏö©</button>
                <button class="btn btn-success" id="tap-bpm-btn" style="padding: 6px 10px; font-size: 10px;" disabled>üéµ Tap</button>
            </div>

            <div class="control-group">
                <label>Offset:</label>
                <input type="number" id="offset-input" value="0" step="0.01" style="width: 70px;">
                <button class="btn btn-primary" id="offset-minus-btn" style="padding: 6px 8px; font-size: 10px;" disabled>-0.01</button>
                <button class="btn btn-primary" id="offset-plus-btn" style="padding: 6px 8px; font-size: 10px;" disabled>+0.01</button>
                <button class="btn btn-success" id="mark-beat-btn" style="padding: 6px 10px; font-size: 10px;" disabled>1Î∞ï</button>
            </div>

            <div class="control-group">
                <label>Ï†úÎ™©:</label>
                <input type="text" id="title-input" placeholder="Title">
            </div>

            <div class="control-group">
                <label>ÎÇúÏù¥ÎèÑ:</label>
                <select id="difficulty-select">
                    <option value="Easy">Easy</option>
                    <option value="Normal">Normal</option>
                    <option value="Hard" selected>Hard</option>
                    <option value="Expert">Expert</option>
                </select>
            </div>

            <div class="control-group">
                <button class="btn btn-primary" id="play-btn" disabled>‚ñ∂ Ïû¨ÏÉù</button>
                <button class="btn btn-danger" id="stop-btn" disabled>‚èπ Ï†ïÏßÄ</button>
            </div>

            <div class="control-group">
                <button class="btn btn-success" id="regen-btn" disabled>üîÑ Ïû¨ÏÉùÏÑ±</button>
                <button class="btn btn-success" id="save-btn" disabled>üíæ Ï†ÄÏû•</button>
                <label for="load-chart-input" class="btn btn-primary" id="load-chart-btn" disabled>üìÇ Î∂àÎü¨Ïò§Í∏∞</label>
                <input type="file" id="load-chart-input" accept=".json">
                <button class="btn btn-primary" id="toggle-onset-btn" disabled>üëÅÔ∏è Onset</button>
            </div>

            <div class="control-group">
                <button class="btn btn-danger" id="delete-note-btn" disabled>üóëÔ∏è ÎÖ∏Ìä∏ ÏÇ≠Ï†ú</button>
                <button class="btn btn-primary" id="edit-mode-btn" disabled>‚úèÔ∏è Ìé∏ÏßëÎ™®Îìú</button>
                <span id="edit-mode-status" style="font-size: 11px; color: #aaa;">ÏùºÎ∞òÎ™®Îìú</span>
            </div>
        </div>

        <div id="editor-container">
            <div id="left-sidebar">
                <div class="sidebar-section">
                    <h3>üéØ Pure Onset ÏãúÏä§ÌÖú</h3>
                    <div class="info-box">
                        <strong>ÌôïÎ•† ÏóÜÏùå! 1:1 Îß§Ìïë!</strong><br>
                        <br>
                        <strong>‚úÖ ÏõêÏÉ∑ = ÎÖ∏Ìä∏:</strong><br>
                        ‚Ä¢ Onset Í∞êÏßÄ ‚Üí Î¨¥Ï°∞Í±¥ ÎÖ∏Ìä∏<br>
                        ‚Ä¢ ÌôïÎ•†/ÎûúÎç§ ÏôÑÏ†Ñ Ï†úÍ±∞<br>
                        ‚Ä¢ BPM Í∑∏Î¶¨ÎìúÏóê Ïä§ÎÉÖ (1/16Î∞ï)<br>
                        <br>
                        <strong>üéß ÏïÖÍ∏∞Î≥Ñ ÏûêÎèô Îß§Ìïë:</strong><br>
                        ‚Ä¢ Kick ‚Üí ÏôºÏÜê (D‚ÜîF)<br>
                        ‚Ä¢ Snare ‚Üí Ïò§Î•∏ÏÜê (J‚ÜîK)<br>
                        ‚Ä¢ Hi-hat ‚Üí Ïò§Î•∏ÏÜê (J‚ÜîK)<br>
                        <br>
                        <strong>ÎÇúÏù¥ÎèÑ = Threshold:</strong><br>
                        Easy: Í∞ïÌïú ÎπÑÌä∏Îßå<br>
                        Hard: Ï§ëÍ∞Ñ ÎπÑÌä∏ÍπåÏßÄ<br>
                        Expert: ÏïΩÌïú ÎπÑÌä∏ÍπåÏßÄ
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>üëÅÔ∏è Onset ÏãúÍ∞ÅÌôî</h3>
                    <div class="info-box">
                        <strong>üîç Onset Î≤ÑÌäº:</strong><br>
                        Í∞êÏßÄÎêú ÎπÑÌä∏Î•º ÏãúÍ∞ÅÌôî!<br>
                        <br>
                        <strong>ÏÉâÏÉÅ ÏùòÎØ∏:</strong><br>
                        <span style="color: #00FFFF;">‚óè Ï≤≠Î°ùÏÉâ</span> - ÎÖ∏Ìä∏ ÏÉùÏÑ±Îê®<br>
                        <span style="color: #FFFF00;">‚óè ÎÖ∏ÎûÄÏÉâ</span> - Ï§ëÍ∞Ñ Í∞ïÎèÑ<br>
                        <span style="color: #FFA500;">‚óè Ï£ºÌô©ÏÉâ</span> - ÏïΩÌïú ÎπÑÌä∏<br>
                        <br>
                        <strong>ÏïÖÍ∏∞ ÌëúÏãú:</strong><br>
                        <span style="color: #FF6B6B;">K</span> = Kick (ÌÇ•ÎìúÎüº)<br>
                        <span style="color: #4ECDC4;">S</span> = Snare (Ïä§ÎÑ§Ïñ¥)<br>
                        <span style="color: #FFE66D;">H</span> = Hi-hat (ÌïòÏù¥Ìñá)<br>
                        <br>
                        Ï≤≠Î°ùÏÉâ ÏÑ†Ïù¥ ÎÖ∏Ìä∏ÏôÄ ÏùºÏπòÌïòÎäîÏßÄ<br>
                        ÌôïÏù∏Ìï¥ÏÑú ÌÉÄÏù¥Î∞ç Í≤ÄÏ¶ù!
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>‚öôÔ∏è ÏàòÎèô Ï°∞Ï†ï</h3>
                    <div class="info-box">
                        <strong>üéµ Tap BPM:</strong><br>
                        Ïû¨ÏÉùÌïòÎ©∞ 1Î∞ïÎßàÎã§ ÌÅ¥Î¶≠<br>
                        ‚Üí ÏûêÎèôÏúºÎ°ú BPM Í≥ÑÏÇ∞<br>
                        <br>
                        <strong>1Î∞ï Î≤ÑÌäº:</strong><br>
                        Ïû¨ÏÉù Ï§ë 1Î∞ïÏóêÏÑú ÌÅ¥Î¶≠<br>
                        ‚Üí Offset ÏûêÎèô ÏÑ§Ï†ï<br>
                        <br>
                        <strong>ÎØ∏ÏÑ∏Ï°∞Ï†ï:</strong><br>
                        ‚Ä¢ +/- Î≤ÑÌäºÏúºÎ°ú 0.01Ï¥àÏî©<br>
                        ‚Ä¢ ÎÖ∏Ìä∏Í∞Ä Ìù∞ ÏÑ†Ïóê ÎßûÍ≤å<br>
                        <br>
                        <strong>ÏàúÏÑú:</strong><br>
                        1. Tap BPMÏúºÎ°ú BPM Ï∏°Ï†ï<br>
                        2. "Ï†ÅÏö©" ÌÅ¥Î¶≠<br>
                        3. Ïû¨ÏÉùÌïòÎ©∞ 1Î∞ï Î≤ÑÌäº<br>
                        4. +/- Î°ú ÎØ∏ÏÑ∏Ï°∞Ï†ï
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>Î†àÏù∏ Îß§Ìïë</h3>
                    <div class="info-box">
                        <strong>üéÆ ÎîîÏ†úÏù¥Îß•Ïä§ Ìå®ÌÑ¥!</strong><br>
                        <br>
                        <strong>Kick:</strong> ÏôºÏÜê (D‚ÜîF)<br>
                        <strong>Snare:</strong> Ïò§Î•∏ÏÜê (J‚ÜîK)<br>
                        <strong>Hi-hat:</strong> Ïò§Î•∏ÏÜê (J‚ÜîK)<br>
                        <br>
                        <strong>Í∞ïÎ∞ï:</strong> ÏôºÏÜê‚ÜîÏò§Î•∏ÏÜê ÍµêÎåÄ<br>
                        <strong>ÏïΩÎ∞ï:</strong> Í∞ôÏùÄ ÏÜê Ïó∞ÌÉÄ<br>
                        <strong>Space:</strong> Í±∞Ïùò Ïïà ÏîÄ<br>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>ÎÇúÏù¥ÎèÑÎ≥Ñ ÌäπÏÑ±</h3>
                    <div class="info-box">
                        <strong>Easy:</strong> 1/2Î∞ïÏûê (downbeat)<br>
                        <strong>Normal:</strong> 1/4Î∞ïÏûê<br>
                        <strong>Hard:</strong> 1/4 + 1/8Î∞ïÏûê<br>
                        <strong>Expert:</strong> 1/4+1/8+1/16Î∞ïÏûê<br>
                        <br>
                        <strong>Î∞ÄÎèÑ Ï°∞Ï†à:</strong><br>
                        Chorus 130%, Verse 100%<br>
                        Break 60%, Intro 40%
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>ÏàòÎèô Ï°∞Ï†ï</h3>
                    <div class="info-box">
                        Ïû¨ÏÉùÌïòÎ©∞ ÎÖ∏Ìä∏ Ï∂îÍ∞Ä:<br>
                        D, F, Space, J, K<br>
                        <br>
                        Delete: ÎßàÏßÄÎßâ ÏÇ≠Ï†ú<br>
                        üîÑ Ïû¨ÏÉùÏÑ±: ÏÉàÎ°ú ÏÉùÏÑ±
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>‚úèÔ∏è Ìé∏Ïßë Î™®Îìú (E)</h3>
                    <div class="info-box">
                        <strong>ÎÖ∏Ìä∏ ÏÑ†ÌÉù:</strong><br>
                        ‚Ä¢ ÎÖ∏Ìä∏ ÌÅ¥Î¶≠ÏúºÎ°ú ÏÑ†ÌÉù/Ìï¥Ï†ú<br>
                        ‚Ä¢ ESC: ÏÑ†ÌÉù Ìï¥Ï†ú<br>
                        <br>
                        <strong>ÏÑ†ÌÉùÎêú ÎÖ∏Ìä∏ Ìé∏Ïßë:</strong><br>
                        ‚Ä¢ D/F/Space/J/K: Î†àÏù∏ Ïù¥Îèô<br>
                        ‚Ä¢ ‚Üê/‚Üí: ÌÉÄÏù¥Î∞ç Ï°∞Ï†ï (¬±10ms)<br>
                        ‚Ä¢ Delete/Backspace: ÏÇ≠Ï†ú<br>
                        <br>
                        <strong>Îã®Ï∂ïÌÇ§:</strong><br>
                        ‚Ä¢ E: Ìé∏ÏßëÎ™®Îìú ÌÜ†Í∏Ä<br>
                        ‚Ä¢ Ctrl+S: Ï∞®Ìä∏ Ï†ÄÏû•
                    </div>
                </div>
            </div>

            <div id="editor-canvas"></div>

            <div id="right-sidebar">
                <h3>CHART INFO</h3>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="label">NOTES</div>
                        <div class="value" id="note-count">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">NPS</div>
                        <div class="value" id="nps-display">0.0</div>
                    </div>
                </div>

                <div style="margin-top: 15px;">
                    <div class="info-item">
                        ÏãúÍ∞Ñ: <strong id="current-time">0.00s</strong>
                    </div>
                    <div class="info-item">
                        Î∞ïÏûê: <strong id="current-beat">0</strong>
                    </div>
                    <div class="info-item">
                        ÏÉÅÌÉú: <strong id="status">ÎåÄÍ∏∞ Ï§ë</strong>
                    </div>
                    <div class="info-item">
                        BPM: <strong id="detected-bpm">-</strong>
                    </div>
                </div>

                <h3 style="margin-top: 20px;">DENSITY</h3>
                <canvas id="density-graph" class="density-graph"></canvas>

                <h3 style="margin-top: 20px;">MINIMAP</h3>
                <canvas id="minimap"></canvas>

                <div class="key-hint">
                    <strong>üéπ Îã®Ï∂ïÌÇ§</strong><br>
                    <kbd>D F Space J K</kbd> ÎÖ∏Ìä∏<br>
                    <kbd>Delete</kbd> ÏÇ≠Ï†ú<br>
                    <kbd>Space</kbd> Ïû¨ÏÉù/Ï†ïÏßÄ<br>
                    <br>
                    <strong>üí° ÏÇ¨Ïö©Î≤ï</strong><br>
                    1. ÏùåÏõêÎßå Î°úÎìúÌïòÏÑ∏Ïöî!<br>
                    2. ÏûêÎèôÏúºÎ°ú Î∂ÑÏÑùÎê©ÎãàÎã§<br>
                    3. Î∞îÎ°ú Ïû¨ÏÉù Í∞ÄÎä•!<br>
                    4. OffsetÏúºÎ°ú ÎØ∏ÏÑ∏Ï°∞Ï†ï
                </div>
            </div>
        </div>
    </div>

    <script src="https://pixijs.download/release/pixi.js"></script>
    <script>
        const LANES = [
            { key: 'KeyD', index: 0, color: 0xFF6B6B, label: 'D' },
            { key: 'KeyF', index: 1, color: 0x4ECDC4, label: 'F' },
            { key: 'Space', index: 2, color: 0xFFE66D, label: '‚ê£' },
            { key: 'KeyJ', index: 3, color: 0x95E1D3, label: 'J' },
            { key: 'KeyK', index: 4, color: 0xF38181, label: 'K' }
        ];

        const editorState = {
            notes: [],
            audioContext: null,
            audioBuffer: null,
            audioSource: null,
            startTime: 0,
            currentTime: 0,
            isPlaying: false,
            bpm: 0,
            offset: 0,
            title: '',
            difficulty: 'Hard',
            duration: 0,
            onsets: [],  // Overall onset strengths
            onsetTimes: [],
            bassOnsets: [],   // Bass line (40-100Hz) - Task #3
            kickOnsets: [],   // Kick drum (100-150Hz) - Task #3
            snareOnsets: [],  // Snare drum (mid freq)
            hihatOnsets: [],  // Hi-hat (high freq)
            melodyOnsets: [],  // Melody (200-2000Hz, spectral flux) - Task #1
            musicStructure: [], // Music structure sections (Intro/Verse/Chorus) - Task #2
            showOnsets: false,   // Toggle onset visualization
            editMode: false,     // Edit mode for note selection/editing
            selectedNotes: new Set(),  // Set of selected note indices
            audioFileName: ''    // Original audio file name
        };

        let app, gameContainer, notesContainer, gridContainer, beatGridContainer, onsetMarkersContainer;
        let GAME_WIDTH, GAME_HEIGHT, LANE_WIDTH, JUDGMENT_LINE_Y;

        function showLoading(text, detail = '') {
            document.getElementById('loading-text').textContent = text;
            document.getElementById('loading-detail').textContent = detail;
            document.getElementById('loading-overlay').classList.add('show');
        }

        function hideLoading() {
            document.getElementById('loading-overlay').classList.remove('show');
        }

        function calculateDimensions() {
            const canvas = document.getElementById('editor-canvas');
            GAME_WIDTH = canvas.clientWidth;
            GAME_HEIGHT = canvas.clientHeight;
            LANE_WIDTH = GAME_WIDTH / LANES.length;
            JUDGMENT_LINE_Y = GAME_HEIGHT - 100;
        }

        window.addEventListener('load', async () => {
            setupUI();
            await initEditor();
        });

        function setupUI() {
            document.getElementById('file-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    document.getElementById('file-name').textContent = file.name.substring(0, 20);
                    document.getElementById('title-input').value = file.name.replace(/\.[^/.]+$/, "");
                    editorState.title = file.name.replace(/\.[^/.]+$/, "");
                    editorState.audioFileName = file.name;  // Ïò§ÎîîÏò§ ÌååÏùº Ïù¥Î¶Ñ Ï†ÄÏû•
                    await loadAndAnalyzeAudio(file);
                }
            });

            document.getElementById('play-btn').addEventListener('click', togglePlayback);
            document.getElementById('stop-btn').addEventListener('click', stopPlayback);
            document.getElementById('save-btn').addEventListener('click', saveChart);
            document.getElementById('load-chart-input').addEventListener('change', loadChart);
            document.getElementById('regen-btn').addEventListener('click', regenerateNotes);

            document.getElementById('override-bpm-btn').addEventListener('click', () => {
                const newBPM = parseFloat(document.getElementById('bpm-input').value);
                if (newBPM >= 60 && newBPM <= 240) {
                    editorState.bpm = newBPM;
                    regenerateNotes();
                    console.log(`‚úèÔ∏è BPM manually adjusted to ${newBPM}`);
                } else {
                    alert('BPMÏùÄ 60-240 ÏÇ¨Ïù¥Ïó¨Ïïº Ìï©ÎãàÎã§.');
                }
            });

            document.getElementById('offset-input').addEventListener('change', (e) => {
                editorState.offset = parseFloat(e.target.value);
                regenerateNotes();
                console.log(`‚úèÔ∏è Offset manually adjusted to ${editorState.offset.toFixed(3)}s`);
            });

            document.getElementById('offset-minus-btn').addEventListener('click', () => {
                editorState.offset -= 0.01;
                document.getElementById('offset-input').value = editorState.offset.toFixed(3);
                regenerateNotes();
                console.log(`‚úèÔ∏è Offset: ${editorState.offset.toFixed(3)}s`);
            });

            document.getElementById('offset-plus-btn').addEventListener('click', () => {
                editorState.offset += 0.01;
                document.getElementById('offset-input').value = editorState.offset.toFixed(3);
                regenerateNotes();
                console.log(`‚úèÔ∏è Offset: ${editorState.offset.toFixed(3)}s`);
            });

            // Tap BPM Í∏∞Îä•
            let tapTimes = [];
            document.getElementById('tap-bpm-btn').addEventListener('click', () => {
                const now = Date.now();
                tapTimes.push(now);

                // ÏµúÍ∑º 8Î≤àÏùò ÌÉ≠Îßå Ïú†ÏßÄ
                if (tapTimes.length > 8) {
                    tapTimes.shift();
                }

                if (tapTimes.length >= 2) {
                    // ÌÉ≠ Í∞ÑÍ≤©Ïùò ÌèâÍ∑† Í≥ÑÏÇ∞
                    const intervals = [];
                    for (let i = 1; i < tapTimes.length; i++) {
                        intervals.push(tapTimes[i] - tapTimes[i - 1]);
                    }
                    const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                    const bpm = 60000 / avgInterval;  // ms to BPM

                    document.getElementById('bpm-input').value = bpm.toFixed(1);
                    console.log(`üéµ Tap BPM: ${bpm.toFixed(1)} (${tapTimes.length} taps)`);
                }

                // 5Ï¥à Ïù¥ÏÉÅ ÌÉ≠ Ïïà ÌïòÎ©¥ Î¶¨ÏÖã
                setTimeout(() => {
                    const lastTap = tapTimes[tapTimes.length - 1];
                    if (Date.now() - lastTap > 5000) {
                        tapTimes = [];
                        console.log('Tap BPM reset');
                    }
                }, 5000);
            });

            // Mark Beat Í∏∞Îä• (1Î∞ï ÏúÑÏπò ÌëúÏãú)
            document.getElementById('mark-beat-btn').addEventListener('click', () => {
                if (editorState.isPlaying) {
                    const currentTime = editorState.currentTime;
                    document.getElementById('offset-input').value = currentTime.toFixed(3);
                    editorState.offset = currentTime;
                    regenerateNotes();
                    console.log(`‚úèÔ∏è Marked beat at ${currentTime.toFixed(3)}s as offset`);
                } else {
                    alert('Ïû¨ÏÉù Ï§ëÏóê 1Î∞ïÏóêÏÑú Î≤ÑÌäºÏùÑ ÎàÑÎ•¥ÏÑ∏Ïöî!');
                }
            });

            document.getElementById('difficulty-select').addEventListener('change', (e) => {
                editorState.difficulty = e.target.value;
                if (editorState.audioBuffer) {
                    regenerateNotes();
                }
            });

            // Toggle Onset Visualization
            document.getElementById('toggle-onset-btn').addEventListener('click', () => {
                editorState.showOnsets = !editorState.showOnsets;
                const btn = document.getElementById('toggle-onset-btn');
                if (editorState.showOnsets) {
                    btn.textContent = 'üëÅÔ∏è Onset ON';
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-success');
                    console.log('üîç Onset visualization enabled');
                } else {
                    btn.textContent = 'üëÅÔ∏è Onset';
                    btn.classList.remove('btn-success');
                    btn.classList.add('btn-primary');
                    console.log('üîç Onset visualization disabled');
                }
            });

            // Toggle Edit Mode
            document.getElementById('edit-mode-btn').addEventListener('click', toggleEditMode);

            // Delete Selected Notes
            document.getElementById('delete-note-btn').addEventListener('click', deleteSelectedNotes);

            window.addEventListener('keydown', handleKeyDown);
        }

        function handleKeyDown(e) {
            const activeElement = document.activeElement;
            const isTyping = activeElement.tagName === 'INPUT';

            if (!isTyping) {
                // Ìé∏Ïßë Î™®ÎìúÏóêÏÑú ÏÑ†ÌÉùÎêú ÎÖ∏Ìä∏ Ìé∏Ïßë
                if (editorState.editMode && editorState.selectedNotes.size > 0) {
                    // Delete/Backspace: ÏÑ†ÌÉùÎêú ÎÖ∏Ìä∏ ÏÇ≠Ï†ú
                    if (e.code === 'Delete' || e.code === 'Backspace') {
                        e.preventDefault();
                        deleteSelectedNotes();
                        return;
                    }

                    // Î†àÏù∏ Î≥ÄÍ≤Ω: D(0), F(1), Space(2), J(3), K(4)
                    const laneMap = { 'KeyD': 0, 'KeyF': 1, 'Space': 2, 'KeyJ': 3, 'KeyK': 4 };
                    if (laneMap.hasOwnProperty(e.code)) {
                        e.preventDefault();
                        moveSelectedNotesToLane(laneMap[e.code]);
                        return;
                    }

                    // ÌÉÄÏù¥Î∞ç ÎØ∏ÏÑ∏ Ï°∞Ï†ï: ArrowLeft (ÏïûÏúºÎ°ú), ArrowRight (Îí§Î°ú)
                    if (e.code === 'ArrowLeft') {
                        e.preventDefault();
                        adjustSelectedNotesTiming(-0.01);  // 10ms ÏïûÏúºÎ°ú
                        return;
                    }
                    if (e.code === 'ArrowRight') {
                        e.preventDefault();
                        adjustSelectedNotesTiming(0.01);  // 10ms Îí§Î°ú
                        return;
                    }

                    // Escape: ÏÑ†ÌÉù Ìï¥Ï†ú
                    if (e.code === 'Escape') {
                        e.preventDefault();
                        editorState.selectedNotes.clear();
                        console.log('‚úÖ Î™®Îì† ÎÖ∏Ìä∏ ÏÑ†ÌÉù Ìï¥Ï†ú');
                        return;
                    }
                }

                // ÏùºÎ∞ò Î™®Îìú Îã®Ï∂ïÌÇ§
                if (e.code === 'Space') {
                    e.preventDefault();
                    togglePlayback();
                    return;
                }

                if (e.code === 'Delete' || e.code === 'Backspace') {
                    e.preventDefault();
                    deleteLastNote();
                    return;
                }

                const lane = LANES.find(l => l.key === e.code);
                if (lane && editorState.isPlaying) {
                    e.preventDefault();
                    const time = editorState.currentTime;
                    addNote(lane.index, time);
                    showKeyFlash(lane.index);
                }

                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    saveChart();
                }

                // E: Ìé∏Ïßë Î™®Îìú ÌÜ†Í∏Ä
                if (e.code === 'KeyE') {
                    e.preventDefault();
                    toggleEditMode();
                }
            }
        }

        async function loadAndAnalyzeAudio(file) {
            try {
                showLoading('ÏùåÏõê Î°úÎî© Ï§ë...', 'Ïò§ÎîîÏò§ ÎîîÏΩîÎî©');

                if (!editorState.audioContext) {
                    editorState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                const arrayBuffer = await file.arrayBuffer();
                editorState.audioBuffer = await editorState.audioContext.decodeAudioData(arrayBuffer);
                editorState.duration = editorState.audioBuffer.duration;

                showLoading('BPM Î∂ÑÏÑù Ï§ë...', 'ÌÖúÌè¨ Î∞è ÎπÑÌä∏ Í∞êÏßÄ');

                // BPM Î∞è Ï≤´ ÎπÑÌä∏ Ïò§ÌîÑÏÖã ÏûêÎèô Í∞êÏßÄ
                const { bpm: detectedBPM, offset: detectedOffset, onsets, onsetTimes, bassOnsets, kickOnsets, snareOnsets, hihatOnsets, melodyOnsets, musicStructure } = await detectBPMAndOffset(editorState.audioBuffer);
                editorState.bpm = detectedBPM;
                editorState.offset = detectedOffset;
                editorState.onsets = onsets;
                editorState.onsetTimes = onsetTimes;
                editorState.bassOnsets = bassOnsets;   // Task #3
                editorState.kickOnsets = kickOnsets;
                editorState.snareOnsets = snareOnsets;
                editorState.hihatOnsets = hihatOnsets;
                editorState.melodyOnsets = melodyOnsets; // Task #1
                editorState.musicStructure = musicStructure; // Task #2

                document.getElementById('bpm-input').value = detectedBPM.toFixed(1);
                document.getElementById('offset-input').value = detectedOffset.toFixed(3);
                document.getElementById('detected-bpm').textContent = detectedBPM.toFixed(1);

                showLoading('ÎÖ∏Ìä∏ ÏÉùÏÑ± Ï§ë...', 'ÎÇúÏù¥ÎèÑ: ' + editorState.difficulty);

                // ÏûêÎèô ÎÖ∏Ìä∏ ÏÉùÏÑ±
                generateNotes();

                hideLoading();

                document.getElementById('status').textContent = 'Ï§ÄÎπÑ ÏôÑÎ£å!';
                document.getElementById('play-btn').disabled = false;
                document.getElementById('stop-btn').disabled = false;
                document.getElementById('regen-btn').disabled = false;
                document.getElementById('save-btn').disabled = false;
                document.getElementById('load-chart-btn').disabled = false;
                document.getElementById('edit-mode-btn').disabled = false;
                document.getElementById('override-bpm-btn').disabled = false;
                document.getElementById('offset-minus-btn').disabled = false;
                document.getElementById('offset-plus-btn').disabled = false;
                document.getElementById('tap-bpm-btn').disabled = false;
                document.getElementById('mark-beat-btn').disabled = false;
                document.getElementById('toggle-onset-btn').disabled = false;

                alert(`‚ú® Î∂ÑÏÑù ÏôÑÎ£å!\n\nBPM: ${detectedBPM.toFixed(1)}\nOffset: ${detectedOffset.toFixed(3)}s\nÎÖ∏Ìä∏: ${editorState.notes.length}Í∞ú\nÎÇúÏù¥ÎèÑ: ${editorState.difficulty}\n\nÏû¨ÏÉù Î≤ÑÌäºÏùÑ ÎàåÎü¨ ÌôïÏù∏ÌïòÏÑ∏Ïöî!\n‚Äª Î∞ïÏûêÍ∞Ä ÏïàÎßûÏúºÎ©¥ BPMÏù¥ÎÇò OffsetÏùÑ ÏàòÎèô Ï°∞Ï†ïÌïòÏÑ∏Ïöî.`);

            } catch (error) {
                hideLoading();
                console.error('Error:', error);
                alert('Ïò§ÎîîÏò§ Î°úÎìú Ïã§Ìå®: ' + error.message);
            }
        }

        // BPM Î∞è Ï≤´ ÎπÑÌä∏ Ïò§ÌîÑÏÖã ÏûêÎèô Í∞êÏßÄ + FFT Í∏∞Î∞ò Ï£ºÌååÏàò Î∂ÑÏÑù
        async function detectBPMAndOffset(audioBuffer) {
            const sampleRate = audioBuffer.sampleRate;
            const channelData = audioBuffer.getChannelData(0);

            console.log('Starting advanced BPM detection with FFT analysis...');

            // 1. FFT Í∏∞Î∞ò Onset Strength Envelope Í≥ÑÏÇ∞
            const fftSize = 2048;  // FFT window size (power of 2)
            const hopSize = Math.floor(fftSize / 2); // 50% overlap

            // Ï†ÑÏ≤¥ onset + Ï£ºÌååÏàò ÎåÄÏó≠Î≥Ñ onset + Î©úÎ°úÎîî Ï†ïÎ≥¥
            const onsetStrengths = [];
            const onsetTimes = [];
            const bassOnsets = [];      // Î≤†Ïù¥Ïä§ ÎùºÏù∏ (40-100Hz) - Task #3
            const kickOnsets = [];      // ÌÇ•ÎìúÎüº (100-150Hz) - Task #3
            const snareOnsets = [];     // Ïä§ÎÑ§Ïñ¥ (150-4000Hz)
            const hihatOnsets = [];     // ÌïòÏù¥Ìñá (4000-12000Hz)
            const melodyStrengths = []; // Î©úÎ°úÎîî (200-2000Hz, spectral flux) - Task #1

            console.log(`Using simplified frequency band analysis with bass separation (Task #3)`);

            // Ïù¥Ï†Ñ Ïä§ÌéôÌä∏Îüº Ï†ÄÏû• (Spectral Flux Í≥ÑÏÇ∞Ïö©)
            let prevSpectrum = null;

            // Í∞Å windowÎßàÎã§ Í∞ÑÏÜåÌôîÎêú Ï£ºÌååÏàò ÎåÄÏó≠ Î∂ÑÏÑù ÏàòÌñâ
            // (Ï†ÑÏ≤¥ DFT ÎåÄÏã† ÌïÑÏöîÌïú Ï£ºÌååÏàò ÎåÄÏó≠Îßå Í≥ÑÏÇ∞ - Ìõ®Ïî¨ Îπ†Î¶Ñ)
            for (let i = 0; i < channelData.length - fftSize; i += hopSize) {
                const time = i / sampleRate;

                // ÌòÑÏû¨ window Ï∂îÏ∂ú Î∞è RMS Í∏∞Î∞ò ÎåÄÏó≠Î≥Ñ ÏóêÎÑàÏßÄ Í≥ÑÏÇ∞
                let bassEnergy = 0;   // Task #3: Bass line (very low freq)
                let kickEnergy = 0;   // Task #3: Kick drum (low freq)
                let snareEnergy = 0;
                let hihatEnergy = 0;
                let melodyEnergy = 0;
                let zeroCrossings = 0; // Zero-crossing rate for melody pitch detection
                let prevSample = 0;

                // Task #3: Í∞ÑÏÜåÌôîÎêú ÌïÑÌÑ∞Î±ÖÌÅ¨ Î∞©Ïãù - BassÏôÄ Kick Î∂ÑÎ¶¨ + Zero-Crossing for melody
                for (let j = 0; j < fftSize; j++) {
                    const sample = channelData[i + j];
                    const sampleSq = sample * sample;

                    // Zero-crossing detection (Î©úÎ°úÎîî pitch Î≥ÄÌôî Í∞êÏßÄ)
                    if (j > 0 && prevSample * sample < 0) {
                        zeroCrossings++;
                    }
                    prevSample = sample;

                    // Task #3: Ï¥àÏ†ÄÏ£ºÌåå ÏóêÎÑàÏßÄ (Bass line: ÏïûÏ™Ω 1/16)
                    if (j < fftSize / 16) {
                        bassEnergy += sampleSq;
                    }
                    // Task #3: Ï†ÄÏ£ºÌåå ÏóêÎÑàÏßÄ (Kick: 1/16 ~ 1/8)
                    else if (j < fftSize / 8) {
                        kickEnergy += sampleSq;
                    }
                    // Ï§ëÏ£ºÌåå ÏóêÎÑàÏßÄ (Snare/Melody: 1/8 ~ 1/2)
                    else if (j < fftSize / 2) {
                        snareEnergy += sampleSq;
                        melodyEnergy += sampleSq * 2.0; // Î©úÎ°úÎîî ÎåÄÏó≠
                    }
                    // Í≥†Ï£ºÌåå ÏóêÎÑàÏßÄ (Hihat: ÎÇòÎ®∏ÏßÄ)
                    else {
                        hihatEnergy += sampleSq;
                    }
                }

                // Zero-crossing rateÎ•º Î©úÎ°úÎîî ÏóêÎÑàÏßÄÏóê Î∞òÏòÅ
                // ÎÜíÏùÄ ZCR = ÎÜíÏùÄ Ï£ºÌååÏàò = Î©úÎ°úÎîî/Î≥¥Ïª¨ Í∞ÄÎä•ÏÑ± ÎÜíÏùå
                const zcr = zeroCrossings / fftSize;
                if (zcr > 0.1 && zcr < 0.4) {  // Î©úÎ°úÎîî Î≤îÏúÑÏùò ZCR (ÎÑàÎ¨¥ ÎÇÆÏúºÎ©¥ Bass, ÎÑàÎ¨¥ ÎÜíÏúºÎ©¥ ÎÖ∏Ïù¥Ï¶à)
                    melodyEnergy *= (1 + zcr * 5); // ZCRÏóê ÎπÑÎ°ÄÌï¥ÏÑú Î©úÎ°úÎîî ÏóêÎÑàÏßÄ Ï¶ùÌè≠
                }

                // Normalize by window size
                bassEnergy = Math.sqrt(bassEnergy / fftSize);   // Task #3
                kickEnergy = Math.sqrt(kickEnergy / fftSize);   // Task #3
                snareEnergy = Math.sqrt(snareEnergy / fftSize);
                hihatEnergy = Math.sqrt(hihatEnergy / fftSize);
                melodyEnergy = Math.sqrt(melodyEnergy / fftSize);

                // Onset detection: Ïù¥Ï†Ñ ÌîÑÎ†àÏûÑÍ≥ºÏùò Ï∞®Ïù¥ Í≥ÑÏÇ∞
                let onset = 0;
                let bassOnset = 0;   // Task #3
                let kickOnset = 0;
                let snareOnset = 0;
                let hihatOnset = 0;
                let melodyOnset = 0;

                if (prevSpectrum !== null) {
                    // Energy difference (positive only)
                    const totalEnergy = bassEnergy + kickEnergy + snareEnergy + hihatEnergy + melodyEnergy;
                    const prevTotalEnergy = prevSpectrum[0] + prevSpectrum[1] + prevSpectrum[2] + prevSpectrum[3] + prevSpectrum[4];

                    onset = Math.max(0, totalEnergy - prevTotalEnergy);
                    bassOnset = Math.max(0, bassEnergy - prevSpectrum[0]); // Task #3
                    kickOnset = Math.max(0, kickEnergy - prevSpectrum[1]); // Task #3
                    snareOnset = Math.max(0, snareEnergy - prevSpectrum[2]);
                    hihatOnset = Math.max(0, hihatEnergy - prevSpectrum[3]);

                    // Task #1: Î©úÎ°úÎîî onset - ÏóêÎÑàÏßÄ Î≥ÄÌôîÍ∞Ä Ï∂©Î∂ÑÌûà ÌÅ¥ ÎïåÎßå
                    const melodyDiff = melodyEnergy - prevSpectrum[4];
                    if (melodyDiff > prevSpectrum[4] * 0.2) {  // Ïù¥Ï†Ñ ÎåÄÎπÑ 20% Ïù¥ÏÉÅ Ï¶ùÍ∞Ä
                        melodyOnset = melodyDiff;
                    } else {
                        melodyOnset = 0;  // ÏûëÏùÄ Î≥ÄÌôîÎäî Î¨¥Ïãú
                    }
                }

                onsetStrengths.push(onset);
                bassOnsets.push(bassOnset);   // Task #3
                kickOnsets.push(kickOnset);
                snareOnsets.push(snareOnset);
                hihatOnsets.push(hihatOnset);
                melodyStrengths.push(melodyOnset); // Task #1
                onsetTimes.push(time);

                // Store current energies for next iteration (Task #3: 5 bands now)
                prevSpectrum = [bassEnergy, kickEnergy, snareEnergy, hihatEnergy, melodyEnergy];
            }

            // 2. Normalize onset strengths
            const maxOnset = Math.max(...onsetStrengths);
            const maxBass = Math.max(...bassOnsets);   // Task #3
            const maxKick = Math.max(...kickOnsets);
            const maxSnare = Math.max(...snareOnsets);
            const maxHihat = Math.max(...hihatOnsets);
            const maxMelody = Math.max(...melodyStrengths);

            const normalizedOnsets = onsetStrengths.map(o => o / maxOnset);
            const normalizedBass = bassOnsets.map(o => o / maxBass);   // Task #3
            const normalizedKick = kickOnsets.map(o => o / maxKick);
            const normalizedSnare = snareOnsets.map(o => o / maxSnare);
            const normalizedHihat = hihatOnsets.map(o => o / maxHihat);
            const normalizedMelody = melodyStrengths.map(o => o / maxMelody); // Task #1

            // Calculate onset statistics
            const strongOnsets = normalizedOnsets.filter(o => o > 0.3).length;
            const bassCount = normalizedBass.filter(o => o > 0.3).length;   // Task #3
            const kickCount = normalizedKick.filter(o => o > 0.3).length;
            const snareCount = normalizedSnare.filter(o => o > 0.3).length;
            const hihatCount = normalizedHihat.filter(o => o > 0.3).length;
            const melodyCount = normalizedMelody.filter(o => o > 0.3).length; // Task #1

            console.log(`Calculated ${normalizedOnsets.length} onset frames`);
            console.log(`Strong onsets (>0.3): ${strongOnsets}`);
            console.log(`Frequency bands - Bass: ${bassCount}, Kick: ${kickCount}, Snare: ${snareCount}, Hihat: ${hihatCount}, Melody: ${melodyCount}`);

            // 3. Autocorrelation for tempo detection
            const minBPM = 60;
            const maxBPM = 200;
            const minInterval = Math.floor((60 / maxBPM) / (hopSize / sampleRate));
            const maxInterval = Math.floor((60 / minBPM) / (hopSize / sampleRate));

            let bestCorr = 0;
            let bestLag = 0;

            // Calculate autocorrelation with normalization
            for (let lag = minInterval; lag <= maxInterval; lag++) {
                let corr = 0;
                let norm = 0;

                for (let i = 0; i < normalizedOnsets.length - lag; i++) {
                    corr += normalizedOnsets[i] * normalizedOnsets[i + lag];
                    norm += normalizedOnsets[i] * normalizedOnsets[i];
                }

                // Normalize correlation
                if (norm > 0) {
                    corr = corr / Math.sqrt(norm);
                }

                if (corr > bestCorr) {
                    bestCorr = corr;
                    bestLag = lag;
                }
            }

            // 4. Calculate BPM from best lag
            const beatInterval = bestLag * (hopSize / sampleRate);
            let detectedBPM = 60 / beatInterval;

            console.log(`Raw BPM: ${detectedBPM.toFixed(1)}, Correlation: ${bestCorr.toFixed(3)}`);

            // 5. BPM adjustment (handle octave errors)
            // Try multiples and divisions to find the most musical tempo
            const candidates = [detectedBPM, detectedBPM * 2, detectedBPM / 2, detectedBPM * 3, detectedBPM / 3];
            let finalBPM = detectedBPM;

            for (const candidate of candidates) {
                if (candidate >= 80 && candidate <= 180) {
                    finalBPM = candidate;
                    break;
                }
            }

            // Round to nearest 0.5
            finalBPM = Math.round(finalBPM * 2) / 2;

            console.log(`Final BPM: ${finalBPM}`);

            // 6. First beat offset detection (improved)
            // Find the first ANY onset (ÏùåÏïÖÏùò Ïã§Ï†ú ÏãúÏûëÏ†ê) - not just strong ones!
            const threshold = 0.1; // 10% of max (ÏïΩÌïú ÎπÑÌä∏ÎèÑ Í∞êÏßÄ)
            let firstBeatIndex = -1;

            for (let i = 0; i < normalizedOnsets.length; i++) {
                if (normalizedOnsets[i] > threshold) {
                    firstBeatIndex = i;
                    break;
                }
            }

            const firstBeatTime = firstBeatIndex !== -1 ? onsetTimes[firstBeatIndex] : 0;

            // Align to beat grid
            const beatDuration = 60 / finalBPM;

            // IMPORTANT: BPM Í∑∏Î¶¨ÎìúÏóê ÎßûÏ∂∞ÏÑú offset Í≥ÑÏÇ∞
            // firstBeatTimeÏùÑ Í∞ÄÏû• Í∞ÄÍπåÏö¥ Î∞ïÏûêÏóê Ï†ïÎ†¨
            const beatPosition = Math.round(firstBeatTime / beatDuration);
            let offset = beatPosition * beatDuration;

            // ÌïòÏßÄÎßå ÏùåÏïÖÏù¥ ÏïÑÏòà Ï≤òÏùåÎ∂ÄÌÑ∞ ÏãúÏûëÌïúÎã§Î©¥ offset = 0
            if (firstBeatTime < beatDuration * 2) {
                offset = 0;
                console.log(`First beat at ${firstBeatTime.toFixed(3)}s (very early), setting offset to 0`);
            } else {
                console.log(`First beat at ${firstBeatTime.toFixed(3)}s, aligned offset: ${offset.toFixed(3)}s`);
            }

            // Ï≤´ 4ÎßàÎîîÏùò Í∞ïÌïú ÎπÑÌä∏Îì§ÏùÑ Ï∂úÎ†•Ìï¥ÏÑú ÌôïÏù∏
            console.log('First 4 measures strong beats:');
            for (let i = 0; i < Math.min(16, normalizedOnsets.length); i++) {
                if (normalizedOnsets[i] > 0.4) {
                    const beatPos = (onsetTimes[i] - offset) / beatDuration;
                    console.log(`  ${onsetTimes[i].toFixed(2)}s (beat ${beatPos.toFixed(2)}) - strength ${normalizedOnsets[i].toFixed(2)}`);
                }
            }

            // 7. Music Structure Recognition (Task #2)
            // ÏóêÎÑàÏßÄ Î≥ÄÌôîÎ•º Î∂ÑÏÑùÌï¥ÏÑú Í≥°Ïùò Íµ¨Ï°∞(Intro/Verse/Chorus)Î•º Í∞êÏßÄ
            const musicStructure = detectMusicStructure(normalizedOnsets, onsetTimes, audioBuffer.duration, finalBPM);
            console.log(`Detected ${musicStructure.length} music sections`);

            return {
                bpm: finalBPM,
                offset: offset,
                confidence: bestCorr,
                onsets: normalizedOnsets,      // Overall onset strengths
                onsetTimes: onsetTimes,
                bassOnsets: normalizedBass,    // Bass line onsets (40-100Hz) - Task #3
                kickOnsets: normalizedKick,    // Kick drum onsets (100-150Hz) - Task #3
                snareOnsets: normalizedSnare,  // Snare drum onsets (150-4000Hz)
                hihatOnsets: normalizedHihat,  // Hi-hat onsets (4000-12000Hz)
                melodyOnsets: normalizedMelody, // Melody onsets (200-2000Hz) - Task #1
                musicStructure: musicStructure  // Music structure sections - Task #2
            };
        }

        // Task #2: Music Structure Detection
        // ÏóêÎÑàÏßÄ Î†àÎ≤® Î≥ÄÌôîÎ•º Î∂ÑÏÑùÌïòÏó¨ Í≥°Ïùò Íµ¨Ï°∞(Intro/Verse/Chorus/Bridge/Outro)Î•º Í∞êÏßÄ
        function detectMusicStructure(onsets, onsetTimes, duration, bpm) {
            const sections = [];

            // ÏóêÎÑàÏßÄÎ•º ÏùºÏ†ï ÏãúÍ∞Ñ Îã®ÏúÑÎ°ú ÌèâÍ∑†ÎÇ¥ÏÑú Î∂ÑÏÑù (4ÎßàÎîî = 16Î∞ïÏûê Îã®ÏúÑ)
            const beatDuration = 60 / bpm;
            const sectionDuration = beatDuration * 16; // 4ÎßàÎîî
            const numSections = Math.ceil(duration / sectionDuration);

            console.log(`Analyzing music structure: ${numSections} sections (${sectionDuration.toFixed(1)}s each)`);

            // Í∞Å ÏÑπÏÖòÏùò ÌèâÍ∑† ÏóêÎÑàÏßÄ Í≥ÑÏÇ∞
            const sectionEnergies = [];
            for (let i = 0; i < numSections; i++) {
                const startTime = i * sectionDuration;
                const endTime = Math.min((i + 1) * sectionDuration, duration);

                // Ïù¥ ÏãúÍ∞Ñ Î≤îÏúÑÏùò onsetÎì§Ïùò ÌèâÍ∑† ÏóêÎÑàÏßÄ
                const sectionOnsets = onsets.filter((_, idx) => {
                    const t = onsetTimes[idx];
                    return t >= startTime && t < endTime;
                });

                const avgEnergy = sectionOnsets.length > 0
                    ? sectionOnsets.reduce((sum, o) => sum + o, 0) / sectionOnsets.length
                    : 0;

                sectionEnergies.push(avgEnergy);
            }

            // Ï†ÑÏ≤¥ Í≥°Ïùò ÌèâÍ∑†/ÏµúÎåÄ ÏóêÎÑàÏßÄ
            const avgEnergy = sectionEnergies.reduce((sum, e) => sum + e, 0) / sectionEnergies.length;
            const maxEnergy = Math.max(...sectionEnergies);

            console.log(`Energy stats - Avg: ${avgEnergy.toFixed(3)}, Max: ${maxEnergy.toFixed(3)}`);

            // Í∞Å ÏÑπÏÖòÏùÑ Î∂ÑÎ•ò
            for (let i = 0; i < numSections; i++) {
                const startTime = i * sectionDuration;
                const endTime = Math.min((i + 1) * sectionDuration, duration);
                const energy = sectionEnergies[i];
                const energyRatio = energy / avgEnergy;

                let sectionType = 'Verse';
                let densityMultiplier = 1.0;

                // ÏóêÎÑàÏßÄ Î†àÎ≤®Î°ú ÏÑπÏÖò ÌÉÄÏûÖ ÌåêÎã® (ÎîîÏ†úÏù¥Îß•Ïä§ Ïä§ÌÉÄÏùº Î∞ÄÎèÑ)
                if (i === 0 && energyRatio < 0.7) {
                    // Ï≤´ ÏÑπÏÖòÏù¥ ÎÇÆÏùÄ ÏóêÎÑàÏßÄ ‚Üí Intro
                    sectionType = 'Intro';
                    densityMultiplier = 0.4; // ÎÖ∏Ìä∏ Î∞ÄÎèÑ 40% (Îçî ÎÇÆÏ∂§)
                } else if (i === numSections - 1 && energyRatio < 0.7) {
                    // ÎßàÏßÄÎßâ ÏÑπÏÖòÏù¥ ÎÇÆÏùÄ ÏóêÎÑàÏßÄ ‚Üí Outro
                    sectionType = 'Outro';
                    densityMultiplier = 0.5; // ÎÖ∏Ìä∏ Î∞ÄÎèÑ 50% (Îçî ÎÇÆÏ∂§)
                } else if (energyRatio > 1.3) {
                    // ÌèâÍ∑†Î≥¥Îã§ 30% ÎÜíÏùÄ ÏóêÎÑàÏßÄ ‚Üí Chorus (Ï†àÏ†ï)
                    sectionType = 'Chorus';
                    densityMultiplier = 1.3; // ÎÖ∏Ìä∏ Î∞ÄÎèÑ 130% (Ï§ÑÏûÑ)
                } else if (energyRatio > 1.1) {
                    // ÌèâÍ∑†Î≥¥Îã§ 10% ÎÜíÏùÄ ÏóêÎÑàÏßÄ ‚Üí Pre-Chorus
                    sectionType = 'Pre-Chorus';
                    densityMultiplier = 1.1; // ÎÖ∏Ìä∏ Î∞ÄÎèÑ 110% (Ï§ÑÏûÑ)
                } else if (energyRatio < 0.8) {
                    // ÌèâÍ∑†Î≥¥Îã§ ÎÇÆÏùÄ ÏóêÎÑàÏßÄ ‚Üí Break/Bridge
                    sectionType = 'Break';
                    densityMultiplier = 0.6; // ÎÖ∏Ìä∏ Î∞ÄÎèÑ 60% (Îçî ÎÇÆÏ∂§)
                } else {
                    // ÌèâÍ∑† ÏóêÎÑàÏßÄ ‚Üí Verse
                    sectionType = 'Verse';
                    densityMultiplier = 1.0; // ÎÖ∏Ìä∏ Î∞ÄÎèÑ 100%
                }

                sections.push({
                    startTime: startTime,
                    endTime: endTime,
                    type: sectionType,
                    energy: energy,
                    densityMultiplier: densityMultiplier
                });

                console.log(`Section ${i}: ${startTime.toFixed(1)}-${endTime.toFixed(1)}s | ${sectionType} | Energy: ${energy.toFixed(3)} (${(energyRatio * 100).toFixed(0)}%) | Density: ${(densityMultiplier * 100).toFixed(0)}%`);
            }

            return sections;
        }

        function generateNotes() {
            editorState.notes = [];

            const beatDuration = 60 / editorState.bpm;

            console.log(`üéØ Pure Onset-Based Generation: BPM ${editorState.bpm}`);
            console.log(`‚ö†Ô∏è ÌôïÎ•† ÏóÜÏùå! OnsetÎßå Î≥¥Í≥† 1:1 ÎÖ∏Ìä∏ ÏÉùÏÑ±`);

            // ÎÇúÏù¥ÎèÑÎ≥Ñ Onset thresholdÎßå ÏÑ§Ï†ï (ÌôïÎ•† Ï†úÍ±∞!)
            const difficultySettings = {
                'Easy': {
                    threshold: 0.30,  // Í∞ïÌïú ÎπÑÌä∏Îßå
                    description: 'Í∞ïÌïú ÎπÑÌä∏Îßå'
                },
                'Normal': {
                    threshold: 0.20,  // Ï§ëÍ∞Ñ ÎπÑÌä∏
                    description: 'Ï§ëÍ∞Ñ ÎπÑÌä∏'
                },
                'Hard': {
                    threshold: 0.15,  // ÏïΩÌïú ÎπÑÌä∏ÍπåÏßÄ (Îçî ÎÇÆÏ∂§!)
                    description: 'ÏïΩÌïú ÎπÑÌä∏ÍπåÏßÄ'
                },
                'Expert': {
                    threshold: 0.10,  // Îß§Ïö∞ ÏïΩÌïú ÎπÑÌä∏ÍπåÏßÄ
                    description: 'Îß§Ïö∞ ÏïΩÌïú ÎπÑÌä∏ÍπåÏßÄ'
                }
            };

            const settings = difficultySettings[editorState.difficulty];
            console.log(`Difficulty: ${editorState.difficulty} - ${settings.description}, Threshold: ${settings.threshold}`);

            if (!editorState.onsets || editorState.onsets.length === 0) {
                console.error('No onset data available!');
                alert('Onset Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§. ÏùåÏõêÏùÑ Îã§Ïãú Î°úÎìúÌïòÏÑ∏Ïöî.');
                return;
            }

            let lastLane = 0;  // Î†àÏù∏ ÍµêÎåÄ Ìå®ÌÑ¥Ïö©
            let lastLeftLane = 0;  // ÏôºÏÜê ÎßàÏßÄÎßâ Î†àÏù∏ (D/F ÍµêÎåÄÏö©)
            let lastRightLane = 3;  // Ïò§Î•∏ÏÜê ÎßàÏßÄÎßâ Î†àÏù∏ (J/K ÍµêÎåÄÏö©)
            let processedOnsets = 0;
            let skippedWeak = 0;
            let skippedDuplicate = 0;

            console.log(`Processing ${editorState.onsets.length} onsets...`);

            // Onset ÏßÅÏ†ë ÏàúÌöå (BPM Í∑∏Î¶¨Îìú Î¨¥Ïãú!)
            for (let i = 0; i < editorState.onsets.length; i++) {
                const onsetStrength = editorState.onsets[i];
                const onsetTime = editorState.onsetTimes[i];

                processedOnsets++;

                // 1. Threshold Ï≤¥ÌÅ¨ (ÎÇúÏù¥ÎèÑÎ≥Ñ)
                if (onsetStrength < settings.threshold) {
                    skippedWeak++;
                    continue;
                }

                // 2. ÏùåÏõê Î≤îÏúÑ Ï≤¥ÌÅ¨
                if (onsetTime < 0 || onsetTime > editorState.duration) {
                    continue;
                }

                // 3. BPM Í∑∏Î¶¨ÎìúÏóê Ïä§ÎÉÖ (Í∞ÄÏû• Í∞ÄÍπåÏö¥ 1/16Î∞ï)
                const beatPosition = (onsetTime - editorState.offset) / beatDuration;
                const snapDivisor = 16;
                const snappedBeat = Math.round(beatPosition * snapDivisor) / snapDivisor;
                const snappedTime = snappedBeat * beatDuration + editorState.offset;

                // 4. Ïú†Ìö® Î≤îÏúÑ Ïû¨ÌôïÏù∏
                if (snappedTime < 0 || snappedTime > editorState.duration) {
                    continue;
                }

                // 5. Ï§ëÎ≥µ Î∞©ÏßÄ (50ms Ïù¥ÎÇ¥)
                const isDuplicate = editorState.notes.some(note =>
                    Math.abs(note.time - snappedTime) < 0.05
                );
                if (isDuplicate) {
                    skippedDuplicate++;
                    continue;
                }

                // 6. Î†àÏù∏ Í≤∞Ï†ï - ÎìúÎüº ÌÉÄÏûÖ Í∏∞Î∞ò + Ï¢åÏö∞ Í∑†Ìòï
                let lane = 0;
                const kickStrength = editorState.kickOnsets[i] || 0;
                const snareStrength = editorState.snareOnsets[i] || 0;
                const hihatStrength = editorState.hihatOnsets[i] || 0;
                const maxDrumStrength = Math.max(kickStrength, snareStrength, hihatStrength);

                let isLeftHand = (lastLane === 0 || lastLane === 1);

                if (kickStrength === maxDrumStrength && kickStrength > 0.15) {
                    // Kick ‚Üí ÏôºÏÜê ÍµêÎåÄ (D‚ÜîF) - ÏôºÏÜê Ï†ÑÏö© Ìä∏ÎûòÏª§ ÏÇ¨Ïö©!
                    lane = (lastLeftLane === 0) ? 1 : 0;  // D‚ÜîF ÌôïÏã§Ìïú ÍµêÎåÄ
                    lastLeftLane = lane;  // ÏôºÏÜê ÎßàÏßÄÎßâ Î†àÏù∏ ÏóÖÎç∞Ïù¥Ìä∏
                } else if (snareStrength === maxDrumStrength && snareStrength > 0.15) {
                    // Snare ‚Üí Ïò§Î•∏ÏÜê ÍµêÎåÄ (J‚ÜîK) - Ïò§Î•∏ÏÜê Ï†ÑÏö© Ìä∏ÎûòÏª§ ÏÇ¨Ïö©!
                    lane = (lastRightLane === 3) ? 4 : 3;  // J‚ÜîK ÌôïÏã§Ìïú ÍµêÎåÄ
                    lastRightLane = lane;  // Ïò§Î•∏ÏÜê ÎßàÏßÄÎßâ Î†àÏù∏ ÏóÖÎç∞Ïù¥Ìä∏
                } else if (hihatStrength === maxDrumStrength && hihatStrength > 0.15) {
                    // Hi-hat ‚Üí Ïò§Î•∏ÏÜê ÍµêÎåÄ (J‚ÜîK)
                    lane = (lastRightLane === 3) ? 4 : 3;
                    lastRightLane = lane;
                } else {
                    // ÎìúÎüºÏù¥ Î™ÖÌôïÌïòÏßÄ ÏïäÏúºÎ©¥ Ï¢åÏö∞ ÍµêÎåÄ (Í∑†Ìòï Ïú†ÏßÄ)
                    if (isLeftHand) {
                        // ÏôºÏÜê ‚Üí Ïò§Î•∏ÏÜêÏúºÎ°ú
                        lane = (lastRightLane === 3) ? 4 : 3;
                        lastRightLane = lane;
                    } else {
                        // Ïò§Î•∏ÏÜê ‚Üí ÏôºÏÜêÏúºÎ°ú
                        lane = (lastLeftLane === 0) ? 1 : 0;
                        lastLeftLane = lane;
                    }
                }

                // 7. ÎÖ∏Ìä∏ Ï∂îÍ∞Ä (ÌôïÎ•† ÏóÜÏù¥ Î¨¥Ï°∞Í±¥!)
                editorState.notes.push({
                    time: parseFloat(snappedTime.toFixed(3)),
                    lane: lane
                });

                lastLane = lane;
            }

            editorState.notes.sort((a, b) => a.time - b.time);

            console.log(`‚úÖ Generated ${editorState.notes.length} notes`);
            console.log(`üìä Stats:`);
            console.log(`   - Processed onsets: ${processedOnsets}`);
            console.log(`   - Created notes: ${editorState.notes.length}`);
            console.log(`   - Skipped (too weak): ${skippedWeak}`);
            console.log(`   - Skipped (duplicate): ${skippedDuplicate}`);

            if (editorState.notes.length > 0) {
                const firstNote = editorState.notes[0];
                const lastNote = editorState.notes[editorState.notes.length - 1];
                console.log(`‚è±Ô∏è First: ${firstNote.time.toFixed(3)}s, Last: ${lastNote.time.toFixed(3)}s`);

                // Î†àÏù∏ Î∂ÑÌè¨ ÌÜµÍ≥Ñ
                const laneCounts = [0, 0, 0, 0, 0];
                editorState.notes.forEach(note => laneCounts[note.lane]++);
                const totalNotes = editorState.notes.length;
                console.log(`üéπ Lane distribution:`);
                console.log(`   D(0): ${laneCounts[0]} (${(laneCounts[0]/totalNotes*100).toFixed(1)}%)`);
                console.log(`   F(1): ${laneCounts[1]} (${(laneCounts[1]/totalNotes*100).toFixed(1)}%)`);
                console.log(`   Space(2): ${laneCounts[2]} (${(laneCounts[2]/totalNotes*100).toFixed(1)}%)`);
                console.log(`   J(3): ${laneCounts[3]} (${(laneCounts[3]/totalNotes*100).toFixed(1)}%)`);
                console.log(`   K(4): ${laneCounts[4]} (${(laneCounts[4]/totalNotes*100).toFixed(1)}%)`);

                // NPS (Notes Per Second) Í≥ÑÏÇ∞
                const nps = (editorState.notes.length / editorState.duration).toFixed(2);
                console.log(`üìà Average NPS: ${nps}`);
            }

            updateStats();
        }

        function regenerateNotes() {
            if (!editorState.audioBuffer) {
                alert('Î®ºÏ†Ä ÏùåÏõêÏùÑ Î°úÎìúÌïòÏÑ∏Ïöî.');
                return;
            }

            if (confirm('ÎÖ∏Ìä∏Î•º Îã§Ïãú ÏÉùÏÑ±ÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) {
                generateNotes();
                alert(`üîÑ Ïû¨ÏÉùÏÑ± ÏôÑÎ£å!\n\nÎÖ∏Ìä∏: ${editorState.notes.length}Í∞ú\nÎÇúÏù¥ÎèÑ: ${editorState.difficulty}`);
            }
        }

        async function initEditor() {
            calculateDimensions();

            app = new PIXI.Application();
            await app.init({
                width: GAME_WIDTH,
                height: GAME_HEIGHT,
                backgroundColor: 0x0a0a0a,
                antialias: true,
                resolution: window.devicePixelRatio || 1
            });

            document.getElementById('editor-canvas').appendChild(app.canvas);

            gameContainer = new PIXI.Container();
            gridContainer = new PIXI.Container();
            beatGridContainer = new PIXI.Container();
            onsetMarkersContainer = new PIXI.Container();
            notesContainer = new PIXI.Container();

            app.stage.addChild(gameContainer);
            app.stage.addChild(gridContainer);
            app.stage.addChild(beatGridContainer);
            app.stage.addChild(onsetMarkersContainer);
            app.stage.addChild(notesContainer);

            drawLanes();
            drawJudgmentLine();

            app.ticker.add(editorLoop);

            window.addEventListener('resize', () => {
                calculateDimensions();
                if (app) {
                    app.renderer.resize(GAME_WIDTH, GAME_HEIGHT);
                    gameContainer.removeChildren();
                    gridContainer.removeChildren();
                    drawLanes();
                    drawJudgmentLine();
                }
            });
        }

        function drawLanes() {
            for (let i = 0; i < LANES.length; i++) {
                const lane = new PIXI.Graphics();

                lane.rect(i * LANE_WIDTH, 0, LANE_WIDTH, GAME_HEIGHT / 2);
                lane.fill({ color: 0x16213e, alpha: 0.2 });

                lane.rect(i * LANE_WIDTH, GAME_HEIGHT / 2, LANE_WIDTH, GAME_HEIGHT / 2);
                lane.fill({ color: 0x16213e, alpha: 0.4 });

                lane.moveTo(i * LANE_WIDTH, 0);
                lane.lineTo(i * LANE_WIDTH, GAME_HEIGHT);
                lane.stroke({ color: LANES[i].color, width: 2, alpha: 0.5 });

                gameContainer.addChild(lane);

                const keyText = new PIXI.Text({
                    text: LANES[i].label,
                    style: {
                        fontSize: 28,
                        fill: LANES[i].color,
                        fontWeight: 'bold',
                        fontFamily: 'Orbitron'
                    }
                });
                keyText.anchor.set(0.5);
                keyText.x = i * LANE_WIDTH + LANE_WIDTH / 2;
                keyText.y = GAME_HEIGHT - 30;
                gameContainer.addChild(keyText);
            }
        }

        function drawJudgmentLine() {
            const line = new PIXI.Graphics();
            line.moveTo(0, JUDGMENT_LINE_Y);
            line.lineTo(GAME_WIDTH, JUDGMENT_LINE_Y);
            line.stroke({ color: 0xFFFFFF, width: 4 });

            const glow = new PIXI.Graphics();
            glow.moveTo(0, JUDGMENT_LINE_Y);
            glow.lineTo(GAME_WIDTH, JUDGMENT_LINE_Y);
            glow.stroke({ color: 0xFFFFFF, width: 20, alpha: 0.2 });

            gameContainer.addChild(glow);
            gameContainer.addChild(line);
        }

        function addNote(laneIndex, time) {
            const note = {
                time: parseFloat(time.toFixed(3)),
                lane: laneIndex
            };

            editorState.notes.push(note);
            editorState.notes.sort((a, b) => a.time - b.time);
            updateStats();
        }

        function deleteLastNote() {
            if (editorState.notes.length > 0) {
                editorState.notes.pop();
                updateStats();
            }
        }

        function showKeyFlash(laneIndex) {
            const flash = new PIXI.Graphics();
            flash.rect(laneIndex * LANE_WIDTH, JUDGMENT_LINE_Y - 50, LANE_WIDTH, 100);
            flash.fill({ color: LANES[laneIndex].color, alpha: 0.6 });
            gameContainer.addChild(flash);

            setTimeout(() => {
                gameContainer.removeChild(flash);
            }, 100);
        }

        function togglePlayback() {
            if (editorState.isPlaying) {
                pausePlayback();
            } else {
                startPlayback();
            }
        }

        function startPlayback() {
            if (!editorState.audioBuffer) {
                alert('Î®ºÏ†Ä ÏùåÏõêÏùÑ Î°úÎìúÌïòÏÑ∏Ïöî.');
                return;
            }

            if (editorState.audioSource) {
                editorState.audioSource.stop();
            }

            editorState.audioSource = editorState.audioContext.createBufferSource();
            editorState.audioSource.buffer = editorState.audioBuffer;
            editorState.audioSource.connect(editorState.audioContext.destination);

            const offset = editorState.currentTime || 0;
            editorState.audioSource.start(0, offset);
            editorState.startTime = editorState.audioContext.currentTime - offset;
            editorState.isPlaying = true;

            document.getElementById('status').textContent = 'Ïû¨ÏÉù Ï§ë';
            document.getElementById('play-btn').textContent = '‚è∏ ÏùºÏãúÏ†ïÏßÄ';

            editorState.audioSource.onended = () => {
                stopPlayback();
            };
        }

        function pausePlayback() {
            if (editorState.audioSource) {
                editorState.audioSource.stop();
                editorState.audioSource = null;
            }
            editorState.isPlaying = false;
            document.getElementById('status').textContent = 'ÏùºÏãúÏ†ïÏßÄ';
            document.getElementById('play-btn').textContent = '‚ñ∂ Ïû¨ÏÉù';
        }

        function stopPlayback() {
            if (editorState.audioSource) {
                editorState.audioSource.stop();
                editorState.audioSource = null;
            }
            editorState.isPlaying = false;
            editorState.currentTime = 0;
            document.getElementById('status').textContent = 'Ï†ïÏßÄ';
            document.getElementById('play-btn').textContent = '‚ñ∂ Ïû¨ÏÉù';
        }

        function editorLoop(ticker) {
            if (editorState.isPlaying && editorState.audioContext) {
                editorState.currentTime = editorState.audioContext.currentTime - editorState.startTime;
                document.getElementById('current-time').textContent = editorState.currentTime.toFixed(2) + 's';

                if (editorState.bpm > 0) {
                    const currentBeat = Math.floor((editorState.currentTime - editorState.offset) / (60 / editorState.bpm)) + 1;
                    document.getElementById('current-beat').textContent = currentBeat;
                }
            }

            // Draw beat grid lines
            beatGridContainer.removeChildren();
            if (editorState.bpm > 0) {
                const beatDuration = 60 / editorState.bpm;
                const NOTE_SPEED = 200;

                // Draw beat lines within visible range
                const visibleTime = GAME_HEIGHT / NOTE_SPEED;
                const startBeat = Math.floor((editorState.currentTime - editorState.offset) / beatDuration);
                const endBeat = Math.ceil((editorState.currentTime + visibleTime - editorState.offset) / beatDuration);

                for (let beat = startBeat; beat <= endBeat; beat++) {
                    const beatTime = beat * beatDuration + editorState.offset;
                    const timeDiff = beatTime - editorState.currentTime;
                    const lineY = JUDGMENT_LINE_Y - timeDiff * NOTE_SPEED;

                    if (lineY > -10 && lineY < GAME_HEIGHT + 10) {
                        const line = new PIXI.Graphics();

                        // Different colors for different beat types
                        if (beat % 4 === 0) {
                            // Measure line (white, thick)
                            line.moveTo(0, lineY);
                            line.lineTo(GAME_WIDTH, lineY);
                            line.stroke({ color: 0xFFFFFF, width: 2, alpha: 0.4 });
                        } else {
                            // Regular beat line (gray, thin)
                            line.moveTo(0, lineY);
                            line.lineTo(GAME_WIDTH, lineY);
                            line.stroke({ color: 0x888888, width: 1, alpha: 0.2 });
                        }

                        beatGridContainer.addChild(line);
                    }
                }
            }

            // Draw onset markers if enabled
            onsetMarkersContainer.removeChildren();
            if (editorState.showOnsets && editorState.onsets && editorState.onsets.length > 0) {
                const NOTE_SPEED = 200;
                const visibleTime = GAME_HEIGHT / NOTE_SPEED;

                // Get difficulty threshold to show which onsets become notes
                const difficultyThresholds = {
                    'Easy': 0.6,
                    'Normal': 0.45,
                    'Hard': 0.35,
                    'Expert': 0.25
                };
                const threshold = difficultyThresholds[editorState.difficulty] || 0.35;

                for (let i = 0; i < editorState.onsets.length; i++) {
                    const onsetTime = editorState.onsetTimes[i];
                    const onsetStrength = editorState.onsets[i];
                    const timeDiff = onsetTime - editorState.currentTime;

                    // Only draw onsets in visible range
                    if (Math.abs(timeDiff) > visibleTime) continue;

                    const lineY = JUDGMENT_LINE_Y - timeDiff * NOTE_SPEED;

                    if (lineY > -10 && lineY < GAME_HEIGHT + 10) {
                        const line = new PIXI.Graphics();

                        // Color based on onset strength
                        let color, alpha, width;
                        if (onsetStrength >= threshold) {
                            // Strong onset (becomes a note) - bright cyan
                            color = 0x00FFFF;
                            alpha = 0.8;
                            width = 3;
                        } else if (onsetStrength >= threshold * 0.7) {
                            // Medium onset - yellow
                            color = 0xFFFF00;
                            alpha = 0.5;
                            width = 2;
                        } else if (onsetStrength >= threshold * 0.4) {
                            // Weak onset - orange
                            color = 0xFFA500;
                            alpha = 0.3;
                            width = 1;
                        } else {
                            // Very weak - skip to reduce clutter
                            continue;
                        }

                        line.moveTo(0, lineY);
                        line.lineTo(GAME_WIDTH, lineY);
                        line.stroke({ color: color, width: width, alpha: alpha });

                        // Add drum type indicator on the right
                        if (onsetStrength >= threshold) {
                            const kickStrength = editorState.kickOnsets[i] || 0;
                            const snareStrength = editorState.snareOnsets[i] || 0;
                            const hihatStrength = editorState.hihatOnsets[i] || 0;
                            const maxDrumStrength = Math.max(kickStrength, snareStrength, hihatStrength);

                            let drumIndicator = '';
                            let indicatorColor = 0xFFFFFF;
                            if (kickStrength === maxDrumStrength && maxDrumStrength > 0.2) {
                                drumIndicator = 'K';
                                indicatorColor = 0xFF6B6B;
                            } else if (snareStrength === maxDrumStrength && maxDrumStrength > 0.2) {
                                drumIndicator = 'S';
                                indicatorColor = 0x4ECDC4;
                            } else if (hihatStrength === maxDrumStrength && maxDrumStrength > 0.2) {
                                drumIndicator = 'H';
                                indicatorColor = 0xFFE66D;
                            }

                            if (drumIndicator) {
                                const text = new PIXI.Text({
                                    text: drumIndicator,
                                    style: {
                                        fontSize: 12,
                                        fill: indicatorColor,
                                        fontWeight: 'bold',
                                        fontFamily: 'Orbitron'
                                    }
                                });
                                text.anchor.set(0, 0.5);
                                text.x = GAME_WIDTH - 20;
                                text.y = lineY;
                                onsetMarkersContainer.addChild(text);
                            }
                        }

                        onsetMarkersContainer.addChild(line);
                    }
                }
            }

            notesContainer.removeChildren();

            const NOTE_HEIGHT = 20;
            const NOTE_SPEED = 200;

            for (let i = 0; i < editorState.notes.length; i++) {
                const note = editorState.notes[i];
                const timeDiff = note.time - editorState.currentTime;
                const noteY = JUDGMENT_LINE_Y - timeDiff * NOTE_SPEED;

                if (noteY > -50 && noteY < GAME_HEIGHT + 50) {
                    const noteSprite = new PIXI.Graphics();
                    noteSprite.roundRect(0, 0, LANE_WIDTH - 10, NOTE_HEIGHT, 8);

                    let noteColor = LANES[note.lane].color;

                    // ÏÑ†ÌÉùÎêú ÎÖ∏Ìä∏Îäî Î∞ùÍ≤å ÌëúÏãú
                    const isSelected = editorState.selectedNotes.has(i);
                    const alpha = isSelected ? 1.0 : 0.9;
                    noteSprite.fill({ color: noteColor, alpha: alpha });

                    noteSprite.roundRect(0, 0, LANE_WIDTH - 10, NOTE_HEIGHT, 8);

                    // ÏÑ†ÌÉùÎêú ÎÖ∏Ìä∏Îäî ÎÖ∏ÎûÄÏÉâ ÌÖåÎëêÎ¶¨
                    const strokeColor = isSelected ? 0xFFFF00 : 0xFFFFFF;
                    const strokeWidth = isSelected ? 4 : 2;
                    noteSprite.stroke({ color: strokeColor, width: strokeWidth, alpha: isSelected ? 1.0 : 0.5 });

                    noteSprite.x = note.lane * LANE_WIDTH + 5;
                    noteSprite.y = noteY - NOTE_HEIGHT / 2;

                    // Ìé∏Ïßë Î™®ÎìúÏóêÏÑú ÌÅ¥Î¶≠ Í∞ÄÎä•ÌïòÎèÑÎ°ù ÏÑ§Ï†ï
                    if (editorState.editMode) {
                        noteSprite.interactive = true;
                        noteSprite.cursor = 'pointer';
                        noteSprite.eventMode = 'static';

                        noteSprite.on('pointerdown', (event) => {
                            if (editorState.selectedNotes.has(i)) {
                                editorState.selectedNotes.delete(i);
                                console.log(`‚ùå ÎÖ∏Ìä∏ ÏÑ†ÌÉù Ìï¥Ï†ú: ${i} (ÏãúÍ∞Ñ: ${note.time.toFixed(3)}s, Î†àÏù∏: ${note.lane})`);
                            } else {
                                editorState.selectedNotes.add(i);
                                console.log(`‚úÖ ÎÖ∏Ìä∏ ÏÑ†ÌÉù: ${i} (ÏãúÍ∞Ñ: ${note.time.toFixed(3)}s, Î†àÏù∏: ${note.lane})`);
                            }
                            console.log(`   Ï¥ù ÏÑ†ÌÉùÎêú ÎÖ∏Ìä∏: ${editorState.selectedNotes.size}Í∞ú`);
                        });
                    }

                    notesContainer.addChild(noteSprite);
                }
            }

            updateMinimap();
        }

        function updateStats() {
            document.getElementById('note-count').textContent = editorState.notes.length;

            if (editorState.duration > 0) {
                const nps = (editorState.notes.length / editorState.duration).toFixed(1);
                document.getElementById('nps-display').textContent = nps;
            }

            updateDensityGraph();
        }

        function updateDensityGraph() {
            const canvas = document.getElementById('density-graph');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (editorState.duration === 0 || editorState.notes.length === 0) return;

            const windowSize = 1;
            const windows = Math.ceil(editorState.duration / windowSize);
            const densities = [];

            for (let i = 0; i < windows; i++) {
                const start = i * windowSize;
                const end = (i + 1) * windowSize;
                const count = editorState.notes.filter(n => n.time >= start && n.time < end).length;
                densities.push(count);
            }

            const maxDensity = Math.max(...densities, 1);

            ctx.fillStyle = '#667eea';
            densities.forEach((density, i) => {
                const x = (i / windows) * canvas.width;
                const width = canvas.width / windows;
                const height = (density / maxDensity) * canvas.height;
                const y = canvas.height - height;

                ctx.fillRect(x, y, width, height);
            });

            if (editorState.duration > 0) {
                const x = (editorState.currentTime / editorState.duration) * canvas.width;
                ctx.strokeStyle = '#FF6B6B';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
        }

        function updateMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (editorState.duration === 0) return;

            editorState.notes.forEach(note => {
                const x = (note.time / editorState.duration) * canvas.width;
                const y = (note.lane / LANES.length) * canvas.height;
                const width = Math.max(2, canvas.width / 100);
                const height = canvas.height / LANES.length;

                let color = `#${LANES[note.lane].color.toString(16).padStart(6, '0')}`;

                ctx.fillStyle = color;
                ctx.fillRect(x, y, width, height);
            });

            const x = (editorState.currentTime / editorState.duration) * canvas.width;
            ctx.strokeStyle = '#FF6B6B';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }

        function saveChart() {
            const title = editorState.title || 'Untitled';
            const bpm = editorState.bpm;
            const difficulty = editorState.difficulty;

            const chartData = {
                title,
                bpm,
                offset: editorState.offset,
                difficulty,
                duration: editorState.duration,
                lanes: LANES.length,
                notes: editorState.notes,
                audioFileName: editorState.audioFileName,  // Ïò§ÎîîÏò§ ÌååÏùº Ïù¥Î¶Ñ Ï†ÄÏû•
                metadata: {
                    nps: (editorState.notes.length / editorState.duration).toFixed(2),
                    noteCount: editorState.notes.length,
                    createdAt: new Date().toISOString(),
                    editor: 'BEAT MASTER Auto'
                }
            };

            const dataStr = JSON.stringify(chartData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);

            const link = document.createElement('a');
            link.href = url;
            link.download = `${title.replace(/[^a-z0-9]/gi, '_')}_${difficulty}_chart.json`;
            link.click();

            URL.revokeObjectURL(url);
            alert('Ï∞®Ìä∏Í∞Ä Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§!');
        }

        function loadChart() {
            const input = document.getElementById('load-chart-input');
            const file = input.files[0];

            if (!file) {
                alert('ÌååÏùºÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const chartData = JSON.parse(e.target.result);

                    // Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ Î°úÎìú
                    editorState.notes = chartData.notes || [];
                    editorState.bpm = chartData.bpm || 120;
                    editorState.offset = chartData.offset || 0;
                    editorState.title = chartData.title || 'Untitled';
                    editorState.difficulty = chartData.difficulty || 'Hard';
                    editorState.duration = chartData.duration || 0;
                    editorState.audioFileName = chartData.audioFileName || '';

                    // UI ÏóÖÎç∞Ïù¥Ìä∏
                    document.getElementById('bpm-input').value = editorState.bpm;
                    document.getElementById('offset-input').value = editorState.offset;
                    document.getElementById('title-input').value = editorState.title;
                    document.getElementById('difficulty-select').value = editorState.difficulty;

                    // ÎÖ∏Ìä∏ Ïû¨Î†åÎçîÎßÅ
                    updateStats();

                    // Ïò§ÎîîÏò§Í∞Ä Î°úÎìúÎêòÏñ¥ ÏûàÏúºÎ©¥ ÌôîÎ©¥ ÏóÖÎç∞Ïù¥Ìä∏
                    if (editorState.audioBuffer) {
                        render();
                    }

                    alert(`Ï∞®Ìä∏ Î°úÎìú ÏôÑÎ£å!\nÎÖ∏Ìä∏: ${editorState.notes.length}Í∞ú\n${chartData.audioFileName ? 'Ïò§ÎîîÏò§ ÌååÏùº: ' + chartData.audioFileName : 'Ïò§ÎîîÏò§ ÌååÏùºÏùÑ Î≥ÑÎèÑÎ°ú Î°úÎìúÌï¥Ï£ºÏÑ∏Ïöî.'}`);

                    // ÏûÖÎ†• Ï¥àÍ∏∞Ìôî
                    input.value = '';
                } catch (error) {
                    console.error('Ï∞®Ìä∏ Î°úÎìú Ïã§Ìå®:', error);
                    alert('Ï∞®Ìä∏ ÌååÏùºÏùÑ ÏùΩÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
                }
            };

            reader.readAsText(file);
        }

        function toggleEditMode() {
            editorState.editMode = !editorState.editMode;
            const btn = document.getElementById('edit-mode-btn');
            const statusText = document.getElementById('edit-mode-status');
            const deleteBtn = document.getElementById('delete-note-btn');

            if (editorState.editMode) {
                btn.textContent = '‚úèÔ∏è Ìé∏ÏßëÏ§ë';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-success');
                statusText.textContent = 'Ìé∏ÏßëÎ™®Îìú (ÎÖ∏Ìä∏ ÌÅ¥Î¶≠)';
                statusText.style.color = '#38ef7d';
                deleteBtn.disabled = false;
                console.log('‚úèÔ∏è Ìé∏Ïßë Î™®Îìú ÌôúÏÑ±Ìôî: ÎÖ∏Ìä∏Î•º ÌÅ¥Î¶≠ÌïòÏó¨ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî');
            } else {
                btn.textContent = '‚úèÔ∏è Ìé∏ÏßëÎ™®Îìú';
                btn.classList.remove('btn-success');
                btn.classList.add('btn-primary');
                statusText.textContent = 'ÏùºÎ∞òÎ™®Îìú';
                statusText.style.color = '#aaa';
                deleteBtn.disabled = true;
                editorState.selectedNotes.clear();
                console.log('‚úèÔ∏è ÏùºÎ∞ò Î™®ÎìúÎ°ú Ï†ÑÌôò');
            }
        }

        function deleteSelectedNotes() {
            if (editorState.selectedNotes.size === 0) {
                alert('ÏÇ≠Ï†úÌï† ÎÖ∏Ìä∏Î•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }

            const count = editorState.selectedNotes.size;
            if (!confirm(`ÏÑ†ÌÉùÌïú ${count}Í∞úÏùò ÎÖ∏Ìä∏Î•º ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?`)) {
                return;
            }

            // ÏÑ†ÌÉùÎêú Ïù∏Îç±Ïä§Î•º Î∞∞Ïó¥Î°ú Î≥ÄÌôòÌïòÍ≥† ÎÇ¥Î¶ºÏ∞®Ïàú Ï†ïÎ†¨ (Îí§ÏóêÏÑúÎ∂ÄÌÑ∞ ÏÇ≠Ï†ú)
            const selectedIndices = Array.from(editorState.selectedNotes).sort((a, b) => b - a);

            for (const index of selectedIndices) {
                editorState.notes.splice(index, 1);
            }

            editorState.selectedNotes.clear();
            updateStats();
            render();

            console.log(`üóëÔ∏è ${count}Í∞úÏùò ÎÖ∏Ìä∏ ÏÇ≠Ï†úÎê®. ÎÇ®ÏùÄ ÎÖ∏Ìä∏: ${editorState.notes.length}Í∞ú`);
            alert(`${count}Í∞úÏùò ÎÖ∏Ìä∏Í∞Ä ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.`);
        }

        function getNoteAtPosition(x, y) {
            // ÌôîÎ©¥ Ï¢åÌëúÎ•º Í≤åÏûÑ Ï¢åÌëúÎ°ú Î≥ÄÌôò
            const lane = Math.floor(x / LANE_WIDTH);
            if (lane < 0 || lane >= LANES.length) return -1;

            // ÌòÑÏû¨ ÏãúÍ∞Ñ Í∏∞Ï§ÄÏúºÎ°ú ÎÖ∏Ìä∏ Ï∞æÍ∏∞
            const clickTime = editorState.currentTime + (JUDGMENT_LINE_Y - y) / (GAME_HEIGHT * 0.8);

            // ÌÅ¥Î¶≠ ÏúÑÏπòÏóêÏÑú Í∞ÄÏû• Í∞ÄÍπåÏö¥ ÎÖ∏Ìä∏ Ï∞æÍ∏∞ (0.5Ï¥à Î≤îÏúÑ ÎÇ¥)
            let closestIndex = -1;
            let closestDistance = 0.5;  // ÏµúÎåÄ 0.5Ï¥à Î≤îÏúÑ

            for (let i = 0; i < editorState.notes.length; i++) {
                const note = editorState.notes[i];
                if (note.lane === lane) {
                    const distance = Math.abs(note.time - clickTime);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestIndex = i;
                    }
                }
            }

            return closestIndex;
        }

        function moveSelectedNotesToLane(targetLane) {
            if (editorState.selectedNotes.size === 0) return;

            const selectedIndices = Array.from(editorState.selectedNotes);
            for (const index of selectedIndices) {
                if (editorState.notes[index]) {
                    editorState.notes[index].lane = targetLane;
                }
            }

            updateStats();
            console.log(`üîÑ ${selectedIndices.length}Í∞ú ÎÖ∏Ìä∏Î•º Î†àÏù∏ ${targetLane}(${LANES[targetLane].label})Î°ú Ïù¥Îèô`);
        }

        function adjustSelectedNotesTiming(delta) {
            if (editorState.selectedNotes.size === 0) return;

            const selectedIndices = Array.from(editorState.selectedNotes);
            for (const index of selectedIndices) {
                if (editorState.notes[index]) {
                    editorState.notes[index].time += delta;
                    // ÏµúÏÜå 0Ï¥à Ï†úÌïú
                    if (editorState.notes[index].time < 0) {
                        editorState.notes[index].time = 0;
                    }
                }
            }

            // ÎÖ∏Ìä∏Î•º ÏãúÍ∞ÑÏàúÏúºÎ°ú Ïû¨Ï†ïÎ†¨
            editorState.notes.sort((a, b) => a.time - b.time);

            updateStats();
            console.log(`‚è±Ô∏è ${selectedIndices.length}Í∞ú ÎÖ∏Ìä∏ ÌÉÄÏù¥Î∞ç Ï°∞Ï†ï: ${delta > 0 ? '+' : ''}${(delta * 1000).toFixed(0)}ms`);
        }
    </script>
</body>
</html>
