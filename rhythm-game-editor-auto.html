<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BookJam - Note Editor</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Noto+Sans+KR:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: 'Orbitron', 'Noto Sans KR', sans-serif;
            background: linear-gradient(135deg, #0F2027 0%, #203A43 50%, #2C5364 100%);
            color: white;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #control-panel {
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            padding: 15px 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            border-bottom: 2px solid rgba(102, 126, 234, 0.5);
            max-height: 120px;
            overflow-y: auto;
        }

        .control-group {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        label {
            font-size: 12px;
            color: #aaa;
            white-space: nowrap;
        }

        input[type="file"] {
            display: none;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            white-space: nowrap;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.6);
        }

        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        input[type="number"], input[type="text"], select {
            padding: 6px 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
        }

        input[type="number"] {
            width: 80px;
        }

        input[type="text"] {
            width: 150px;
        }

        select {
            width: 120px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }

        #editor-container {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }

        #left-sidebar {
            width: 200px;
            background: rgba(0, 0, 0, 0.9);
            border-right: 2px solid rgba(102, 126, 234, 0.3);
            padding: 15px;
            overflow-y: auto;
        }

        #left-sidebar h3 {
            margin-bottom: 10px;
            color: #667eea;
            font-size: 14px;
        }

        .sidebar-section {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-box {
            background: rgba(102, 126, 234, 0.15);
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 10px;
            line-height: 1.5;
        }

        #editor-canvas {
            flex: 1;
            background: #0a0a0a;
            position: relative;
        }

        #editor-canvas canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        #right-sidebar {
            width: 220px;
            background: rgba(0, 0, 0, 0.9);
            border-left: 2px solid rgba(102, 126, 234, 0.3);
            padding: 15px;
            overflow-y: auto;
        }

        #right-sidebar h3 {
            margin-bottom: 10px;
            color: #667eea;
            font-size: 14px;
        }

        .info-item {
            margin: 8px 0;
            font-size: 12px;
        }

        .info-item strong {
            color: #667eea;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .stat-box {
            background: rgba(102, 126, 234, 0.1);
            padding: 8px;
            border-radius: 4px;
            text-align: center;
        }

        .stat-box .label {
            font-size: 10px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .stat-box .value {
            font-size: 16px;
            font-weight: bold;
            color: #667eea;
        }

        .key-hint {
            background: rgba(102, 126, 234, 0.2);
            padding: 10px;
            border-radius: 6px;
            margin-top: 15px;
            font-size: 11px;
            line-height: 1.6;
        }

        .density-graph, #minimap {
            width: 100%;
            height: 80px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 6px;
            margin-top: 10px;
            border: 1px solid rgba(102, 126, 234, 0.3);
        }

        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        #loading-overlay.show {
            display: flex;
        }

        .loading-content {
            text-align: center;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <h2 id="loading-text">ë¶„ì„ ì¤‘...</h2>
            <p id="loading-detail">ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”</p>
        </div>
    </div>

    <div id="container">
        <div id="control-panel">
            <div class="control-group">
                <label for="file-input" class="btn btn-primary">ğŸ“ ìŒì› ë¡œë“œ</label>
                <input type="file" id="file-input" accept="audio/*">
                <span id="file-name" style="font-size: 11px;">íŒŒì¼ ì—†ìŒ</span>
            </div>

            <div class="control-group">
                <label>BPM:</label>
                <input type="number" id="bpm-input" value="0" min="60" max="240" step="0.5">
                <button class="btn btn-primary" id="override-bpm-btn" style="padding: 6px 10px; font-size: 10px;" disabled>ì ìš©</button>
                <button class="btn btn-success" id="tap-bpm-btn" style="padding: 6px 10px; font-size: 10px;" disabled>ğŸµ Tap</button>
            </div>

            <div class="control-group">
                <label>Offset:</label>
                <input type="number" id="offset-input" value="0" step="0.01" style="width: 70px;">
                <button class="btn btn-primary" id="offset-minus-btn" style="padding: 6px 8px; font-size: 10px;" disabled>-0.01</button>
                <button class="btn btn-primary" id="offset-plus-btn" style="padding: 6px 8px; font-size: 10px;" disabled>+0.01</button>
                <button class="btn btn-success" id="mark-beat-btn" style="padding: 6px 10px; font-size: 10px;" disabled>1ë°•</button>
            </div>

            <div class="control-group">
                <label>ì œëª©:</label>
                <input type="text" id="title-input" placeholder="Title">
            </div>

            <div class="control-group">
                <label>ë‚œì´ë„:</label>
                <select id="difficulty-select">
                    <option value="Easy">Easy</option>
                    <option value="Normal">Normal</option>
                    <option value="Hard" selected>Hard</option>
                    <option value="Expert">Expert</option>
                </select>
            </div>

            <div class="control-group">
                <button class="btn btn-primary" id="play-btn" disabled>â–¶ ì¬ìƒ</button>
                <button class="btn btn-danger" id="stop-btn" disabled>â¹ ì •ì§€</button>
            </div>

            <div class="control-group">
                <button class="btn btn-success" id="regen-btn" disabled>ğŸ”„ ì¬ìƒì„±</button>
                <button class="btn btn-success" id="save-btn" disabled>ğŸ’¾ ì €ì¥</button>
                <label for="load-chart-input" class="btn btn-primary" id="load-chart-btn" disabled>ğŸ“‚ ë¶ˆëŸ¬ì˜¤ê¸°</label>
                <input type="file" id="load-chart-input" accept=".json">
                <button class="btn btn-primary" id="toggle-onset-btn" disabled>ğŸ‘ï¸ Onset</button>
            </div>

            <div class="control-group">
                <button class="btn btn-danger" id="delete-note-btn" disabled>ğŸ—‘ï¸ ë…¸íŠ¸ ì‚­ì œ</button>
                <button class="btn btn-primary" id="edit-mode-btn" disabled>âœï¸ í¸ì§‘ëª¨ë“œ</button>
                <span id="edit-mode-status" style="font-size: 11px; color: #aaa;">ì¼ë°˜ëª¨ë“œ</span>
            </div>

            <div class="control-group">
                <button class="btn btn-primary" id="long-note-mode-btn" disabled>ğŸµ ë¡±ë…¸íŠ¸ ëª¨ë“œ</button>
                <span id="long-note-status" style="font-size: 11px; color: #aaa;">ì¼ë°˜ ë…¸íŠ¸</span>
            </div>
        </div>

        <div id="editor-container">
            <div id="left-sidebar">
                <div class="sidebar-section">
                    <h3>ğŸ¯ Pure Onset ì‹œìŠ¤í…œ</h3>
                    <div class="info-box">
                        <strong>í™•ë¥  ì—†ìŒ! 1:1 ë§¤í•‘!</strong><br>
                        <br>
                        <strong>âœ… ì›ìƒ· = ë…¸íŠ¸:</strong><br>
                        â€¢ Onset ê°ì§€ â†’ ë¬´ì¡°ê±´ ë…¸íŠ¸<br>
                        â€¢ í™•ë¥ /ëœë¤ ì™„ì „ ì œê±°<br>
                        â€¢ BPM ê·¸ë¦¬ë“œì— ìŠ¤ëƒ… (1/16ë°•)<br>
                        <br>
                        <strong>ğŸ§ ì•…ê¸°ë³„ ìë™ ë§¤í•‘:</strong><br>
                        â€¢ Kick â†’ ì™¼ì† (Dâ†”F)<br>
                        â€¢ Snare â†’ ì˜¤ë¥¸ì† (Jâ†”K)<br>
                        â€¢ Hi-hat â†’ ì˜¤ë¥¸ì† (Jâ†”K)<br>
                        <br>
                        <strong>ë‚œì´ë„ = Threshold:</strong><br>
                        Easy: ê°•í•œ ë¹„íŠ¸ë§Œ<br>
                        Hard: ì¤‘ê°„ ë¹„íŠ¸ê¹Œì§€<br>
                        Expert: ì•½í•œ ë¹„íŠ¸ê¹Œì§€
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>ğŸ‘ï¸ Onset ì‹œê°í™”</h3>
                    <div class="info-box">
                        <strong>ğŸ” Onset ë²„íŠ¼:</strong><br>
                        ê°ì§€ëœ ë¹„íŠ¸ë¥¼ ì‹œê°í™”!<br>
                        <br>
                        <strong>ìƒ‰ìƒ ì˜ë¯¸:</strong><br>
                        <span style="color: #00FFFF;">â— ì²­ë¡ìƒ‰</span> - ë…¸íŠ¸ ìƒì„±ë¨<br>
                        <span style="color: #FFFF00;">â— ë…¸ë€ìƒ‰</span> - ì¤‘ê°„ ê°•ë„<br>
                        <span style="color: #FFA500;">â— ì£¼í™©ìƒ‰</span> - ì•½í•œ ë¹„íŠ¸<br>
                        <br>
                        <strong>ì•…ê¸° í‘œì‹œ:</strong><br>
                        <span style="color: #FF6B6B;">K</span> = Kick (í‚¥ë“œëŸ¼)<br>
                        <span style="color: #4ECDC4;">S</span> = Snare (ìŠ¤ë„¤ì–´)<br>
                        <span style="color: #FFE66D;">H</span> = Hi-hat (í•˜ì´í–‡)<br>
                        <br>
                        ì²­ë¡ìƒ‰ ì„ ì´ ë…¸íŠ¸ì™€ ì¼ì¹˜í•˜ëŠ”ì§€<br>
                        í™•ì¸í•´ì„œ íƒ€ì´ë° ê²€ì¦!
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>âš™ï¸ ìˆ˜ë™ ì¡°ì •</h3>
                    <div class="info-box">
                        <strong>ğŸµ Tap BPM:</strong><br>
                        ì¬ìƒí•˜ë©° 1ë°•ë§ˆë‹¤ í´ë¦­<br>
                        â†’ ìë™ìœ¼ë¡œ BPM ê³„ì‚°<br>
                        <br>
                        <strong>1ë°• ë²„íŠ¼:</strong><br>
                        ì¬ìƒ ì¤‘ 1ë°•ì—ì„œ í´ë¦­<br>
                        â†’ Offset ìë™ ì„¤ì •<br>
                        <br>
                        <strong>ë¯¸ì„¸ì¡°ì •:</strong><br>
                        â€¢ +/- ë²„íŠ¼ìœ¼ë¡œ 0.01ì´ˆì”©<br>
                        â€¢ ë…¸íŠ¸ê°€ í° ì„ ì— ë§ê²Œ<br>
                        <br>
                        <strong>ìˆœì„œ:</strong><br>
                        1. Tap BPMìœ¼ë¡œ BPM ì¸¡ì •<br>
                        2. "ì ìš©" í´ë¦­<br>
                        3. ì¬ìƒí•˜ë©° 1ë°• ë²„íŠ¼<br>
                        4. +/- ë¡œ ë¯¸ì„¸ì¡°ì •
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>ë ˆì¸ ë§¤í•‘</h3>
                    <div class="info-box">
                        <strong>ğŸ® ë””ì œì´ë§¥ìŠ¤ íŒ¨í„´!</strong><br>
                        <br>
                        <strong>Kick:</strong> ì™¼ì† (Dâ†”F)<br>
                        <strong>Snare:</strong> ì˜¤ë¥¸ì† (Jâ†”K)<br>
                        <strong>Hi-hat:</strong> ì˜¤ë¥¸ì† (Jâ†”K)<br>
                        <br>
                        <strong>ê°•ë°•:</strong> ì™¼ì†â†”ì˜¤ë¥¸ì† êµëŒ€<br>
                        <strong>ì•½ë°•:</strong> ê°™ì€ ì† ì—°íƒ€<br>
                        <strong>Space:</strong> ê±°ì˜ ì•ˆ ì”€<br>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>ğŸ® ë‚œì´ë„ë³„ íŠ¹ì„±</h3>
                    <div class="info-box">
                        <strong>Easy (3ë ˆì¸):</strong><br>
                        â€¢ ë ˆì¸: D - Space - K<br>
                        â€¢ ë°•ì: 1/2ë°•ì (ê°•í•œ ë¹„íŠ¸)<br>
                        â€¢ ë¡±ë…¸íŠ¸: ì—°ì† ë…¸íŠ¸ ìë™ ë³€í™˜<br>
                        â€¢ ëŒ€ìƒ: ì´ˆë“± ì €í•™ë…„<br>
                        <br>
                        <strong>Normal (4ë ˆì¸):</strong><br>
                        â€¢ ë ˆì¸: D - F - J - K<br>
                        â€¢ ë°•ì: 1/4ë°•ì (ì¤‘ê°„ ë¹„íŠ¸)<br>
                        â€¢ ë¡±ë…¸íŠ¸: ì—°ì† ë…¸íŠ¸ ìë™ ë³€í™˜<br>
                        â€¢ ëŒ€ìƒ: ì´ˆë“± ê³ í•™ë…„<br>
                        <br>
                        <strong>Hard (5ë ˆì¸):</strong><br>
                        â€¢ ë ˆì¸: D - F - Space - J - K<br>
                        â€¢ ë°•ì: 1/4 + 1/8ë°•ì<br>
                        â€¢ ë¡±ë…¸íŠ¸: ì—°ì† ë…¸íŠ¸ ìë™ ë³€í™˜<br>
                        â€¢ ëŒ€ìƒ: ì¤‘í•™ìƒ+<br>
                        <br>
                        <strong>Expert (5ë ˆì¸):</strong><br>
                        â€¢ ë ˆì¸: D - F - Space - J - K<br>
                        â€¢ ë°•ì: 1/4+1/8+1/16ë°•ì<br>
                        â€¢ ë¡±ë…¸íŠ¸: ì—°ì† ë…¸íŠ¸ ìë™ ë³€í™˜<br>
                        â€¢ ëŒ€ìƒ: ê³ ê¸‰ í”Œë ˆì´ì–´
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>ìˆ˜ë™ ì¡°ì •</h3>
                    <div class="info-box">
                        ì¬ìƒí•˜ë©° ë…¸íŠ¸ ì¶”ê°€:<br>
                        D, F, Space, J, K<br>
                        <br>
                        Delete: ë§ˆì§€ë§‰ ì‚­ì œ<br>
                        ğŸ”„ ì¬ìƒì„±: ìƒˆë¡œ ìƒì„±
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>ğŸµ ë¡± ë…¸íŠ¸ ì‹œìŠ¤í…œ</h3>
                    <div class="info-box">
                        <strong>âœ¨ ìë™ ìƒì„± (ìµœì í™”ë¨):</strong><br>
                        â€¢ ì¡°ê±´: ê°™ì€ ë ˆì¸ 1ì´ˆ ì´ë‚´<br>
                        â€¢ ìµœì†Œ: 2ê°œ ì—°ì†, 0.1ì´ˆ ì´ìƒ<br>
                        â€¢ ìƒì„± í›„ ì ê¸ˆ (ì•ˆì •ì )<br>
                        <br>
                        <strong>ìµœì í™” ë””ìì¸:</strong><br>
                        â€¢ í—¤ë“œ: ë‘êº¼ìš´ ìº¡ (1.5ë°°)<br>
                        â€¢ ë³¸ì²´: ë‹¨ìƒ‰ (50% íˆ¬ëª…ë„)<br>
                        â€¢ í…Œì¼: ë‘êº¼ìš´ ìº¡ (1.5ë°°)<br>
                        â€¢ í…Œë‘ë¦¬: í°ìƒ‰ 4px<br>
                        <br>
                        <strong>ì„±ëŠ¥ ê°œì„ :</strong><br>
                        â€¢ í™”ë©´ ë°– ë…¸íŠ¸ ì»¬ë§<br>
                        â€¢ ë Œë”ë§ ìµœì í™”<br>
                        â€¢ ë””ë²„ê·¸ ë¡œê·¸ ì œê±°<br>
                        <br>
                        <strong>ğŸ® ìˆ˜ë™ ì¶”ê°€:</strong><br>
                        1. "ë¡±ë…¸íŠ¸ ëª¨ë“œ" ë²„íŠ¼ í´ë¦­<br>
                        2. ì¬ìƒí•˜ë©° í‚¤ë¥¼ ëˆ„ë¥´ê³  ìˆê¸°<br>
                        3. ì›í•˜ëŠ” ê¸¸ì´ë§Œí¼ ëˆ„ë¥¸ ë’¤ ë–¼ê¸°<br>
                        <br>
                        <strong>ì‹œê° íš¨ê³¼:</strong><br>
                        â€¢ í—¤ë“œ: ì‹œì‘ (ì§„í•œ ìƒ‰)<br>
                        â€¢ ë³¸ì²´: ì¤‘ê°„ (ë°˜íˆ¬ëª… ë§‰ëŒ€)<br>
                        â€¢ í…Œì¼: ë (ì§„í•œ ìƒ‰)<br>
                        â€¢ ì…ë ¥ ì¤‘: ì´ˆë¡ í…Œë‘ë¦¬
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>âœï¸ í¸ì§‘ ëª¨ë“œ (E)</h3>
                    <div class="info-box">
                        <strong>ë…¸íŠ¸ ì„ íƒ:</strong><br>
                        â€¢ ë…¸íŠ¸ í´ë¦­ìœ¼ë¡œ ì„ íƒ/í•´ì œ<br>
                        â€¢ ESC: ì„ íƒ í•´ì œ<br>
                        <br>
                        <strong>ì„ íƒëœ ë…¸íŠ¸ í¸ì§‘:</strong><br>
                        â€¢ D/F/Space/J/K: ë ˆì¸ ì´ë™<br>
                        â€¢ â†/â†’: íƒ€ì´ë° ì¡°ì • (Â±10ms)<br>
                        â€¢ Delete/Backspace: ì‚­ì œ<br>
                        <br>
                        <strong>ë‹¨ì¶•í‚¤:</strong><br>
                        â€¢ E: í¸ì§‘ëª¨ë“œ í† ê¸€<br>
                        â€¢ Ctrl+S: ì°¨íŠ¸ ì €ì¥
                    </div>
                </div>
            </div>

            <div id="editor-canvas"></div>

            <div id="right-sidebar">
                <h3>CHART INFO</h3>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="label">NOTES</div>
                        <div class="value" id="note-count">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">NPS</div>
                        <div class="value" id="nps-display">0.0</div>
                    </div>
                </div>

                <div style="margin-top: 15px;">
                    <div class="info-item">
                        ì‹œê°„: <strong id="current-time">0.00s</strong>
                    </div>
                    <div class="info-item">
                        ë°•ì: <strong id="current-beat">0</strong>
                    </div>
                    <div class="info-item">
                        ìƒíƒœ: <strong id="status">ëŒ€ê¸° ì¤‘</strong>
                    </div>
                    <div class="info-item">
                        BPM: <strong id="detected-bpm">-</strong>
                    </div>
                </div>

                <h3 style="margin-top: 20px;">DENSITY</h3>
                <canvas id="density-graph" class="density-graph"></canvas>

                <h3 style="margin-top: 20px;">MINIMAP</h3>
                <canvas id="minimap"></canvas>

                <div class="key-hint">
                    <strong>ğŸ¹ ë‹¨ì¶•í‚¤</strong><br>
                    <kbd>D F Space J K</kbd> ë…¸íŠ¸<br>
                    <kbd>Delete</kbd> ì‚­ì œ<br>
                    <kbd>Space</kbd> ì¬ìƒ/ì •ì§€<br>
                    <kbd>E</kbd> í¸ì§‘ëª¨ë“œ<br>
                    <br>
                    <strong>ğŸµ ë¡± ë…¸íŠ¸</strong><br>
                    ë¡±ë…¸íŠ¸ ëª¨ë“œ ON â†’ í‚¤ ëˆ„ë¥´ê³  ìˆê¸°<br>
                    <br>
                    <strong>ğŸ’¡ ì‚¬ìš©ë²•</strong><br>
                    1. ìŒì›ë§Œ ë¡œë“œí•˜ì„¸ìš”!<br>
                    2. ìë™ìœ¼ë¡œ ë¶„ì„ë©ë‹ˆë‹¤<br>
                    3. ë°”ë¡œ ì¬ìƒ ê°€ëŠ¥!<br>
                    4. Offsetìœ¼ë¡œ ë¯¸ì„¸ì¡°ì •
                </div>
            </div>
        </div>
    </div>

    <script src="https://pixijs.download/release/pixi.js"></script>
    <script>
        // ì „ì²´ ë ˆì¸ ì •ì˜ (5ë ˆì¸)
        const ALL_LANES = [
            { key: 'KeyD', index: 0, color: 0xFF6B6B, label: 'D', position: 'left' },
            { key: 'KeyF', index: 1, color: 0x4ECDC4, label: 'F', position: 'left' },
            { key: 'Space', index: 2, color: 0xFFE66D, label: 'â£', position: 'center' },
            { key: 'KeyJ', index: 3, color: 0x95E1D3, label: 'J', position: 'right' },
            { key: 'KeyK', index: 4, color: 0xF38181, label: 'K', position: 'right' }
        ];

        // ë‚œì´ë„ë³„ ë ˆì¸ êµ¬ì„±
        const DIFFICULTY_LANES = {
            'Easy': [
                { key: 'KeyD', index: 0, color: 0xFF6B6B, label: 'D', position: 'left', originalIndex: 0 },
                { key: 'Space', index: 1, color: 0xFFE66D, label: 'â£', position: 'center', originalIndex: 2 },
                { key: 'KeyK', index: 2, color: 0xF38181, label: 'K', position: 'right', originalIndex: 4 }
            ],
            'Normal': [
                { key: 'KeyD', index: 0, color: 0xFF6B6B, label: 'D', position: 'left', originalIndex: 0 },
                { key: 'KeyF', index: 1, color: 0x4ECDC4, label: 'F', position: 'left', originalIndex: 1 },
                { key: 'KeyJ', index: 2, color: 0x95E1D3, label: 'J', position: 'right', originalIndex: 3 },
                { key: 'KeyK', index: 3, color: 0xF38181, label: 'K', position: 'right', originalIndex: 4 }
            ],
            'Hard': ALL_LANES.map((lane, idx) => ({ ...lane, originalIndex: idx })),
            'Expert': ALL_LANES.map((lane, idx) => ({ ...lane, originalIndex: idx }))
        };

        // í˜„ì¬ í™œì„± ë ˆì¸ (ë‚œì´ë„ì— ë”°ë¼ ë³€ê²½ë¨)
        let LANES = DIFFICULTY_LANES['Hard'];

        const editorState = {
            notes: [],
            audioContext: null,
            audioBuffer: null,
            audioSource: null,
            startTime: 0,
            currentTime: 0,
            isPlaying: false,
            bpm: 0,
            offset: 0,
            title: '',
            difficulty: 'Hard',
            duration: 0,
            onsets: [],  // Overall onset strengths
            onsetTimes: [],
            bassOnsets: [],   // Bass line (40-100Hz) - Task #3
            kickOnsets: [],   // Kick drum (100-150Hz) - Task #3
            snareOnsets: [],  // Snare drum (mid freq)
            hihatOnsets: [],  // Hi-hat (high freq)
            melodyOnsets: [],  // Melody (200-2000Hz, spectral flux) - Task #1
            musicStructure: [], // Music structure sections (Intro/Verse/Chorus) - Task #2
            showOnsets: false,   // Toggle onset visualization
            editMode: false,     // Edit mode for note selection/editing
            selectedNotes: new Set(),  // Set of selected note indices
            audioFileName: '',   // Original audio file name
            longNoteMode: false, // Long note mode toggle
            activeLongNotes: {}, // Currently active long notes { lane: { startTime, startIndex } }
            longNotesConverted: false // ë¡±ë…¸íŠ¸ ë³€í™˜ ì™„ë£Œ í”Œë˜ê·¸ (ì¤‘ë³µ ë°©ì§€)
        };

        let app, gameContainer, notesContainer, gridContainer, beatGridContainer, onsetMarkersContainer;
        let GAME_WIDTH, GAME_HEIGHT, LANE_WIDTH, JUDGMENT_LINE_Y;

        function showLoading(text, detail = '') {
            document.getElementById('loading-text').textContent = text;
            document.getElementById('loading-detail').textContent = detail;
            document.getElementById('loading-overlay').classList.add('show');
        }

        function hideLoading() {
            document.getElementById('loading-overlay').classList.remove('show');
        }

        function calculateDimensions() {
            const canvas = document.getElementById('editor-canvas');
            GAME_WIDTH = canvas.clientWidth;
            GAME_HEIGHT = canvas.clientHeight;
            LANE_WIDTH = GAME_WIDTH / LANES.length;
            JUDGMENT_LINE_Y = GAME_HEIGHT - 100;
        }

        window.addEventListener('load', async () => {
            setupUI();
            await initEditor();
        });

        function setupUI() {
            document.getElementById('file-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    document.getElementById('file-name').textContent = file.name.substring(0, 20);
                    document.getElementById('title-input').value = file.name.replace(/\.[^/.]+$/, "");
                    editorState.title = file.name.replace(/\.[^/.]+$/, "");
                    editorState.audioFileName = file.name;  // ì˜¤ë””ì˜¤ íŒŒì¼ ì´ë¦„ ì €ì¥
                    await loadAndAnalyzeAudio(file);
                }
            });

            document.getElementById('play-btn').addEventListener('click', togglePlayback);
            document.getElementById('stop-btn').addEventListener('click', stopPlayback);
            document.getElementById('save-btn').addEventListener('click', saveChart);
            document.getElementById('load-chart-input').addEventListener('change', loadChart);
            document.getElementById('regen-btn').addEventListener('click', regenerateNotes);

            document.getElementById('override-bpm-btn').addEventListener('click', () => {
                const newBPM = parseFloat(document.getElementById('bpm-input').value);
                if (newBPM >= 60 && newBPM <= 240) {
                    editorState.bpm = newBPM;
                    regenerateNotes();
                    console.log(`âœï¸ BPM manually adjusted to ${newBPM}`);
                } else {
                    alert('BPMì€ 60-240 ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤.');
                }
            });

            document.getElementById('offset-input').addEventListener('change', (e) => {
                editorState.offset = parseFloat(e.target.value);
                regenerateNotes();
                console.log(`âœï¸ Offset manually adjusted to ${editorState.offset.toFixed(3)}s`);
            });

            document.getElementById('offset-minus-btn').addEventListener('click', () => {
                editorState.offset -= 0.01;
                document.getElementById('offset-input').value = editorState.offset.toFixed(3);
                regenerateNotes();
                console.log(`âœï¸ Offset: ${editorState.offset.toFixed(3)}s`);
            });

            document.getElementById('offset-plus-btn').addEventListener('click', () => {
                editorState.offset += 0.01;
                document.getElementById('offset-input').value = editorState.offset.toFixed(3);
                regenerateNotes();
                console.log(`âœï¸ Offset: ${editorState.offset.toFixed(3)}s`);
            });

            // Tap BPM ê¸°ëŠ¥
            let tapTimes = [];
            document.getElementById('tap-bpm-btn').addEventListener('click', () => {
                const now = Date.now();
                tapTimes.push(now);

                // ìµœê·¼ 8ë²ˆì˜ íƒ­ë§Œ ìœ ì§€
                if (tapTimes.length > 8) {
                    tapTimes.shift();
                }

                if (tapTimes.length >= 2) {
                    // íƒ­ ê°„ê²©ì˜ í‰ê·  ê³„ì‚°
                    const intervals = [];
                    for (let i = 1; i < tapTimes.length; i++) {
                        intervals.push(tapTimes[i] - tapTimes[i - 1]);
                    }
                    const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                    const bpm = 60000 / avgInterval;  // ms to BPM

                    document.getElementById('bpm-input').value = bpm.toFixed(1);
                    console.log(`ğŸµ Tap BPM: ${bpm.toFixed(1)} (${tapTimes.length} taps)`);
                }

                // 5ì´ˆ ì´ìƒ íƒ­ ì•ˆ í•˜ë©´ ë¦¬ì…‹
                setTimeout(() => {
                    const lastTap = tapTimes[tapTimes.length - 1];
                    if (Date.now() - lastTap > 5000) {
                        tapTimes = [];
                        console.log('Tap BPM reset');
                    }
                }, 5000);
            });

            // Mark Beat ê¸°ëŠ¥ (1ë°• ìœ„ì¹˜ í‘œì‹œ)
            document.getElementById('mark-beat-btn').addEventListener('click', () => {
                if (editorState.isPlaying) {
                    const currentTime = editorState.currentTime;
                    document.getElementById('offset-input').value = currentTime.toFixed(3);
                    editorState.offset = currentTime;
                    regenerateNotes();
                    console.log(`âœï¸ Marked beat at ${currentTime.toFixed(3)}s as offset`);
                } else {
                    alert('ì¬ìƒ ì¤‘ì— 1ë°•ì—ì„œ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”!');
                }
            });

            document.getElementById('difficulty-select').addEventListener('change', (e) => {
                editorState.difficulty = e.target.value;

                // ë‚œì´ë„ì— ë”°ë¼ ë ˆì¸ ë³€ê²½
                LANES = DIFFICULTY_LANES[editorState.difficulty];
                console.log(`ğŸ® ë‚œì´ë„ ë³€ê²½: ${editorState.difficulty} (ë ˆì¸ ìˆ˜: ${LANES.length})`);

                // ë ˆì¸ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                if (gameContainer) {
                    gameContainer.removeChildren();
                    drawLanes();
                    drawJudgmentLine();
                }

                // í™”ë©´ í¬ê¸° ì¬ê³„ì‚°
                calculateDimensions();

                if (editorState.audioBuffer) {
                    regenerateNotes();
                }
            });

            // Toggle Onset Visualization
            document.getElementById('toggle-onset-btn').addEventListener('click', () => {
                editorState.showOnsets = !editorState.showOnsets;
                const btn = document.getElementById('toggle-onset-btn');
                if (editorState.showOnsets) {
                    btn.textContent = 'ğŸ‘ï¸ Onset ON';
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-success');
                    console.log('ğŸ” Onset visualization enabled');
                } else {
                    btn.textContent = 'ğŸ‘ï¸ Onset';
                    btn.classList.remove('btn-success');
                    btn.classList.add('btn-primary');
                    console.log('ğŸ” Onset visualization disabled');
                }
            });

            // Toggle Edit Mode
            document.getElementById('edit-mode-btn').addEventListener('click', toggleEditMode);

            // Delete Selected Notes
            document.getElementById('delete-note-btn').addEventListener('click', deleteSelectedNotes);

            // Toggle Long Note Mode
            document.getElementById('long-note-mode-btn').addEventListener('click', toggleLongNoteMode);

            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
        }

        function handleKeyDown(e) {
            const activeElement = document.activeElement;
            const isTyping = activeElement.tagName === 'INPUT';

            if (!isTyping) {
                // í¸ì§‘ ëª¨ë“œì—ì„œ ì„ íƒëœ ë…¸íŠ¸ í¸ì§‘
                if (editorState.editMode && editorState.selectedNotes.size > 0) {
                    // Delete/Backspace: ì„ íƒëœ ë…¸íŠ¸ ì‚­ì œ
                    if (e.code === 'Delete' || e.code === 'Backspace') {
                        e.preventDefault();
                        deleteSelectedNotes();
                        return;
                    }

                    // ë ˆì¸ ë³€ê²½: D(0), F(1), Space(2), J(3), K(4)
                    const laneMap = { 'KeyD': 0, 'KeyF': 1, 'Space': 2, 'KeyJ': 3, 'KeyK': 4 };
                    if (laneMap.hasOwnProperty(e.code)) {
                        e.preventDefault();
                        moveSelectedNotesToLane(laneMap[e.code]);
                        return;
                    }

                    // íƒ€ì´ë° ë¯¸ì„¸ ì¡°ì •: ArrowLeft (ì•ìœ¼ë¡œ), ArrowRight (ë’¤ë¡œ)
                    if (e.code === 'ArrowLeft') {
                        e.preventDefault();
                        adjustSelectedNotesTiming(-0.01);  // 10ms ì•ìœ¼ë¡œ
                        return;
                    }
                    if (e.code === 'ArrowRight') {
                        e.preventDefault();
                        adjustSelectedNotesTiming(0.01);  // 10ms ë’¤ë¡œ
                        return;
                    }

                    // Escape: ì„ íƒ í•´ì œ
                    if (e.code === 'Escape') {
                        e.preventDefault();
                        editorState.selectedNotes.clear();
                        console.log('âœ… ëª¨ë“  ë…¸íŠ¸ ì„ íƒ í•´ì œ');
                        return;
                    }
                }

                // ì¼ë°˜ ëª¨ë“œ ë‹¨ì¶•í‚¤
                if (e.code === 'Space') {
                    e.preventDefault();
                    togglePlayback();
                    return;
                }

                if (e.code === 'Delete' || e.code === 'Backspace') {
                    e.preventDefault();
                    deleteLastNote();
                    return;
                }

                const lane = LANES.find(l => l.key === e.code);
                if (lane && editorState.isPlaying) {
                    e.preventDefault();
                    const time = editorState.currentTime;

                    if (editorState.longNoteMode) {
                        // ë¡± ë…¸íŠ¸ ëª¨ë“œ: í‚¤ë¥¼ ëˆ„ë¥´ë©´ ì‹œì‘ ì‹œê°„ ê¸°ë¡
                        if (!editorState.activeLongNotes[lane.index]) {
                            // ìƒˆ ë¡± ë…¸íŠ¸ ì‹œì‘
                            const noteIndex = editorState.notes.length;
                            const note = {
                                time: parseFloat(time.toFixed(3)),
                                endTime: null,  // keyupì—ì„œ ì„¤ì •ë¨
                                lane: lane.index,
                                type: 'long'
                            };
                            editorState.notes.push(note);
                            editorState.activeLongNotes[lane.index] = {
                                startTime: time,
                                noteIndex: noteIndex
                            };
                            console.log(`ğŸµ ë¡± ë…¸íŠ¸ ì‹œì‘: Lane ${lane.index}, Time ${time.toFixed(3)}s`);
                        }
                    } else {
                        // ì¼ë°˜ ë…¸íŠ¸ ëª¨ë“œ
                        addNote(lane.index, time);
                        showKeyFlash(lane.index);
                    }
                }

                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    saveChart();
                }

                // E: í¸ì§‘ ëª¨ë“œ í† ê¸€
                if (e.code === 'KeyE') {
                    e.preventDefault();
                    toggleEditMode();
                }
            }
        }

        function handleKeyUp(e) {
            const activeElement = document.activeElement;
            const isTyping = activeElement.tagName === 'INPUT';

            if (!isTyping && editorState.longNoteMode && editorState.isPlaying) {
                const lane = LANES.find(l => l.key === e.code);
                if (lane && editorState.activeLongNotes[lane.index]) {
                    e.preventDefault();
                    const endTime = editorState.currentTime;
                    const longNoteData = editorState.activeLongNotes[lane.index];
                    const noteIndex = longNoteData.noteIndex;
                    const note = editorState.notes[noteIndex];

                    // ë¡± ë…¸íŠ¸ ì™„ì„±
                    const duration = endTime - longNoteData.startTime;

                    // ìµœì†Œ ê¸¸ì´ ê²€ì¦ (0.1ì´ˆ ë¯¸ë§Œì´ë©´ ì¼ë°˜ ë…¸íŠ¸ë¡œ ë³€í™˜)
                    if (duration < 0.1) {
                        console.log(`âš ï¸ ë¡± ë…¸íŠ¸ê°€ ë„ˆë¬´ ì§§ìŒ (${(duration * 1000).toFixed(0)}ms) â†’ ì¼ë°˜ ë…¸íŠ¸ë¡œ ë³€í™˜`);
                        note.type = 'normal';
                        delete note.endTime;
                    } else {
                        note.endTime = parseFloat(endTime.toFixed(3));
                        console.log(`âœ… ë¡± ë…¸íŠ¸ ì™„ì„±: Lane ${lane.index}, ${longNoteData.startTime.toFixed(3)}s ~ ${endTime.toFixed(3)}s (${(duration * 1000).toFixed(0)}ms)`);
                    }

                    // í™œì„± ë¡± ë…¸íŠ¸ ì œê±°
                    delete editorState.activeLongNotes[lane.index];

                    // ë…¸íŠ¸ ì¬ì •ë ¬
                    editorState.notes.sort((a, b) => a.time - b.time);
                    updateStats();
                }
            }
        }

        async function loadAndAnalyzeAudio(file) {
            try {
                showLoading('ìŒì› ë¡œë”© ì¤‘...', 'ì˜¤ë””ì˜¤ ë””ì½”ë”©');

                if (!editorState.audioContext) {
                    editorState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                const arrayBuffer = await file.arrayBuffer();
                editorState.audioBuffer = await editorState.audioContext.decodeAudioData(arrayBuffer);
                editorState.duration = editorState.audioBuffer.duration;
                editorState.longNotesConverted = false;  // ìƒˆ ìŒì› ë¡œë“œ ì‹œ í”Œë˜ê·¸ ì´ˆê¸°í™”

                showLoading('BPM ë¶„ì„ ì¤‘...', 'í…œí¬ ë° ë¹„íŠ¸ ê°ì§€');

                // BPM ë° ì²« ë¹„íŠ¸ ì˜¤í”„ì…‹ ìë™ ê°ì§€
                const { bpm: detectedBPM, offset: detectedOffset, onsets, onsetTimes, bassOnsets, kickOnsets, snareOnsets, hihatOnsets, melodyOnsets, musicStructure } = await detectBPMAndOffset(editorState.audioBuffer);
                editorState.bpm = detectedBPM;
                editorState.offset = detectedOffset;
                editorState.onsets = onsets;
                editorState.onsetTimes = onsetTimes;
                editorState.bassOnsets = bassOnsets;   // Task #3
                editorState.kickOnsets = kickOnsets;
                editorState.snareOnsets = snareOnsets;
                editorState.hihatOnsets = hihatOnsets;
                editorState.melodyOnsets = melodyOnsets; // Task #1
                editorState.musicStructure = musicStructure; // Task #2

                document.getElementById('bpm-input').value = detectedBPM.toFixed(1);
                document.getElementById('offset-input').value = detectedOffset.toFixed(3);
                document.getElementById('detected-bpm').textContent = detectedBPM.toFixed(1);

                showLoading('ë…¸íŠ¸ ìƒì„± ì¤‘...', 'ë‚œì´ë„: ' + editorState.difficulty);

                // ë‚œì´ë„ì— ë”°ë¼ ë ˆì¸ ì„¤ì •
                LANES = DIFFICULTY_LANES[editorState.difficulty];
                console.log(`ğŸ® ë ˆì¸ ì„¤ì •: ${editorState.difficulty} (${LANES.length} lanes)`);

                // ë ˆì¸ ë‹¤ì‹œ ê·¸ë¦¬ê¸° (í•„ìš”ì‹œ)
                if (gameContainer) {
                    gameContainer.removeChildren();
                    drawLanes();
                    drawJudgmentLine();
                }

                calculateDimensions();

                // ìë™ ë…¸íŠ¸ ìƒì„±
                generateNotes();

                hideLoading();

                document.getElementById('status').textContent = 'ì¤€ë¹„ ì™„ë£Œ!';
                document.getElementById('play-btn').disabled = false;
                document.getElementById('stop-btn').disabled = false;
                document.getElementById('regen-btn').disabled = false;
                document.getElementById('save-btn').disabled = false;
                document.getElementById('load-chart-btn').disabled = false;
                document.getElementById('edit-mode-btn').disabled = false;
                document.getElementById('override-bpm-btn').disabled = false;
                document.getElementById('offset-minus-btn').disabled = false;
                document.getElementById('offset-plus-btn').disabled = false;
                document.getElementById('tap-bpm-btn').disabled = false;
                document.getElementById('mark-beat-btn').disabled = false;
                document.getElementById('toggle-onset-btn').disabled = false;
                document.getElementById('long-note-mode-btn').disabled = false;

                alert(`âœ¨ ë¶„ì„ ì™„ë£Œ!\n\nBPM: ${detectedBPM.toFixed(1)}\nOffset: ${detectedOffset.toFixed(3)}s\në…¸íŠ¸: ${editorState.notes.length}ê°œ\në‚œì´ë„: ${editorState.difficulty}\n\nì¬ìƒ ë²„íŠ¼ì„ ëˆŒëŸ¬ í™•ì¸í•˜ì„¸ìš”!\nâ€» ë°•ìê°€ ì•ˆë§ìœ¼ë©´ BPMì´ë‚˜ Offsetì„ ìˆ˜ë™ ì¡°ì •í•˜ì„¸ìš”.`);

            } catch (error) {
                hideLoading();
                console.error('Error:', error);
                alert('ì˜¤ë””ì˜¤ ë¡œë“œ ì‹¤íŒ¨: ' + error.message);
            }
        }

        // BPM ë° ì²« ë¹„íŠ¸ ì˜¤í”„ì…‹ ìë™ ê°ì§€ + FFT ê¸°ë°˜ ì£¼íŒŒìˆ˜ ë¶„ì„
        async function detectBPMAndOffset(audioBuffer) {
            const sampleRate = audioBuffer.sampleRate;
            const channelData = audioBuffer.getChannelData(0);

            console.log('Starting advanced BPM detection with FFT analysis...');

            // 1. FFT ê¸°ë°˜ Onset Strength Envelope ê³„ì‚°
            const fftSize = 2048;  // FFT window size (power of 2)
            const hopSize = Math.floor(fftSize / 2); // 50% overlap

            // ì „ì²´ onset + ì£¼íŒŒìˆ˜ ëŒ€ì—­ë³„ onset + ë©œë¡œë”” ì •ë³´
            const onsetStrengths = [];
            const onsetTimes = [];
            const bassOnsets = [];      // ë² ì´ìŠ¤ ë¼ì¸ (40-100Hz) - Task #3
            const kickOnsets = [];      // í‚¥ë“œëŸ¼ (100-150Hz) - Task #3
            const snareOnsets = [];     // ìŠ¤ë„¤ì–´ (150-4000Hz)
            const hihatOnsets = [];     // í•˜ì´í–‡ (4000-12000Hz)
            const melodyStrengths = []; // ë©œë¡œë”” (200-2000Hz, spectral flux) - Task #1

            console.log(`Using simplified frequency band analysis with bass separation (Task #3)`);

            // ì´ì „ ìŠ¤í™íŠ¸ëŸ¼ ì €ì¥ (Spectral Flux ê³„ì‚°ìš©)
            let prevSpectrum = null;

            // ê° windowë§ˆë‹¤ ê°„ì†Œí™”ëœ ì£¼íŒŒìˆ˜ ëŒ€ì—­ ë¶„ì„ ìˆ˜í–‰
            // (ì „ì²´ DFT ëŒ€ì‹  í•„ìš”í•œ ì£¼íŒŒìˆ˜ ëŒ€ì—­ë§Œ ê³„ì‚° - í›¨ì”¬ ë¹ ë¦„)
            for (let i = 0; i < channelData.length - fftSize; i += hopSize) {
                const time = i / sampleRate;

                // í˜„ì¬ window ì¶”ì¶œ ë° RMS ê¸°ë°˜ ëŒ€ì—­ë³„ ì—ë„ˆì§€ ê³„ì‚°
                let bassEnergy = 0;   // Task #3: Bass line (very low freq)
                let kickEnergy = 0;   // Task #3: Kick drum (low freq)
                let snareEnergy = 0;
                let hihatEnergy = 0;
                let melodyEnergy = 0;
                let zeroCrossings = 0; // Zero-crossing rate for melody pitch detection
                let prevSample = 0;

                // Task #3: ê°„ì†Œí™”ëœ í•„í„°ë±…í¬ ë°©ì‹ - Bassì™€ Kick ë¶„ë¦¬ + Zero-Crossing for melody
                for (let j = 0; j < fftSize; j++) {
                    const sample = channelData[i + j];
                    const sampleSq = sample * sample;

                    // Zero-crossing detection (ë©œë¡œë”” pitch ë³€í™” ê°ì§€)
                    if (j > 0 && prevSample * sample < 0) {
                        zeroCrossings++;
                    }
                    prevSample = sample;

                    // Task #3: ì´ˆì €ì£¼íŒŒ ì—ë„ˆì§€ (Bass line: ì•ìª½ 1/16)
                    if (j < fftSize / 16) {
                        bassEnergy += sampleSq;
                    }
                    // Task #3: ì €ì£¼íŒŒ ì—ë„ˆì§€ (Kick: 1/16 ~ 1/8)
                    else if (j < fftSize / 8) {
                        kickEnergy += sampleSq;
                    }
                    // ì¤‘ì£¼íŒŒ ì—ë„ˆì§€ (Snare/Melody: 1/8 ~ 1/2)
                    else if (j < fftSize / 2) {
                        snareEnergy += sampleSq;
                        melodyEnergy += sampleSq * 2.0; // ë©œë¡œë”” ëŒ€ì—­
                    }
                    // ê³ ì£¼íŒŒ ì—ë„ˆì§€ (Hihat: ë‚˜ë¨¸ì§€)
                    else {
                        hihatEnergy += sampleSq;
                    }
                }

                // Zero-crossing rateë¥¼ ë©œë¡œë”” ì—ë„ˆì§€ì— ë°˜ì˜
                // ë†’ì€ ZCR = ë†’ì€ ì£¼íŒŒìˆ˜ = ë©œë¡œë””/ë³´ì»¬ ê°€ëŠ¥ì„± ë†’ìŒ
                const zcr = zeroCrossings / fftSize;
                if (zcr > 0.1 && zcr < 0.4) {  // ë©œë¡œë”” ë²”ìœ„ì˜ ZCR (ë„ˆë¬´ ë‚®ìœ¼ë©´ Bass, ë„ˆë¬´ ë†’ìœ¼ë©´ ë…¸ì´ì¦ˆ)
                    melodyEnergy *= (1 + zcr * 5); // ZCRì— ë¹„ë¡€í•´ì„œ ë©œë¡œë”” ì—ë„ˆì§€ ì¦í­
                }

                // Normalize by window size
                bassEnergy = Math.sqrt(bassEnergy / fftSize);   // Task #3
                kickEnergy = Math.sqrt(kickEnergy / fftSize);   // Task #3
                snareEnergy = Math.sqrt(snareEnergy / fftSize);
                hihatEnergy = Math.sqrt(hihatEnergy / fftSize);
                melodyEnergy = Math.sqrt(melodyEnergy / fftSize);

                // Onset detection: ì´ì „ í”„ë ˆì„ê³¼ì˜ ì°¨ì´ ê³„ì‚°
                let onset = 0;
                let bassOnset = 0;   // Task #3
                let kickOnset = 0;
                let snareOnset = 0;
                let hihatOnset = 0;
                let melodyOnset = 0;

                if (prevSpectrum !== null) {
                    // Energy difference (positive only)
                    const totalEnergy = bassEnergy + kickEnergy + snareEnergy + hihatEnergy + melodyEnergy;
                    const prevTotalEnergy = prevSpectrum[0] + prevSpectrum[1] + prevSpectrum[2] + prevSpectrum[3] + prevSpectrum[4];

                    onset = Math.max(0, totalEnergy - prevTotalEnergy);
                    bassOnset = Math.max(0, bassEnergy - prevSpectrum[0]); // Task #3
                    kickOnset = Math.max(0, kickEnergy - prevSpectrum[1]); // Task #3
                    snareOnset = Math.max(0, snareEnergy - prevSpectrum[2]);
                    hihatOnset = Math.max(0, hihatEnergy - prevSpectrum[3]);

                    // Task #1: ë©œë¡œë”” onset - ì—ë„ˆì§€ ë³€í™”ê°€ ì¶©ë¶„íˆ í´ ë•Œë§Œ
                    const melodyDiff = melodyEnergy - prevSpectrum[4];
                    if (melodyDiff > prevSpectrum[4] * 0.2) {  // ì´ì „ ëŒ€ë¹„ 20% ì´ìƒ ì¦ê°€
                        melodyOnset = melodyDiff;
                    } else {
                        melodyOnset = 0;  // ì‘ì€ ë³€í™”ëŠ” ë¬´ì‹œ
                    }
                }

                onsetStrengths.push(onset);
                bassOnsets.push(bassOnset);   // Task #3
                kickOnsets.push(kickOnset);
                snareOnsets.push(snareOnset);
                hihatOnsets.push(hihatOnset);
                melodyStrengths.push(melodyOnset); // Task #1
                onsetTimes.push(time);

                // Store current energies for next iteration (Task #3: 5 bands now)
                prevSpectrum = [bassEnergy, kickEnergy, snareEnergy, hihatEnergy, melodyEnergy];
            }

            // 2. Normalize onset strengths
            const maxOnset = Math.max(...onsetStrengths);
            const maxBass = Math.max(...bassOnsets);   // Task #3
            const maxKick = Math.max(...kickOnsets);
            const maxSnare = Math.max(...snareOnsets);
            const maxHihat = Math.max(...hihatOnsets);
            const maxMelody = Math.max(...melodyStrengths);

            const normalizedOnsets = onsetStrengths.map(o => o / maxOnset);
            const normalizedBass = bassOnsets.map(o => o / maxBass);   // Task #3
            const normalizedKick = kickOnsets.map(o => o / maxKick);
            const normalizedSnare = snareOnsets.map(o => o / maxSnare);
            const normalizedHihat = hihatOnsets.map(o => o / maxHihat);
            const normalizedMelody = melodyStrengths.map(o => o / maxMelody); // Task #1

            // Calculate onset statistics
            const strongOnsets = normalizedOnsets.filter(o => o > 0.3).length;
            const bassCount = normalizedBass.filter(o => o > 0.3).length;   // Task #3
            const kickCount = normalizedKick.filter(o => o > 0.3).length;
            const snareCount = normalizedSnare.filter(o => o > 0.3).length;
            const hihatCount = normalizedHihat.filter(o => o > 0.3).length;
            const melodyCount = normalizedMelody.filter(o => o > 0.3).length; // Task #1

            console.log(`Calculated ${normalizedOnsets.length} onset frames`);
            console.log(`Strong onsets (>0.3): ${strongOnsets}`);
            console.log(`Frequency bands - Bass: ${bassCount}, Kick: ${kickCount}, Snare: ${snareCount}, Hihat: ${hihatCount}, Melody: ${melodyCount}`);

            // 3. Autocorrelation for tempo detection
            const minBPM = 60;
            const maxBPM = 200;
            const minInterval = Math.floor((60 / maxBPM) / (hopSize / sampleRate));
            const maxInterval = Math.floor((60 / minBPM) / (hopSize / sampleRate));

            let bestCorr = 0;
            let bestLag = 0;

            // Calculate autocorrelation with normalization
            for (let lag = minInterval; lag <= maxInterval; lag++) {
                let corr = 0;
                let norm = 0;

                for (let i = 0; i < normalizedOnsets.length - lag; i++) {
                    corr += normalizedOnsets[i] * normalizedOnsets[i + lag];
                    norm += normalizedOnsets[i] * normalizedOnsets[i];
                }

                // Normalize correlation
                if (norm > 0) {
                    corr = corr / Math.sqrt(norm);
                }

                if (corr > bestCorr) {
                    bestCorr = corr;
                    bestLag = lag;
                }
            }

            // 4. Calculate BPM from best lag
            const beatInterval = bestLag * (hopSize / sampleRate);
            let detectedBPM = 60 / beatInterval;

            console.log(`Raw BPM: ${detectedBPM.toFixed(1)}, Correlation: ${bestCorr.toFixed(3)}`);

            // 5. BPM adjustment (handle octave errors)
            // Try multiples and divisions to find the most musical tempo
            const candidates = [detectedBPM, detectedBPM * 2, detectedBPM / 2, detectedBPM * 3, detectedBPM / 3];
            let finalBPM = detectedBPM;

            for (const candidate of candidates) {
                if (candidate >= 80 && candidate <= 180) {
                    finalBPM = candidate;
                    break;
                }
            }

            // Round to nearest 0.5
            finalBPM = Math.round(finalBPM * 2) / 2;

            console.log(`Final BPM: ${finalBPM}`);

            // 6. First beat offset detection (improved)
            // Find the first ANY onset (ìŒì•…ì˜ ì‹¤ì œ ì‹œì‘ì ) - not just strong ones!
            const threshold = 0.1; // 10% of max (ì•½í•œ ë¹„íŠ¸ë„ ê°ì§€)
            let firstBeatIndex = -1;

            for (let i = 0; i < normalizedOnsets.length; i++) {
                if (normalizedOnsets[i] > threshold) {
                    firstBeatIndex = i;
                    break;
                }
            }

            const firstBeatTime = firstBeatIndex !== -1 ? onsetTimes[firstBeatIndex] : 0;

            // Align to beat grid
            const beatDuration = 60 / finalBPM;

            // IMPORTANT: BPM ê·¸ë¦¬ë“œì— ë§ì¶°ì„œ offset ê³„ì‚°
            // firstBeatTimeì„ ê°€ì¥ ê°€ê¹Œìš´ ë°•ìì— ì •ë ¬
            const beatPosition = Math.round(firstBeatTime / beatDuration);
            let offset = beatPosition * beatDuration;

            // í•˜ì§€ë§Œ ìŒì•…ì´ ì•„ì˜ˆ ì²˜ìŒë¶€í„° ì‹œì‘í•œë‹¤ë©´ offset = 0
            if (firstBeatTime < beatDuration * 2) {
                offset = 0;
                console.log(`First beat at ${firstBeatTime.toFixed(3)}s (very early), setting offset to 0`);
            } else {
                console.log(`First beat at ${firstBeatTime.toFixed(3)}s, aligned offset: ${offset.toFixed(3)}s`);
            }

            // ì²« 4ë§ˆë””ì˜ ê°•í•œ ë¹„íŠ¸ë“¤ì„ ì¶œë ¥í•´ì„œ í™•ì¸
            console.log('First 4 measures strong beats:');
            for (let i = 0; i < Math.min(16, normalizedOnsets.length); i++) {
                if (normalizedOnsets[i] > 0.4) {
                    const beatPos = (onsetTimes[i] - offset) / beatDuration;
                    console.log(`  ${onsetTimes[i].toFixed(2)}s (beat ${beatPos.toFixed(2)}) - strength ${normalizedOnsets[i].toFixed(2)}`);
                }
            }

            // 7. Music Structure Recognition (Task #2)
            // ì—ë„ˆì§€ ë³€í™”ë¥¼ ë¶„ì„í•´ì„œ ê³¡ì˜ êµ¬ì¡°(Intro/Verse/Chorus)ë¥¼ ê°ì§€
            const musicStructure = detectMusicStructure(normalizedOnsets, onsetTimes, audioBuffer.duration, finalBPM);
            console.log(`Detected ${musicStructure.length} music sections`);

            return {
                bpm: finalBPM,
                offset: offset,
                confidence: bestCorr,
                onsets: normalizedOnsets,      // Overall onset strengths
                onsetTimes: onsetTimes,
                bassOnsets: normalizedBass,    // Bass line onsets (40-100Hz) - Task #3
                kickOnsets: normalizedKick,    // Kick drum onsets (100-150Hz) - Task #3
                snareOnsets: normalizedSnare,  // Snare drum onsets (150-4000Hz)
                hihatOnsets: normalizedHihat,  // Hi-hat onsets (4000-12000Hz)
                melodyOnsets: normalizedMelody, // Melody onsets (200-2000Hz) - Task #1
                musicStructure: musicStructure  // Music structure sections - Task #2
            };
        }

        // Task #2: Music Structure Detection
        // ì—ë„ˆì§€ ë ˆë²¨ ë³€í™”ë¥¼ ë¶„ì„í•˜ì—¬ ê³¡ì˜ êµ¬ì¡°(Intro/Verse/Chorus/Bridge/Outro)ë¥¼ ê°ì§€
        function detectMusicStructure(onsets, onsetTimes, duration, bpm) {
            const sections = [];

            // ì—ë„ˆì§€ë¥¼ ì¼ì • ì‹œê°„ ë‹¨ìœ„ë¡œ í‰ê· ë‚´ì„œ ë¶„ì„ (4ë§ˆë”” = 16ë°•ì ë‹¨ìœ„)
            const beatDuration = 60 / bpm;
            const sectionDuration = beatDuration * 16; // 4ë§ˆë””
            const numSections = Math.ceil(duration / sectionDuration);

            console.log(`Analyzing music structure: ${numSections} sections (${sectionDuration.toFixed(1)}s each)`);

            // ê° ì„¹ì…˜ì˜ í‰ê·  ì—ë„ˆì§€ ê³„ì‚°
            const sectionEnergies = [];
            for (let i = 0; i < numSections; i++) {
                const startTime = i * sectionDuration;
                const endTime = Math.min((i + 1) * sectionDuration, duration);

                // ì´ ì‹œê°„ ë²”ìœ„ì˜ onsetë“¤ì˜ í‰ê·  ì—ë„ˆì§€
                const sectionOnsets = onsets.filter((_, idx) => {
                    const t = onsetTimes[idx];
                    return t >= startTime && t < endTime;
                });

                const avgEnergy = sectionOnsets.length > 0
                    ? sectionOnsets.reduce((sum, o) => sum + o, 0) / sectionOnsets.length
                    : 0;

                sectionEnergies.push(avgEnergy);
            }

            // ì „ì²´ ê³¡ì˜ í‰ê· /ìµœëŒ€ ì—ë„ˆì§€
            const avgEnergy = sectionEnergies.reduce((sum, e) => sum + e, 0) / sectionEnergies.length;
            const maxEnergy = Math.max(...sectionEnergies);

            console.log(`Energy stats - Avg: ${avgEnergy.toFixed(3)}, Max: ${maxEnergy.toFixed(3)}`);

            // ê° ì„¹ì…˜ì„ ë¶„ë¥˜
            for (let i = 0; i < numSections; i++) {
                const startTime = i * sectionDuration;
                const endTime = Math.min((i + 1) * sectionDuration, duration);
                const energy = sectionEnergies[i];
                const energyRatio = energy / avgEnergy;

                let sectionType = 'Verse';
                let densityMultiplier = 1.0;

                // ì—ë„ˆì§€ ë ˆë²¨ë¡œ ì„¹ì…˜ íƒ€ì… íŒë‹¨ (ë””ì œì´ë§¥ìŠ¤ ìŠ¤íƒ€ì¼ ë°€ë„)
                if (i === 0 && energyRatio < 0.7) {
                    // ì²« ì„¹ì…˜ì´ ë‚®ì€ ì—ë„ˆì§€ â†’ Intro
                    sectionType = 'Intro';
                    densityMultiplier = 0.4; // ë…¸íŠ¸ ë°€ë„ 40% (ë” ë‚®ì¶¤)
                } else if (i === numSections - 1 && energyRatio < 0.7) {
                    // ë§ˆì§€ë§‰ ì„¹ì…˜ì´ ë‚®ì€ ì—ë„ˆì§€ â†’ Outro
                    sectionType = 'Outro';
                    densityMultiplier = 0.5; // ë…¸íŠ¸ ë°€ë„ 50% (ë” ë‚®ì¶¤)
                } else if (energyRatio > 1.3) {
                    // í‰ê· ë³´ë‹¤ 30% ë†’ì€ ì—ë„ˆì§€ â†’ Chorus (ì ˆì •)
                    sectionType = 'Chorus';
                    densityMultiplier = 1.3; // ë…¸íŠ¸ ë°€ë„ 130% (ì¤„ì„)
                } else if (energyRatio > 1.1) {
                    // í‰ê· ë³´ë‹¤ 10% ë†’ì€ ì—ë„ˆì§€ â†’ Pre-Chorus
                    sectionType = 'Pre-Chorus';
                    densityMultiplier = 1.1; // ë…¸íŠ¸ ë°€ë„ 110% (ì¤„ì„)
                } else if (energyRatio < 0.8) {
                    // í‰ê· ë³´ë‹¤ ë‚®ì€ ì—ë„ˆì§€ â†’ Break/Bridge
                    sectionType = 'Break';
                    densityMultiplier = 0.6; // ë…¸íŠ¸ ë°€ë„ 60% (ë” ë‚®ì¶¤)
                } else {
                    // í‰ê·  ì—ë„ˆì§€ â†’ Verse
                    sectionType = 'Verse';
                    densityMultiplier = 1.0; // ë…¸íŠ¸ ë°€ë„ 100%
                }

                sections.push({
                    startTime: startTime,
                    endTime: endTime,
                    type: sectionType,
                    energy: energy,
                    densityMultiplier: densityMultiplier
                });

                console.log(`Section ${i}: ${startTime.toFixed(1)}-${endTime.toFixed(1)}s | ${sectionType} | Energy: ${energy.toFixed(3)} (${(energyRatio * 100).toFixed(0)}%) | Density: ${(densityMultiplier * 100).toFixed(0)}%`);
            }

            return sections;
        }

        // 5ë ˆì¸ ê¸°ì¤€ ë ˆì¸ì„ ë‚œì´ë„ë³„ ë ˆì¸ìœ¼ë¡œ ë§¤í•‘
        function mapLaneToDifficulty(lane5, difficulty) {
            // lane5: 0(D), 1(F), 2(Space), 3(J), 4(K)

            if (difficulty === 'Easy') {
                // Easy: 3ë ˆì¸ (D, Space, K)
                // 5ë ˆì¸ â†’ 3ë ˆì¸ ë§¤í•‘
                if (lane5 === 0 || lane5 === 1) return 0;  // D, F â†’ D
                if (lane5 === 2) return 1;                  // Space â†’ Space
                if (lane5 === 3 || lane5 === 4) return 2;  // J, K â†’ K
            } else if (difficulty === 'Normal') {
                // Normal: 4ë ˆì¸ (D, F, J, K) - Space ì œì™¸
                if (lane5 === 0) return 0;  // D â†’ D
                if (lane5 === 1) return 1;  // F â†’ F
                if (lane5 === 2) return -1; // SpaceëŠ” ì‚¬ìš© ì•ˆ í•¨ (ìŠ¤í‚µ)
                if (lane5 === 3) return 2;  // J â†’ J
                if (lane5 === 4) return 3;  // K â†’ K
            } else {
                // Hard, Expert: 5ë ˆì¸ (ê·¸ëŒ€ë¡œ)
                return lane5;
            }

            return -1; // ë§¤í•‘ ì‹¤íŒ¨
        }

        // ì—°ì†ëœ ë…¸íŠ¸ë¥¼ ë¡±ë…¸íŠ¸ë¡œ ë³‘í•© (ëª¨ë“  ì—°ì† ë…¸íŠ¸ ë³€í™˜)
        function convertToLongNotes() {
            if (editorState.notes.length === 0) return 0;
            if (editorState.longNotesConverted) {
                console.log(`â­ï¸ Skipping convertToLongNotes (already converted)`);
                return 0;
            }

            const MIN_CONSECUTIVE_NOTES = 2;
            const MIN_LONG_NOTE_DURATION = 0.1;
            const MAX_GAP = 0.5;  // 0.5ì´ˆ (BPM 85 ê¸°ì¤€ ì•½ 1/4ë°•ì)

            console.log(`ğŸ” Long note conversion settings:`);
            console.log(`   - Min consecutive notes: ${MIN_CONSECUTIVE_NOTES}`);
            console.log(`   - Min duration: ${MIN_LONG_NOTE_DURATION}s`);
            console.log(`   - Max gap: ${MAX_GAP}s`);

            // ì‹œê°„ìˆœ ì •ë ¬ (ì•ˆì „ì„±)
            editorState.notes.sort((a, b) => a.time - b.time);

            // ë ˆì¸ë³„ë¡œ ë…¸íŠ¸ ê·¸ë£¹í™”
            const notesByLane = {};
            for (let i = 0; i < LANES.length; i++) {
                notesByLane[i] = [];
            }

            editorState.notes.forEach((note, index) => {
                notesByLane[note.lane].push({ note, originalIndex: index });
            });

            const longNoteCandidates = [];

            // ê° ë ˆì¸ì—ì„œ ì—°ì†ëœ ë…¸íŠ¸ ì°¾ê¸°
            for (let lane = 0; lane < LANES.length; lane++) {
                const laneNotes = notesByLane[lane];

                if (laneNotes.length < MIN_CONSECUTIVE_NOTES) continue;

                let i = 0;
                let sequenceCount = 0;
                while (i < laneNotes.length) {
                    const sequence = [laneNotes[i]];
                    let j = i + 1;

                    // ì—°ì†ëœ ë…¸íŠ¸ ì°¾ê¸° (ê°„ê²© <= MAX_GAP)
                    while (j < laneNotes.length) {
                        const gap = laneNotes[j].note.time - laneNotes[j - 1].note.time;
                        if (gap <= MAX_GAP) {
                            sequence.push(laneNotes[j]);
                            j++;
                        } else {
                            break;
                        }
                    }

                    // MIN_CONSECUTIVE_NOTESê°œ ì´ìƒ ì—°ì† && ì „ì²´ ê¸¸ì´ê°€ MIN_LONG_NOTE_DURATION ì´ìƒ
                    if (sequence.length >= MIN_CONSECUTIVE_NOTES) {
                        const startTime = sequence[0].note.time;
                        const endTime = sequence[sequence.length - 1].note.time;
                        const duration = endTime - startTime;

                        if (duration >= MIN_LONG_NOTE_DURATION) {
                            longNoteCandidates.push({
                                lane: lane,
                                sequence: sequence,
                                startTime: startTime,
                                endTime: endTime,
                                duration: duration,
                                noteCount: sequence.length
                            });
                            sequenceCount++;
                        }
                    }

                    i = j;
                }
            }

            // ëª¨ë“  ì—°ì† ë…¸íŠ¸ë¥¼ ë¡±ë…¸íŠ¸ë¡œ ë³€í™˜ (ë¹„ìœ¨ ì œí•œ ì—†ìŒ)
            let convertedCount = 0;

            console.log(`ğŸ¯ Long note candidates: ${longNoteCandidates.length} (converting ALL)`);

            const notesToRemove = new Set();  // ì‚­ì œí•  ë…¸íŠ¸ë“¤ (ì¤‘ë³µ ë°©ì§€)

            for (const candidate of longNoteCandidates) {
                // ì´ë¯¸ ë¡±ë…¸íŠ¸ë¡œ ë³€í™˜ëœ ë…¸íŠ¸ê°€ í¬í•¨ë˜ì–´ ìˆìœ¼ë©´ ìŠ¤í‚µ
                const alreadyConverted = candidate.sequence.some(item => item.note.type === 'long' || notesToRemove.has(item.note));
                if (alreadyConverted) continue;

                // ì‹œì‘ ë…¸íŠ¸ë¥¼ ë¡±ë…¸íŠ¸ë¡œ ë³€í™˜
                const startNote = candidate.sequence[0].note;
                startNote.type = 'long';
                startNote.endTime = candidate.endTime;

                // ì¤‘ê°„ ë…¸íŠ¸ë“¤ì„ ì‚­ì œ ëŒ€ìƒìœ¼ë¡œ ë§ˆí‚¹
                for (let i = 1; i < candidate.sequence.length; i++) {
                    notesToRemove.add(candidate.sequence[i].note);
                }

                convertedCount++;
            }

            // ì‚­ì œ ëŒ€ìƒ ë…¸íŠ¸ë“¤ ì œê±°
            const beforeRemoval = editorState.notes.length;
            editorState.notes = editorState.notes.filter(note => !notesToRemove.has(note));
            const afterRemoval = editorState.notes.length;
            const removed = beforeRemoval - afterRemoval;

            console.log(`ğŸµ Long note conversion complete:`);
            console.log(`   - Converted: ${convertedCount} long notes`);
            console.log(`   - Removed: ${removed} merged notes`);
            console.log(`   - Total notes: ${editorState.notes.length} (${editorState.notes.filter(n => n.type === 'long').length} long, ${editorState.notes.filter(n => n.type === 'normal').length} normal)`);

            return convertedCount;
        }

        // ì¼ë°˜ ë…¸íŠ¸ Graphics ê·¸ë¦¬ê¸° (í•œ ë²ˆë§Œ)
        function drawNormalNote(noteSprite, laneColor, isSelected) {
            const NOTE_HEIGHT = 20;
            const noteWidth = LANE_WIDTH - 10;
            const alpha = isSelected ? 1.0 : 0.9;

            noteSprite.clear();
            noteSprite.roundRect(0, 0, noteWidth, NOTE_HEIGHT, 8);
            noteSprite.fill({ color: laneColor, alpha: alpha });
            noteSprite.roundRect(0, 0, noteWidth, NOTE_HEIGHT, 8);

            const strokeColor = isSelected ? 0xFFFF00 : 0xFFFFFF;
            const strokeWidth = isSelected ? 4 : 2;
            noteSprite.stroke({ color: strokeColor, width: strokeWidth, alpha: isSelected ? 1.0 : 0.5 });
        }

        // ëª¨ë“  ë…¸íŠ¸ ìŠ¤í”„ë¼ì´íŠ¸ ë¯¸ë¦¬ ìƒì„± + ì¼ë°˜ ë…¸íŠ¸ ê·¸ë¦¬ê¸° (pop-in ë°©ì§€)
        function preCreateAllNoteSprites() {
            if (!notesContainer) {
                console.warn('âš ï¸ notesContainer not initialized yet');
                return;
            }

            console.log(`ğŸ¨ Pre-creating ${editorState.notes.length} note sprites...`);

            editorState.notes.forEach((note, index) => {
                if (!note.sprite) {
                    const noteSprite = new PIXI.Graphics();
                    note.sprite = noteSprite;
                    noteSprite.visible = false; // ì²˜ìŒì—” ìˆ¨ê¹€
                    notesContainer.addChild(noteSprite);

                    // ì¼ë°˜ ë…¸íŠ¸ëŠ” ë¯¸ë¦¬ ê·¸ë¦¬ê¸° (ë¡±ë…¸íŠ¸ëŠ” ë§¤ í”„ë ˆì„ ì—…ë°ì´íŠ¸)
                    const isLongNote = note.type === 'long' && note.endTime;
                    if (!isLongNote) {
                        const laneColor = LANES[note.lane].color;
                        const isSelected = editorState.selectedNotes.has(index);
                        drawNormalNote(noteSprite, laneColor, isSelected);
                    }

                    // í¸ì§‘ ëª¨ë“œ ì´ë²¤íŠ¸ ì„¤ì •ì€ toggleEditModeì—ì„œ ì²˜ë¦¬
                    // ì—¬ê¸°ì„œëŠ” ìŠ¤í”„ë¼ì´íŠ¸ë§Œ ìƒì„±
                }
            });

            console.log(`âœ… Pre-created ${editorState.notes.length} sprites`);
        }

        function generateNotes() {
            // ê¸°ì¡´ ìŠ¤í”„ë¼ì´íŠ¸ ì •ë¦¬
            editorState.notes.forEach(note => {
                if (note.sprite) {
                    note.sprite.destroy();
                    note.sprite = null;
                }
            });

            editorState.notes = [];

            const beatDuration = 60 / editorState.bpm;
            const numLanes = LANES.length;

            console.log(`ğŸ¯ Pure Onset-Based Generation: BPM ${editorState.bpm}, Lanes: ${numLanes}`);
            console.log(`âš ï¸ í™•ë¥  ì—†ìŒ! Onsetë§Œ ë³´ê³  1:1 ë…¸íŠ¸ ìƒì„±`);

            // ë‚œì´ë„ë³„ Onset threshold ì„¤ì •
            const difficultySettings = {
                'Easy': {
                    threshold: 0.30,  // ê°•í•œ ë¹„íŠ¸ë§Œ
                    description: 'ê°•í•œ ë¹„íŠ¸ë§Œ'
                },
                'Normal': {
                    threshold: 0.20,  // ì¤‘ê°„ ë¹„íŠ¸
                    description: 'ì¤‘ê°„ ë¹„íŠ¸'
                },
                'Hard': {
                    threshold: 0.15,  // ì•½í•œ ë¹„íŠ¸ê¹Œì§€
                    description: 'ì•½í•œ ë¹„íŠ¸ê¹Œì§€'
                },
                'Expert': {
                    threshold: 0.10,  // ë§¤ìš° ì•½í•œ ë¹„íŠ¸ê¹Œì§€
                    description: 'ë§¤ìš° ì•½í•œ ë¹„íŠ¸ê¹Œì§€'
                }
            };

            const settings = difficultySettings[editorState.difficulty];
            console.log(`Difficulty: ${editorState.difficulty} (${numLanes} lanes) - ${settings.description}, Threshold: ${settings.threshold}`);

            if (!editorState.onsets || editorState.onsets.length === 0) {
                console.error('No onset data available!');
                alert('Onset ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ìŒì›ì„ ë‹¤ì‹œ ë¡œë“œí•˜ì„¸ìš”.');
                return;
            }

            // 5ë ˆì¸ ê¸°ì¤€ìœ¼ë¡œ ìƒì„± í›„ ë‚œì´ë„ë³„ ë§¤í•‘
            let processedOnsets = 0;
            let skippedWeak = 0;
            let skippedDuplicate = 0;

            // 5ë ˆì¸ ê¸°ì¤€ ë ˆì¸ íŠ¸ë˜ì»¤
            let lastLane = 0;
            let lastLeftLane = 0;   // D/F êµëŒ€ìš©
            let lastRightLane = 3;  // J/K êµëŒ€ìš©

            console.log(`Processing ${editorState.onsets.length} onsets...`);

            // Onset ì§ì ‘ ìˆœíšŒ
            for (let i = 0; i < editorState.onsets.length; i++) {
                const onsetStrength = editorState.onsets[i];
                const onsetTime = editorState.onsetTimes[i];

                processedOnsets++;

                // 1. Threshold ì²´í¬ (ë‚œì´ë„ë³„)
                if (onsetStrength < settings.threshold) {
                    skippedWeak++;
                    continue;
                }

                // 2. ìŒì› ë²”ìœ„ ì²´í¬
                if (onsetTime < 0 || onsetTime > editorState.duration) {
                    continue;
                }

                // 3. BPM ê·¸ë¦¬ë“œì— ìŠ¤ëƒ… (ê°€ì¥ ê°€ê¹Œìš´ 1/16ë°•)
                const beatPosition = (onsetTime - editorState.offset) / beatDuration;
                const snapDivisor = 16;
                const snappedBeat = Math.round(beatPosition * snapDivisor) / snapDivisor;
                const snappedTime = snappedBeat * beatDuration + editorState.offset;

                // 4. ìœ íš¨ ë²”ìœ„ ì¬í™•ì¸
                if (snappedTime < 0 || snappedTime > editorState.duration) {
                    continue;
                }

                // 5. ì¤‘ë³µ ë°©ì§€ (50ms ì´ë‚´)
                const isDuplicate = editorState.notes.some(note =>
                    Math.abs(note.time - snappedTime) < 0.05
                );
                if (isDuplicate) {
                    skippedDuplicate++;
                    continue;
                }

                // 6. 5ë ˆì¸ ê¸°ì¤€ìœ¼ë¡œ ë ˆì¸ ê²°ì •
                let lane5 = 0;  // 5ë ˆì¸ ê¸°ì¤€ (0-4)
                const kickStrength = editorState.kickOnsets[i] || 0;
                const snareStrength = editorState.snareOnsets[i] || 0;
                const hihatStrength = editorState.hihatOnsets[i] || 0;
                const maxDrumStrength = Math.max(kickStrength, snareStrength, hihatStrength);

                let isLeftHand = (lastLane === 0 || lastLane === 1);

                if (kickStrength === maxDrumStrength && kickStrength > 0.15) {
                    // Kick â†’ ì™¼ì† êµëŒ€ (Dâ†”F)
                    lane5 = (lastLeftLane === 0) ? 1 : 0;
                    lastLeftLane = lane5;
                } else if (snareStrength === maxDrumStrength && snareStrength > 0.15) {
                    // Snare â†’ ì˜¤ë¥¸ì† êµëŒ€ (Jâ†”K)
                    lane5 = (lastRightLane === 3) ? 4 : 3;
                    lastRightLane = lane5;
                } else if (hihatStrength === maxDrumStrength && hihatStrength > 0.15) {
                    // Hi-hat â†’ ì˜¤ë¥¸ì† êµëŒ€ (Jâ†”K)
                    lane5 = (lastRightLane === 3) ? 4 : 3;
                    lastRightLane = lane5;
                } else {
                    // ë“œëŸ¼ì´ ëª…í™•í•˜ì§€ ì•Šìœ¼ë©´ ì¢Œìš° êµëŒ€
                    if (isLeftHand) {
                        lane5 = (lastRightLane === 3) ? 4 : 3;
                        lastRightLane = lane5;
                    } else {
                        lane5 = (lastLeftLane === 0) ? 1 : 0;
                        lastLeftLane = lane5;
                    }
                }

                lastLane = lane5;

                // 7. ë‚œì´ë„ë³„ ë ˆì¸ìœ¼ë¡œ ë§¤í•‘
                let finalLane = mapLaneToDifficulty(lane5, editorState.difficulty);

                // ë§¤í•‘ ì‹¤íŒ¨ ì‹œ ìŠ¤í‚µ (í•´ë‹¹ ë‚œì´ë„ì—ì„œ ì‚¬ìš© ì•ˆ í•˜ëŠ” ë ˆì¸)
                if (finalLane === -1) {
                    continue;
                }

                // 8. ë…¸íŠ¸ ì¶”ê°€
                editorState.notes.push({
                    time: parseFloat(snappedTime.toFixed(3)),
                    lane: finalLane,
                    type: 'normal'  // ì¼ë‹¨ normalë¡œ ìƒì„± (ë‚˜ì¤‘ì— ë¡±ë…¸íŠ¸ë¡œ ë³‘í•©)
                });
            }

            editorState.notes.sort((a, b) => a.time - b.time);

            console.log(`âœ… Generated ${editorState.notes.length} notes (before long note conversion)`);

            // 9. ë¡±ë…¸íŠ¸ ìë™ ìƒì„± (í•œ ë²ˆë§Œ ì‹¤í–‰, ì¤‘ë³µ ì°¨ë‹¨)
            if (!editorState.longNotesConverted) {
                convertToLongNotes();
                editorState.longNotesConverted = true;
                console.log(`ğŸ”’ Long note conversion locked`);
            }
            const longNotesAfter = editorState.notes.filter(n => n.type === 'long').length;

            // 10. ëª¨ë“  ë…¸íŠ¸ ìŠ¤í”„ë¼ì´íŠ¸ ë¯¸ë¦¬ ìƒì„± (pop-in ë°©ì§€)
            preCreateAllNoteSprites();

            console.log(`ğŸ“Š Stats:`);
            console.log(`   - Processed onsets: ${processedOnsets}`);
            console.log(`   - Created notes: ${editorState.notes.length}`);
            console.log(`   - Normal notes: ${editorState.notes.filter(n => n.type === 'normal').length}`);
            console.log(`   - Long notes: ${longNotesAfter}`);
            console.log(`   - Skipped (too weak): ${skippedWeak}`);
            console.log(`   - Skipped (duplicate): ${skippedDuplicate}`);

            if (editorState.notes.length > 0) {
                const firstNote = editorState.notes[0];
                const lastNote = editorState.notes[editorState.notes.length - 1];
                console.log(`â±ï¸ First: ${firstNote.time.toFixed(3)}s, Last: ${lastNote.time.toFixed(3)}s`);

                // ë ˆì¸ ë¶„í¬ í†µê³„ (í˜„ì¬ ë‚œì´ë„ ê¸°ì¤€)
                const laneCounts = new Array(LANES.length).fill(0);
                editorState.notes.forEach(note => {
                    if (note.lane >= 0 && note.lane < LANES.length) {
                        laneCounts[note.lane]++;
                    }
                });
                const totalNotes = editorState.notes.length;
                console.log(`ğŸ¹ Lane distribution (${editorState.difficulty}, ${LANES.length} lanes):`);
                LANES.forEach((lane, index) => {
                    const count = laneCounts[index];
                    const percentage = totalNotes > 0 ? (count/totalNotes*100).toFixed(1) : '0.0';
                    console.log(`   ${lane.label}(${index}): ${count} (${percentage}%)`);
                });

                // NPS (Notes Per Second) ê³„ì‚°
                const nps = (editorState.notes.length / editorState.duration).toFixed(2);
                console.log(`ğŸ“ˆ Average NPS: ${nps}`);
            }

            updateStats();
        }

        function regenerateNotes() {
            if (!editorState.audioBuffer) {
                alert('ë¨¼ì € ìŒì›ì„ ë¡œë“œí•˜ì„¸ìš”.');
                return;
            }

            if (confirm('ë…¸íŠ¸ë¥¼ ë‹¤ì‹œ ìƒì„±í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                editorState.longNotesConverted = false;  // ì¬ìƒì„± ì‹œ í”Œë˜ê·¸ ì´ˆê¸°í™”
                generateNotes();
                alert(`ğŸ”„ ì¬ìƒì„± ì™„ë£Œ!\n\në…¸íŠ¸: ${editorState.notes.length}ê°œ\në‚œì´ë„: ${editorState.difficulty}`);
            }
        }

        async function initEditor() {
            calculateDimensions();

            app = new PIXI.Application();
            await app.init({
                width: GAME_WIDTH,
                height: GAME_HEIGHT,
                backgroundColor: 0x0a0a0a,
                antialias: true,
                resolution: window.devicePixelRatio || 1
            });

            document.getElementById('editor-canvas').appendChild(app.canvas);

            gameContainer = new PIXI.Container();
            gridContainer = new PIXI.Container();
            beatGridContainer = new PIXI.Container();
            onsetMarkersContainer = new PIXI.Container();
            notesContainer = new PIXI.Container();

            app.stage.addChild(gameContainer);
            app.stage.addChild(gridContainer);
            app.stage.addChild(beatGridContainer);
            app.stage.addChild(onsetMarkersContainer);
            app.stage.addChild(notesContainer);

            drawLanes();
            drawJudgmentLine();

            app.ticker.add(editorLoop);

            window.addEventListener('resize', () => {
                calculateDimensions();
                if (app) {
                    app.renderer.resize(GAME_WIDTH, GAME_HEIGHT);
                    gameContainer.removeChildren();
                    gridContainer.removeChildren();
                    drawLanes();
                    drawJudgmentLine();
                }
            });
        }

        function drawLanes() {
            for (let i = 0; i < LANES.length; i++) {
                const lane = new PIXI.Graphics();

                lane.rect(i * LANE_WIDTH, 0, LANE_WIDTH, GAME_HEIGHT / 2);
                lane.fill({ color: 0x16213e, alpha: 0.2 });

                lane.rect(i * LANE_WIDTH, GAME_HEIGHT / 2, LANE_WIDTH, GAME_HEIGHT / 2);
                lane.fill({ color: 0x16213e, alpha: 0.4 });

                lane.moveTo(i * LANE_WIDTH, 0);
                lane.lineTo(i * LANE_WIDTH, GAME_HEIGHT);
                lane.stroke({ color: LANES[i].color, width: 2, alpha: 0.5 });

                gameContainer.addChild(lane);

                const keyText = new PIXI.Text({
                    text: LANES[i].label,
                    style: {
                        fontSize: 28,
                        fill: LANES[i].color,
                        fontWeight: 'bold',
                        fontFamily: 'Orbitron'
                    }
                });
                keyText.anchor.set(0.5);
                keyText.x = i * LANE_WIDTH + LANE_WIDTH / 2;
                keyText.y = GAME_HEIGHT - 30;
                gameContainer.addChild(keyText);
            }
        }

        function drawJudgmentLine() {
            const line = new PIXI.Graphics();
            line.moveTo(0, JUDGMENT_LINE_Y);
            line.lineTo(GAME_WIDTH, JUDGMENT_LINE_Y);
            line.stroke({ color: 0xFFFFFF, width: 4 });

            const glow = new PIXI.Graphics();
            glow.moveTo(0, JUDGMENT_LINE_Y);
            glow.lineTo(GAME_WIDTH, JUDGMENT_LINE_Y);
            glow.stroke({ color: 0xFFFFFF, width: 20, alpha: 0.2 });

            gameContainer.addChild(glow);
            gameContainer.addChild(line);
        }

        function addNote(laneIndex, time) {
            const note = {
                time: parseFloat(time.toFixed(3)),
                lane: laneIndex,
                type: 'normal'  // ì¼ë°˜ ë…¸íŠ¸
            };

            editorState.notes.push(note);
            editorState.notes.sort((a, b) => a.time - b.time);
            updateStats();
        }

        function deleteLastNote() {
            if (editorState.notes.length > 0) {
                editorState.notes.pop();
                updateStats();
            }
        }

        function showKeyFlash(laneIndex) {
            const flash = new PIXI.Graphics();
            flash.rect(laneIndex * LANE_WIDTH, JUDGMENT_LINE_Y - 50, LANE_WIDTH, 100);
            flash.fill({ color: LANES[laneIndex].color, alpha: 0.6 });
            gameContainer.addChild(flash);

            setTimeout(() => {
                gameContainer.removeChild(flash);
            }, 100);
        }

        function togglePlayback() {
            if (editorState.isPlaying) {
                pausePlayback();
            } else {
                startPlayback();
            }
        }

        function startPlayback() {
            if (!editorState.audioBuffer) {
                alert('ë¨¼ì € ìŒì›ì„ ë¡œë“œí•˜ì„¸ìš”.');
                return;
            }

            console.log(`â–¶ Start playback - currentTime before: ${editorState.currentTime}`);

            if (editorState.audioSource) {
                editorState.audioSource.stop();
            }

            editorState.audioSource = editorState.audioContext.createBufferSource();
            editorState.audioSource.buffer = editorState.audioBuffer;
            editorState.audioSource.connect(editorState.audioContext.destination);

            const offset = editorState.currentTime || 0;
            editorState.audioSource.start(0, offset);
            editorState.startTime = editorState.audioContext.currentTime - offset;
            editorState.isPlaying = true;

            document.getElementById('status').textContent = 'ì¬ìƒ ì¤‘';
            document.getElementById('play-btn').textContent = 'â¸ ì¼ì‹œì •ì§€';

            console.log(`â–¶ Playing from: ${offset.toFixed(2)}s, startTime: ${editorState.startTime.toFixed(2)}, audioContext.currentTime: ${editorState.audioContext.currentTime.toFixed(2)}`);

            editorState.audioSource.onended = () => {
                stopPlayback();
            };
        }

        function pausePlayback() {
            // í˜„ì¬ ì¬ìƒ ì‹œê°„ ì €ì¥ (audioSource.stop() ì „ì— ì €ì¥í•´ì•¼ í•¨)
            if (editorState.audioContext && editorState.startTime !== undefined) {
                const pausedTime = editorState.audioContext.currentTime - editorState.startTime;
                editorState.currentTime = Math.max(0, pausedTime); // ìŒìˆ˜ ë°©ì§€
                console.log(`â¸ Pausing at: ${editorState.currentTime.toFixed(2)}s (audioContext: ${editorState.audioContext.currentTime.toFixed(2)}, startTime: ${editorState.startTime.toFixed(2)})`);
            }

            if (editorState.audioSource) {
                // onended ì½œë°±ì„ ì œê±°í•˜ì—¬ stopPlayback()ì´ í˜¸ì¶œë˜ì§€ ì•Šë„ë¡ í•¨
                editorState.audioSource.onended = null;
                editorState.audioSource.stop();
                editorState.audioSource = null;
            }

            editorState.isPlaying = false;
            document.getElementById('status').textContent = 'ì¼ì‹œì •ì§€';
            document.getElementById('play-btn').textContent = 'â–¶ ì¬ìƒ';

            console.log(`â¸ Paused, currentTime saved: ${editorState.currentTime.toFixed(2)}s`);
        }

        function stopPlayback() {
            if (editorState.audioSource) {
                editorState.audioSource.stop();
                editorState.audioSource = null;
            }
            editorState.isPlaying = false;
            editorState.currentTime = 0;
            document.getElementById('status').textContent = 'ì •ì§€';
            document.getElementById('play-btn').textContent = 'â–¶ ì¬ìƒ';
        }

        function editorLoop(ticker) {
            // ì¬ìƒ ì¤‘ì¼ ë•Œë§Œ currentTime ì—…ë°ì´íŠ¸
            if (editorState.isPlaying && editorState.audioContext) {
                editorState.currentTime = editorState.audioContext.currentTime - editorState.startTime;
            }

            // ì‹œê°„ í‘œì‹œëŠ” í•­ìƒ ì—…ë°ì´íŠ¸ (ì¼ì‹œì •ì§€ ì‹œì—ë„ í‘œì‹œ)
            document.getElementById('current-time').textContent = editorState.currentTime.toFixed(2) + 's';

            if (editorState.bpm > 0) {
                const currentBeat = Math.floor((editorState.currentTime - editorState.offset) / (60 / editorState.bpm)) + 1;
                document.getElementById('current-beat').textContent = currentBeat;
            }

            // Draw beat grid lines
            beatGridContainer.removeChildren();
            if (editorState.bpm > 0) {
                const beatDuration = 60 / editorState.bpm;
                const NOTE_SPEED = 200;

                // Draw beat lines within visible range
                const visibleTime = GAME_HEIGHT / NOTE_SPEED;
                const startBeat = Math.floor((editorState.currentTime - editorState.offset) / beatDuration);
                const endBeat = Math.ceil((editorState.currentTime + visibleTime - editorState.offset) / beatDuration);

                for (let beat = startBeat; beat <= endBeat; beat++) {
                    const beatTime = beat * beatDuration + editorState.offset;
                    const timeDiff = beatTime - editorState.currentTime;
                    const lineY = JUDGMENT_LINE_Y - timeDiff * NOTE_SPEED;

                    if (lineY > -10 && lineY < GAME_HEIGHT + 10) {
                        const line = new PIXI.Graphics();

                        // Different colors for different beat types
                        if (beat % 4 === 0) {
                            // Measure line (white, thick)
                            line.moveTo(0, lineY);
                            line.lineTo(GAME_WIDTH, lineY);
                            line.stroke({ color: 0xFFFFFF, width: 2, alpha: 0.4 });
                        } else {
                            // Regular beat line (gray, thin)
                            line.moveTo(0, lineY);
                            line.lineTo(GAME_WIDTH, lineY);
                            line.stroke({ color: 0x888888, width: 1, alpha: 0.2 });
                        }

                        beatGridContainer.addChild(line);
                    }
                }
            }

            // Draw onset markers if enabled
            onsetMarkersContainer.removeChildren();
            if (editorState.showOnsets && editorState.onsets && editorState.onsets.length > 0) {
                const NOTE_SPEED = 200;
                const visibleTime = GAME_HEIGHT / NOTE_SPEED;

                // Get difficulty threshold to show which onsets become notes
                const difficultyThresholds = {
                    'Easy': 0.6,
                    'Normal': 0.45,
                    'Hard': 0.35,
                    'Expert': 0.25
                };
                const threshold = difficultyThresholds[editorState.difficulty] || 0.35;

                for (let i = 0; i < editorState.onsets.length; i++) {
                    const onsetTime = editorState.onsetTimes[i];
                    const onsetStrength = editorState.onsets[i];
                    const timeDiff = onsetTime - editorState.currentTime;

                    // Only draw onsets in visible range
                    if (Math.abs(timeDiff) > visibleTime) continue;

                    const lineY = JUDGMENT_LINE_Y - timeDiff * NOTE_SPEED;

                    if (lineY > -10 && lineY < GAME_HEIGHT + 10) {
                        const line = new PIXI.Graphics();

                        // Color based on onset strength
                        let color, alpha, width;
                        if (onsetStrength >= threshold) {
                            // Strong onset (becomes a note) - bright cyan
                            color = 0x00FFFF;
                            alpha = 0.8;
                            width = 3;
                        } else if (onsetStrength >= threshold * 0.7) {
                            // Medium onset - yellow
                            color = 0xFFFF00;
                            alpha = 0.5;
                            width = 2;
                        } else if (onsetStrength >= threshold * 0.4) {
                            // Weak onset - orange
                            color = 0xFFA500;
                            alpha = 0.3;
                            width = 1;
                        } else {
                            // Very weak - skip to reduce clutter
                            continue;
                        }

                        line.moveTo(0, lineY);
                        line.lineTo(GAME_WIDTH, lineY);
                        line.stroke({ color: color, width: width, alpha: alpha });

                        // Add drum type indicator on the right
                        if (onsetStrength >= threshold) {
                            const kickStrength = editorState.kickOnsets[i] || 0;
                            const snareStrength = editorState.snareOnsets[i] || 0;
                            const hihatStrength = editorState.hihatOnsets[i] || 0;
                            const maxDrumStrength = Math.max(kickStrength, snareStrength, hihatStrength);

                            let drumIndicator = '';
                            let indicatorColor = 0xFFFFFF;
                            if (kickStrength === maxDrumStrength && maxDrumStrength > 0.2) {
                                drumIndicator = 'K';
                                indicatorColor = 0xFF6B6B;
                            } else if (snareStrength === maxDrumStrength && maxDrumStrength > 0.2) {
                                drumIndicator = 'S';
                                indicatorColor = 0x4ECDC4;
                            } else if (hihatStrength === maxDrumStrength && maxDrumStrength > 0.2) {
                                drumIndicator = 'H';
                                indicatorColor = 0xFFE66D;
                            }

                            if (drumIndicator) {
                                const text = new PIXI.Text({
                                    text: drumIndicator,
                                    style: {
                                        fontSize: 12,
                                        fill: indicatorColor,
                                        fontWeight: 'bold',
                                        fontFamily: 'Orbitron'
                                    }
                                });
                                text.anchor.set(0, 0.5);
                                text.x = GAME_WIDTH - 20;
                                text.y = lineY;
                                onsetMarkersContainer.addChild(text);
                            }
                        }

                        onsetMarkersContainer.addChild(line);
                    }
                }
            }

            // ìŠ¤í”„ë¼ì´íŠ¸ ì¬ì‚¬ìš© ìµœì í™”: ë§¤ í”„ë ˆì„ ì¬ìƒì„± ëŒ€ì‹  ìœ„ì¹˜ë§Œ ì—…ë°ì´íŠ¸
            const NOTE_HEIGHT = 20;
            const NOTE_SPEED = 200;

            // í™”ë©´ì— ë³´ì¼ ë…¸íŠ¸ë§Œ ë Œë”ë§ (ì„±ëŠ¥ ìµœì í™”)
            const viewportMargin = GAME_HEIGHT * 0.5;  // í™”ë©´ ë†’ì´ì˜ 50% ì—¬ìœ  (ì¶©ë¶„í•œ ì‚¬ì „ ë¡œë”©)
            const minTime = editorState.currentTime - (GAME_HEIGHT + viewportMargin) / NOTE_SPEED;
            const maxTime = editorState.currentTime + viewportMargin / NOTE_SPEED;

            for (let i = 0; i < editorState.notes.length; i++) {
                const note = editorState.notes[i];

                // ë¹ ë¥¸ ì»¬ë§: ì‹œê°„ ë²”ìœ„ ì²´í¬
                const isLongNote = note.type === 'long' && note.endTime;
                const isActiveLongNote = note.type === 'long' && !note.endTime;
                const endTime = isLongNote ? note.endTime : note.time;

                // ë…¸íŠ¸ê°€ í™”ë©´ ë²”ìœ„ ë°–ì´ë©´ ìˆ¨ê¹€
                const isInViewport = !(endTime < minTime || note.time > maxTime);

                const timeDiff = note.time - editorState.currentTime;
                const noteY = JUDGMENT_LINE_Y - timeDiff * NOTE_SPEED;

                // ë¡± ë…¸íŠ¸ì˜ ê²½ìš° ë ì§€ì  ê³„ì‚°
                let endNoteY = noteY;
                if (isLongNote) {
                    const endTimeDiff = note.endTime - editorState.currentTime;
                    endNoteY = JUDGMENT_LINE_Y - endTimeDiff * NOTE_SPEED;
                } else if (isActiveLongNote) {
                    endNoteY = JUDGMENT_LINE_Y;
                }

                // ìŠ¤í”„ë¼ì´íŠ¸ ì¬ì‚¬ìš© (ì´ë¯¸ preCreateAllNoteSpritesì—ì„œ ìƒì„±ë¨)
                let noteSprite = note.sprite;

                if (!noteSprite) {
                    // ë§Œì•½ ìŠ¤í”„ë¼ì´íŠ¸ê°€ ì—†ë‹¤ë©´ (ìˆ˜ë™ ì¶”ê°€ ë…¸íŠ¸ ë“±) ì¦‰ì„ ìƒì„±
                    noteSprite = new PIXI.Graphics();
                    note.sprite = noteSprite;
                    notesContainer.addChild(noteSprite);
                }

                // Visible ì†ì„±ìœ¼ë¡œ culling
                noteSprite.visible = isInViewport;

                if (!isInViewport) continue; // ì•ˆë³´ì´ë©´ ì—…ë°ì´íŠ¸ ìŠ¤í‚µ

                let noteColor = LANES[note.lane].color;
                const isSelected = editorState.selectedNotes.has(i);

                if (isLongNote || isActiveLongNote) {
                    // ë¡±ë…¸íŠ¸: ê¸¸ì´ê°€ ë³€í•˜ë¯€ë¡œ ë§¤ í”„ë ˆì„ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                    noteSprite.clear();
                    // ë¡± ë…¸íŠ¸: ìµœì í™”ëœ ì‹¬í”Œ ë””ìì¸
                    const longNoteHeight = Math.abs(noteY - endNoteY);
                    const longNoteY = Math.min(noteY, endNoteY);
                    const noteWidth = LANE_WIDTH - 10;

                    // 1. ë³¸ì²´ (ë‹¨ìƒ‰)
                    noteSprite.roundRect(0, 0, noteWidth, longNoteHeight, 6);
                    noteSprite.fill({ color: noteColor, alpha: 0.5 });

                    // 2. ì™¸ê³½ í…Œë‘ë¦¬
                    noteSprite.roundRect(0, 0, noteWidth, longNoteHeight, 6);
                    const strokeColor = isSelected ? 0xFFFF00 : (isActiveLongNote ? 0x00FF00 : 0xFFFFFF);
                    noteSprite.stroke({ color: strokeColor, width: 4, alpha: 1.0 });

                    // 3. í—¤ë“œ (ì‹œì‘ ë¶€ë¶„)
                    const headHeight = NOTE_HEIGHT * 1.5;
                    noteSprite.roundRect(0, 0, noteWidth, headHeight, 6);
                    noteSprite.fill({ color: noteColor, alpha: 1.0 });
                    noteSprite.roundRect(0, 0, noteWidth, headHeight, 6);
                    noteSprite.stroke({ color: 0xFFFFFF, width: 2, alpha: 1.0 });

                    // 4. í…Œì¼ (ë ë¶€ë¶„)
                    if (isLongNote) {
                        const tailHeight = NOTE_HEIGHT * 1.5;
                        noteSprite.roundRect(0, longNoteHeight - tailHeight, noteWidth, tailHeight, 6);
                        noteSprite.fill({ color: noteColor, alpha: 1.0 });
                        noteSprite.roundRect(0, longNoteHeight - tailHeight, noteWidth, tailHeight, 6);
                        noteSprite.stroke({ color: 0xFFFFFF, width: 2, alpha: 1.0 });
                    }

                    noteSprite.x = note.lane * LANE_WIDTH + 5;
                    noteSprite.y = longNoteY;
                } else {
                    // ì¼ë°˜ ë…¸íŠ¸: ì„ íƒ ìƒíƒœê°€ ë³€ê²½ë˜ì—ˆìœ¼ë©´ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                    if (isSelected !== noteSprite.wasSelected) {
                        drawNormalNote(noteSprite, noteColor, isSelected);
                        noteSprite.wasSelected = isSelected;
                    }
                    // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                    noteSprite.x = note.lane * LANE_WIDTH + 5;
                    noteSprite.y = noteY - NOTE_HEIGHT / 2;
                }
            }

            updateMinimap();
        }

        function updateStats() {
            const normalNotes = editorState.notes.filter(n => n.type === 'normal' || !n.type).length;
            const longNotes = editorState.notes.filter(n => n.type === 'long').length;
            const totalNotes = editorState.notes.length;

            document.getElementById('note-count').textContent = totalNotes;

            if (editorState.duration > 0) {
                const nps = (totalNotes / editorState.duration).toFixed(1);
                document.getElementById('nps-display').textContent = nps;
            }

            // ì½˜ì†”ì— ë¡±ë…¸íŠ¸ í†µê³„ ì¶œë ¥
            if (longNotes > 0) {
                const longNoteRatio = ((longNotes / totalNotes) * 100).toFixed(1);
                console.log(`ğŸ“Š Stats: Total ${totalNotes} notes (Normal: ${normalNotes}, Long: ${longNotes}, ${longNoteRatio}%)`);
            }

            updateDensityGraph();
        }

        function updateDensityGraph() {
            const canvas = document.getElementById('density-graph');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (editorState.duration === 0 || editorState.notes.length === 0) return;

            const windowSize = 1;
            const windows = Math.ceil(editorState.duration / windowSize);
            const densities = [];

            for (let i = 0; i < windows; i++) {
                const start = i * windowSize;
                const end = (i + 1) * windowSize;
                const count = editorState.notes.filter(n => n.time >= start && n.time < end).length;
                densities.push(count);
            }

            const maxDensity = Math.max(...densities, 1);

            ctx.fillStyle = '#667eea';
            densities.forEach((density, i) => {
                const x = (i / windows) * canvas.width;
                const width = canvas.width / windows;
                const height = (density / maxDensity) * canvas.height;
                const y = canvas.height - height;

                ctx.fillRect(x, y, width, height);
            });

            if (editorState.duration > 0) {
                const x = (editorState.currentTime / editorState.duration) * canvas.width;
                ctx.strokeStyle = '#FF6B6B';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
        }

        function updateMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (editorState.duration === 0) return;

            editorState.notes.forEach(note => {
                const x = (note.time / editorState.duration) * canvas.width;
                const y = (note.lane / LANES.length) * canvas.height;
                const width = Math.max(2, canvas.width / 100);
                const height = canvas.height / LANES.length;

                let color = `#${LANES[note.lane].color.toString(16).padStart(6, '0')}`;

                ctx.fillStyle = color;
                ctx.fillRect(x, y, width, height);
            });

            const x = (editorState.currentTime / editorState.duration) * canvas.width;
            ctx.strokeStyle = '#FF6B6B';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }

        function saveChart() {
            const title = editorState.title || 'Untitled';
            const bpm = editorState.bpm;
            const difficulty = editorState.difficulty;

            // ë…¸íŠ¸ ë°ì´í„° ì •ë¦¬ (sprite ì†ì„± ì œì™¸)
            const cleanNotes = editorState.notes.map(note => ({
                time: note.time,
                lane: note.lane,
                type: note.type,
                endTime: note.endTime  // ë¡±ë…¸íŠ¸ìš©
            }));

            const chartData = {
                title,
                bpm,
                offset: editorState.offset,
                difficulty,
                duration: editorState.duration,
                lanes: LANES.length,
                notes: cleanNotes,  // sprite ì œì™¸ëœ ê¹¨ë—í•œ ë°ì´í„°
                audioFileName: editorState.audioFileName,  // ì˜¤ë””ì˜¤ íŒŒì¼ ì´ë¦„ ì €ì¥
                metadata: {
                    nps: (editorState.notes.length / editorState.duration).toFixed(2),
                    noteCount: editorState.notes.length,
                    createdAt: new Date().toISOString(),
                    editor: 'BEAT MASTER Auto'
                }
            };

            const dataStr = JSON.stringify(chartData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);

            const link = document.createElement('a');
            link.href = url;
            link.download = `${title.replace(/[^a-z0-9]/gi, '_')}_${difficulty}_chart.json`;
            link.click();

            URL.revokeObjectURL(url);
            alert('ì°¨íŠ¸ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
        }

        function loadChart() {
            const input = document.getElementById('load-chart-input');
            const file = input.files[0];

            if (!file) {
                alert('íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const chartData = JSON.parse(e.target.result);

                    // ê¸°ì¡´ ìŠ¤í”„ë¼ì´íŠ¸ ì •ë¦¬
                    editorState.notes.forEach(note => {
                        if (note.sprite) {
                            note.sprite.destroy();
                            note.sprite = null;
                        }
                    });

                    // ì°¨íŠ¸ ë°ì´í„° ë¡œë“œ
                    editorState.notes = chartData.notes || [];

                    // í•˜ìœ„ í˜¸í™˜ì„±: typeì´ ì—†ëŠ” ë…¸íŠ¸ëŠ” 'normal'ë¡œ ì„¤ì •
                    editorState.notes.forEach(note => {
                        if (!note.type) {
                            note.type = 'normal';
                        }
                    });

                    editorState.longNotesConverted = true;  // ì°¨íŠ¸ ë¡œë“œ ì‹œ ì´ë¯¸ ë³€í™˜ëœ ê²ƒìœ¼ë¡œ ê°„ì£¼

                    editorState.bpm = chartData.bpm || 120;
                    editorState.offset = chartData.offset || 0;
                    editorState.title = chartData.title || 'Untitled';
                    editorState.difficulty = chartData.difficulty || 'Hard';
                    editorState.duration = chartData.duration || 0;
                    editorState.audioFileName = chartData.audioFileName || '';

                    // ë‚œì´ë„ì— ë”°ë¼ ë ˆì¸ ì—…ë°ì´íŠ¸
                    LANES = DIFFICULTY_LANES[editorState.difficulty];
                    console.log(`ğŸ“‚ ì°¨íŠ¸ ë¡œë“œ: ${editorState.difficulty} (ë ˆì¸ ìˆ˜: ${LANES.length})`);

                    // UI ì—…ë°ì´íŠ¸
                    document.getElementById('bpm-input').value = editorState.bpm;
                    document.getElementById('offset-input').value = editorState.offset;
                    document.getElementById('title-input').value = editorState.title;
                    document.getElementById('difficulty-select').value = editorState.difficulty;

                    // ë ˆì¸ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                    if (gameContainer) {
                        gameContainer.removeChildren();
                        drawLanes();
                        drawJudgmentLine();
                    }

                    calculateDimensions();

                    // ë…¸íŠ¸ ì¬ë Œë”ë§
                    updateStats();

                    // ì˜¤ë””ì˜¤ê°€ ë¡œë“œë˜ì–´ ìˆìœ¼ë©´ í™”ë©´ ì—…ë°ì´íŠ¸
                    if (editorState.audioBuffer) {
                        render();
                    }

                    alert(`ì°¨íŠ¸ ë¡œë“œ ì™„ë£Œ!\në…¸íŠ¸: ${editorState.notes.length}ê°œ\n${chartData.audioFileName ? 'ì˜¤ë””ì˜¤ íŒŒì¼: ' + chartData.audioFileName : 'ì˜¤ë””ì˜¤ íŒŒì¼ì„ ë³„ë„ë¡œ ë¡œë“œí•´ì£¼ì„¸ìš”.'}`);

                    // ì…ë ¥ ì´ˆê¸°í™”
                    input.value = '';
                } catch (error) {
                    console.error('ì°¨íŠ¸ ë¡œë“œ ì‹¤íŒ¨:', error);
                    alert('ì°¨íŠ¸ íŒŒì¼ì„ ì½ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                }
            };

            reader.readAsText(file);
        }

        function toggleEditMode() {
            editorState.editMode = !editorState.editMode;
            const btn = document.getElementById('edit-mode-btn');
            const statusText = document.getElementById('edit-mode-status');
            const deleteBtn = document.getElementById('delete-note-btn');

            if (editorState.editMode) {
                btn.textContent = 'âœï¸ í¸ì§‘ì¤‘';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-success');
                statusText.textContent = 'í¸ì§‘ëª¨ë“œ (ë…¸íŠ¸ í´ë¦­)';
                statusText.style.color = '#38ef7d';
                deleteBtn.disabled = false;
                console.log('âœï¸ í¸ì§‘ ëª¨ë“œ í™œì„±í™”: ë…¸íŠ¸ë¥¼ í´ë¦­í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”');

                // ëª¨ë“  ë…¸íŠ¸ì— ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
                editorState.notes.forEach((note, index) => {
                    if (note.sprite) {
                        note.sprite.interactive = true;
                        note.sprite.cursor = 'pointer';
                        note.sprite.eventMode = 'static';
                        note.sprite.noteIndex = index;

                        note.sprite.removeAllListeners('pointerdown');
                        note.sprite.on('pointerdown', (event) => {
                            const idx = event.target.noteIndex;
                            const targetNote = editorState.notes[idx];

                            if (editorState.selectedNotes.has(idx)) {
                                editorState.selectedNotes.delete(idx);
                            } else {
                                editorState.selectedNotes.add(idx);
                            }

                            console.log(`ğŸ“ Note ${idx} ${editorState.selectedNotes.has(idx) ? 'selected' : 'deselected'}. Total: ${editorState.selectedNotes.size}`);
                        });
                    }
                });
            } else {
                btn.textContent = 'âœï¸ í¸ì§‘ëª¨ë“œ';
                btn.classList.remove('btn-success');
                btn.classList.add('btn-primary');
                statusText.textContent = 'ì¼ë°˜ëª¨ë“œ';
                statusText.style.color = '#aaa';
                deleteBtn.disabled = true;
                editorState.selectedNotes.clear();
                console.log('âœï¸ ì¼ë°˜ ëª¨ë“œë¡œ ì „í™˜');

                // ëª¨ë“  ë…¸íŠ¸ì—ì„œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
                editorState.notes.forEach((note) => {
                    if (note.sprite) {
                        note.sprite.interactive = false;
                        note.sprite.cursor = 'default';
                        note.sprite.eventMode = 'auto';
                        note.sprite.removeAllListeners('pointerdown');
                    }
                });
            }
        }

        function deleteSelectedNotes() {
            if (editorState.selectedNotes.size === 0) {
                alert('ì‚­ì œí•  ë…¸íŠ¸ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }

            const count = editorState.selectedNotes.size;
            if (!confirm(`ì„ íƒí•œ ${count}ê°œì˜ ë…¸íŠ¸ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                return;
            }

            // ì„ íƒëœ ì¸ë±ìŠ¤ë¥¼ ë°°ì—´ë¡œ ë³€í™˜í•˜ê³  ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬ (ë’¤ì—ì„œë¶€í„° ì‚­ì œ)
            const selectedIndices = Array.from(editorState.selectedNotes).sort((a, b) => b - a);

            for (const index of selectedIndices) {
                const note = editorState.notes[index];
                // ìŠ¤í”„ë¼ì´íŠ¸ ì •ë¦¬
                if (note.sprite) {
                    note.sprite.destroy();
                    note.sprite = null;
                }
                editorState.notes.splice(index, 1);
            }

            editorState.selectedNotes.clear();
            updateStats();
            render();

            console.log(`ğŸ—‘ï¸ ${count}ê°œì˜ ë…¸íŠ¸ ì‚­ì œë¨. ë‚¨ì€ ë…¸íŠ¸: ${editorState.notes.length}ê°œ`);
            alert(`${count}ê°œì˜ ë…¸íŠ¸ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`);
        }

        function getNoteAtPosition(x, y) {
            // í™”ë©´ ì¢Œí‘œë¥¼ ê²Œì„ ì¢Œí‘œë¡œ ë³€í™˜
            const lane = Math.floor(x / LANE_WIDTH);
            if (lane < 0 || lane >= LANES.length) return -1;

            // í˜„ì¬ ì‹œê°„ ê¸°ì¤€ìœ¼ë¡œ ë…¸íŠ¸ ì°¾ê¸°
            const clickTime = editorState.currentTime + (JUDGMENT_LINE_Y - y) / (GAME_HEIGHT * 0.8);

            // í´ë¦­ ìœ„ì¹˜ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ë…¸íŠ¸ ì°¾ê¸° (0.5ì´ˆ ë²”ìœ„ ë‚´)
            let closestIndex = -1;
            let closestDistance = 0.5;  // ìµœëŒ€ 0.5ì´ˆ ë²”ìœ„

            for (let i = 0; i < editorState.notes.length; i++) {
                const note = editorState.notes[i];
                if (note.lane === lane) {
                    const distance = Math.abs(note.time - clickTime);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestIndex = i;
                    }
                }
            }

            return closestIndex;
        }

        function moveSelectedNotesToLane(targetLane) {
            if (editorState.selectedNotes.size === 0) return;

            const selectedIndices = Array.from(editorState.selectedNotes);
            for (const index of selectedIndices) {
                if (editorState.notes[index]) {
                    editorState.notes[index].lane = targetLane;
                }
            }

            updateStats();
            console.log(`ğŸ”„ ${selectedIndices.length}ê°œ ë…¸íŠ¸ë¥¼ ë ˆì¸ ${targetLane}(${LANES[targetLane].label})ë¡œ ì´ë™`);
        }

        function adjustSelectedNotesTiming(delta) {
            if (editorState.selectedNotes.size === 0) return;

            const selectedIndices = Array.from(editorState.selectedNotes);
            for (const index of selectedIndices) {
                if (editorState.notes[index]) {
                    editorState.notes[index].time += delta;
                    // ìµœì†Œ 0ì´ˆ ì œí•œ
                    if (editorState.notes[index].time < 0) {
                        editorState.notes[index].time = 0;
                    }
                }
            }

            // ë…¸íŠ¸ë¥¼ ì‹œê°„ìˆœìœ¼ë¡œ ì¬ì •ë ¬
            editorState.notes.sort((a, b) => a.time - b.time);

            updateStats();
            console.log(`â±ï¸ ${selectedIndices.length}ê°œ ë…¸íŠ¸ íƒ€ì´ë° ì¡°ì •: ${delta > 0 ? '+' : ''}${(delta * 1000).toFixed(0)}ms`);
        }

        function toggleLongNoteMode() {
            editorState.longNoteMode = !editorState.longNoteMode;
            const btn = document.getElementById('long-note-mode-btn');
            const statusText = document.getElementById('long-note-status');

            if (editorState.longNoteMode) {
                btn.textContent = 'ğŸµ ë¡±ë…¸íŠ¸ ON';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-success');
                statusText.textContent = 'ë¡± ë…¸íŠ¸ ëª¨ë“œ';
                statusText.style.color = '#38ef7d';
                console.log('ğŸµ ë¡± ë…¸íŠ¸ ëª¨ë“œ í™œì„±í™”: í‚¤ë¥¼ ëˆ„ë¥´ê³  ìˆìœ¼ë©´ ë¡± ë…¸íŠ¸ ìƒì„±');
            } else {
                btn.textContent = 'ğŸµ ë¡±ë…¸íŠ¸ ëª¨ë“œ';
                btn.classList.remove('btn-success');
                btn.classList.add('btn-primary');
                statusText.textContent = 'ì¼ë°˜ ë…¸íŠ¸';
                statusText.style.color = '#aaa';
                // í™œì„± ë¡± ë…¸íŠ¸ ì´ˆê¸°í™”
                editorState.activeLongNotes = {};
                console.log('ğŸµ ì¼ë°˜ ë…¸íŠ¸ ëª¨ë“œë¡œ ì „í™˜');
            }
        }
    </script>
</body>
</html>
