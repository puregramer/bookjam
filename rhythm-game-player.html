<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>BookJam - Player</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&family=Noto+Sans+KR:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            font-family: 'Fredoka', 'Noto Sans KR', sans-serif;
            background: linear-gradient(135deg, #FFE5F1 0%, #FFF6B5 25%, #C7F0DB 50%, #D4C5F9 75%, #FFE0EC 100%);
            overflow: hidden;
            color: white;
            touch-action: none;
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            position: fixed;
        }

        #game-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            box-sizing: border-box;
            overflow-y: auto;
        }

        /* Cute Kid-Friendly Menu */
        #menu {
            text-align: center;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(30px);
            -webkit-backdrop-filter: blur(30px);
            padding: 20px 20px;
            border-radius: 30px;
            border: 5px solid #FF9CEE;
            box-shadow: 0 10px 50px 0 rgba(255, 156, 238, 0.5),
                        0 20px 80px rgba(255, 200, 150, 0.3),
                        inset 0 0 60px rgba(255, 255, 255, 0.5);
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            animation: menuFadeIn 0.5s ease-out;
        }

        @keyframes menuFadeIn {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes menuFloat {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        @keyframes bounce {
            0%, 100% {
                transform: scale(1) translateY(0);
            }
            25% {
                transform: scale(1.1) translateY(-5px);
            }
            50% {
                transform: scale(1.05) translateY(-3px);
            }
            75% {
                transform: scale(1.08) translateY(-4px);
            }
        }

        @keyframes wiggle {
            0%, 100% {
                transform: rotate(0deg);
            }
            25% {
                transform: rotate(-5deg);
            }
            75% {
                transform: rotate(5deg);
            }
        }

        #menu h1 {
            font-size: clamp(28px, 6vw, 56px);
            margin-bottom: 10px;
            background: linear-gradient(135deg, #FF6B9D 0%, #FEC84D 25%, #0BDA51 50%, #4FACFE 75%, #C77DFF 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
            letter-spacing: 2px;
            filter: drop-shadow(0 4px 12px rgba(255, 107, 157, 0.4));
            animation: wiggle 2s ease-in-out infinite;
        }

        #menu p {
            font-size: clamp(16px, 3vw, 20px);
            margin-bottom: 30px;
            color: #FF6B9D;
            font-weight: 600;
            text-shadow: 0 2px 10px rgba(255, 107, 157, 0.3);
        }

        #menu-logo {
            max-width: 180px;
            height: auto;
            margin-bottom: 15px;
            animation: bounce 2s ease-in-out infinite;
            filter: drop-shadow(0 8px 20px rgba(255, 107, 157, 0.3));
        }

        .file-group {
            margin: 15px 0;
            padding: 15px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.7) 0%, rgba(255, 240, 245, 0.8) 100%);
            border-radius: 25px;
            border: 4px solid #FFD23F;
            box-shadow: 0 6px 25px rgba(255, 210, 63, 0.4),
                        inset 0 0 30px rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
        }

        .file-group:hover {
            border-color: #FF9CEE;
            box-shadow: 0 8px 35px rgba(255, 156, 238, 0.6),
                        0 0 50px rgba(255, 210, 63, 0.3),
                        inset 0 0 40px rgba(255, 255, 255, 0.6);
            transform: translateY(-5px) scale(1.02);
            animation: wiggle 0.5s ease-in-out;
        }

        .file-group h3 {
            font-size: 20px;
            margin-bottom: 10px;
            color: #FF6B9D;
            font-weight: 700;
            text-shadow: 0 3px 12px rgba(255, 107, 157, 0.4);
            letter-spacing: 1px;
        }

        .file-input-label {
            display: inline-block;
            background: linear-gradient(135deg, #FFD23F 0%, #FFA940 100%);
            padding: 18px 45px;
            border-radius: 50px;
            cursor: pointer;
            font-size: clamp(16px, 3vw, 20px);
            font-weight: 700;
            transition: all 0.3s ease;
            box-shadow: 0 6px 25px rgba(255, 210, 63, 0.5);
            margin: 10px;
            border: 4px solid #fff;
            color: #fff;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .file-input-label:hover {
            transform: scale(1.1) translateY(-5px);
            box-shadow: 0 10px 35px rgba(255, 210, 63, 0.7);
            background: linear-gradient(135deg, #FFA940 0%, #FFD23F 100%);
            animation: bounce 0.5s ease-in-out;
        }

        .file-input-label:active {
            transform: scale(0.95);
        }

        input[type="file"] {
            display: none;
        }

        .file-status {
            margin-top: 12px;
            font-size: 16px;
            color: #C77DFF;
            font-weight: 600;
        }

        .file-status.loaded {
            color: #0BDA51;
            font-weight: 700;
            text-shadow: 0 0 12px rgba(11, 218, 81, 0.6);
            animation: bounce 0.5s ease-in-out;
        }

        .start-btn {
            display: inline-block;
            background: linear-gradient(135deg, #FF6B9D 0%, #FF9CEE 100%);
            padding: 16px 50px;
            border-radius: 50px;
            cursor: pointer;
            font-size: clamp(16px, 3vw, 24px);
            font-weight: 700;
            transition: all 0.3s ease;
            box-shadow: 0 12px 45px rgba(255, 107, 157, 0.6);
            margin-top: 20px;
            border: 5px solid #fff;
            color: white;
            font-family: 'Fredoka', 'Noto Sans KR', sans-serif;
            text-shadow: 0 3px 15px rgba(0, 0, 0, 0.3);
            letter-spacing: 1px;
        }

        .start-btn:hover {
            transform: scale(1.15) translateY(-8px);
            box-shadow: 0 18px 60px rgba(255, 107, 157, 0.8);
            background: linear-gradient(135deg, #FF9CEE 0%, #FF6B9D 100%);
            animation: bounce 0.6s ease-in-out;
        }

        .start-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .hidden {
            display: none !important;
        }

        /* Cute Touch Buttons */
        .touch-button {
            position: absolute;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(20px, 5vw, 36px);
            font-weight: 700;
            transition: all 0.1s ease;
            cursor: pointer;
            border-top: 5px solid rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(15px);
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }

        .touch-button.active {
            background: rgba(255, 255, 255, 0.5) !important;
            transform: scale(0.9);
            box-shadow: inset 0 0 30px rgba(255, 255, 255, 0.5);
        }

        canvas {
            display: block;
        }

        /* Ensure canvas doesn't block touch buttons */
        #game-area {
            position: relative;
        }

        #game-area .touch-button {
            pointer-events: auto;
        }

        #particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            background: radial-gradient(circle, rgba(240, 147, 251, 0.4) 0%, rgba(79, 172, 254, 0.3) 40%, rgba(0, 242, 254, 0.2) 60%, transparent 80%);
            border-radius: 50%;
            animation: float 20s infinite;
            box-shadow: 0 0 30px rgba(240, 147, 251, 0.3);
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0) translateX(0) scale(1);
                opacity: 0.3;
            }
            50% {
                transform: translateY(-100px) translateX(50px) scale(1.5);
                opacity: 0.6;
            }
        }

        /* Game Layout with Lyrics Sidebar */
        #game-layout {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            overflow: hidden;
        }

        #game-layout.hidden {
            display: none !important;
        }

        /* Desktop/Tablet Landscape Layout */
        @media (min-width: 769px) {
            #game-layout {
                display: flex;
                flex-direction: row;
            }

            #game-area {
                flex: 0 0 65%;
                position: relative;
                overflow: visible;
                height: 100%;
            }

            #game-area canvas {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: calc(100% - 110px); /* Leave space for touch buttons */
            }

            #lyrics-sidebar {
                flex: 0 0 35%;
                display: flex !important;
                flex-direction: column;
                background: linear-gradient(180deg,
                    rgba(255, 229, 241, 0.95) 0%,
                    rgba(255, 246, 181, 0.95) 25%,
                    rgba(199, 240, 219, 0.95) 50%,
                    rgba(212, 197, 249, 0.95) 75%,
                    rgba(255, 224, 236, 0.95) 100%);
                backdrop-filter: blur(20px);
                -webkit-backdrop-filter: blur(20px);
                padding: 20px;
                overflow-y: auto;
                overflow-x: hidden;
                box-shadow: -5px 0 30px rgba(0, 0, 0, 0.1);
                height: 100%;
                box-sizing: border-box;
            }
        }

        /* Mobile/Small Screen Layout */
        @media (max-width: 768px) {
            #game-layout {
                display: block;
            }

            #game-area {
                width: 100%;
                height: 100%;
                position: relative;
                overflow: visible;
            }

            #game-area canvas {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: calc(100% - 110px); /* Leave space for touch buttons */
            }

            #lyrics-sidebar {
                display: none !important; /* Hide on mobile */
            }

            #lyrics-overlay {
                display: block !important;
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                z-index: 1000;
                background: rgba(255, 255, 255, 0.9);
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
                padding: 10px 20px;
                border-radius: 20px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
                min-width: 200px;
                max-width: 90vw;
                text-align: center;
            }
        }

        @media (min-width: 769px) {
            #lyrics-overlay {
                display: none !important;
            }
        }

        /* Lyrics Sidebar Styles */
        #lyrics-sidebar {
            display: none;
        }

        .lyrics-thumbnail {
            width: 100%;
            max-width: 300px;
            aspect-ratio: 1;
            object-fit: cover;
            border-radius: 20px;
            margin: 0 auto 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            border: 5px solid white;
        }

        .lyrics-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 15px;
            padding: 20px 0;
        }

        .lyric-line {
            font-family: 'Fredoka', 'Noto Sans KR', sans-serif;
            font-size: clamp(16px, 2.5vw, 24px);
            font-weight: 600;
            text-align: center;
            padding: 10px;
            border-radius: 15px;
            transition: all 0.3s ease;
            line-height: 1.5;
        }

        .lyric-line.previous {
            color: rgba(150, 150, 150, 0.6);
            font-size: clamp(14px, 2vw, 18px);
            transform: scale(0.9);
        }

        .lyric-line.current {
            color: #FF6B9D;
            font-size: clamp(20px, 3vw, 32px);
            font-weight: 700;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 5px 25px rgba(255, 107, 157, 0.3);
            transform: scale(1.1);
            animation: lyricPulse 1s ease-in-out infinite;
        }

        .lyric-line.next {
            color: rgba(100, 100, 100, 0.5);
            font-size: clamp(14px, 2vw, 18px);
            transform: scale(0.9);
        }

        @keyframes lyricPulse {
            0%, 100% {
                transform: scale(1.1);
            }
            50% {
                transform: scale(1.15);
            }
        }

        /* Mobile Overlay Lyrics */
        #lyrics-overlay {
            display: none;
        }

        #lyrics-overlay .lyric-line {
            margin: 0;
            padding: 5px 10px;
        }

        #lyrics-overlay .lyric-line.current {
            font-size: clamp(16px, 4vw, 20px);
            color: #FF6B9D;
            font-weight: 700;
        }
    </style>
</head>
<body>
    <div id="particles"></div>

    <!-- Mobile Lyrics Overlay -->
    <div id="lyrics-overlay">
        <div class="lyric-line current" id="mobile-lyric"></div>
    </div>

    <div id="game-container">
        <div id="menu">
            <img src="img.png" alt="BookJam Logo" id="menu-logo">
            <p>신나는 리듬게임 플레이어</p>

            <div class="file-group">
                <h3>1단계: 차트 파일 선택하기</h3>
                <label for="chart-input" class="file-input-label">차트 선택하기</label>
                <input type="file" id="chart-input" accept=".json">
                <div class="file-status" id="chart-status">아직 선택 안 됨</div>
            </div>

            <div class="file-group">
                <h3>2단계: 음악 파일 선택하기</h3>
                <label for="audio-input" class="file-input-label">음악 선택하기</label>
                <input type="file" id="audio-input" accept="audio/*">
                <div class="file-status" id="audio-status">아직 선택 안 됨</div>
            </div>

            <button class="start-btn" id="start-btn" disabled>게임 시작!</button>
        </div>
    </div>

    <!-- Game Layout with Lyrics -->
    <div id="game-layout" class="hidden">
        <div id="game-area"></div>
        <div id="lyrics-sidebar">
            <img class="lyrics-thumbnail" id="lyrics-thumb" src="" alt="Album Art">
            <div class="lyrics-container" id="lyrics-content"></div>
        </div>
    </div>

    <script src="https://pixijs.download/release/pixi.js"></script>
    <script>
        // URL 파라미터 먼저 체크하여 초기 메뉴 상태 설정
        const urlParams = new URLSearchParams(window.location.search);
        const autoLoadIndex = urlParams.get('index');

        if (autoLoadIndex === '0') {
            // 자동 로드 모드: 메뉴 콘텐츠 숨기기
            document.addEventListener('DOMContentLoaded', () => {
                const fileGroups = document.querySelectorAll('.file-group');
                fileGroups.forEach(group => group.style.display = 'none');

                const menuMessage = document.querySelector('#menu p');
                menuMessage.textContent = '로딩 중...';
                menuMessage.style.fontSize = '1.2em';

                document.getElementById('start-btn').style.display = 'none';
            });
        }

        // Create Particle Background
        function createParticles() {
            const container = document.getElementById('particles');
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.width = Math.random() * 100 + 50 + 'px';
                particle.style.height = particle.style.width;
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 20 + 's';
                particle.style.animationDuration = (Math.random() * 10 + 15) + 's';
                container.appendChild(particle);
            }
        }
        createParticles();

        // 전체 레인 정의 (5레인)
        const ALL_LANES = [
            { key: 'KeyD', index: 0, color: 0xff6b9d, label: 'D' },      // Bright Pink
            { key: 'KeyF', index: 1, color: 0xc77dff, label: 'F' },      // Bright Purple
            { key: 'Space', index: 2, color: 0xffd23f, label: '␣' },     // Bright Yellow
            { key: 'KeyJ', index: 3, color: 0x4facfe, label: 'J' },      // Bright Blue
            { key: 'KeyK', index: 4, color: 0x0bda51, label: 'K' }       // Bright Green
        ];

        // 난이도별 레인 구성
        const DIFFICULTY_LANES = {
            'Easy': [
                { key: 'KeyD', index: 0, color: 0xff6b9d, label: 'D', originalIndex: 0 },
                { key: 'Space', index: 1, color: 0xffd23f, label: '␣', originalIndex: 2 },
                { key: 'KeyK', index: 2, color: 0x0bda51, label: 'K', originalIndex: 4 }
            ],
            'Normal': [
                { key: 'KeyD', index: 0, color: 0xff6b9d, label: 'D', originalIndex: 0 },
                { key: 'KeyF', index: 1, color: 0xc77dff, label: 'F', originalIndex: 1 },
                { key: 'KeyJ', index: 2, color: 0x4facfe, label: 'J', originalIndex: 3 },
                { key: 'KeyK', index: 3, color: 0x0bda51, label: 'K', originalIndex: 4 }
            ],
            'Hard': ALL_LANES.map((lane, idx) => ({ ...lane, originalIndex: idx })),
            'Expert': ALL_LANES.map((lane, idx) => ({ ...lane, originalIndex: idx }))
        };

        // 현재 활성 레인 (차트 로드 시 난이도에 맞게 변경됨)
        let LANES = DIFFICULTY_LANES['Hard'];

        // Judgment Timing Windows (Kid-Friendly Theme)
        const JUDGMENT = {
            PERFECT: { window: 50, score: 100, text: 'PERFECT!', color: 0xffd700 },  // Gold
            GREAT: { window: 100, score: 70, text: 'GREAT!', color: 0x4facfe },       // Bright Blue
            GOOD: { window: 150, score: 40, text: 'GOOD!', color: 0xc77dff },         // Bright Purple
            MISS: { window: 200, score: 0, text: 'MISS', color: 0xff6b9d }           // Bright Pink
        };

        // Game State
        const gameState = {
            isPlaying: false,
            score: 0,
            combo: 0,
            maxCombo: 0,
            health: 100,
            perfect: 0,
            great: 0,
            good: 0,
            miss: 0,
            notes: [],
            chartData: null,
            audioContext: null,
            audioBuffer: null,
            audioSource: null,
            startTime: 0,
            offset: 0,  // Chart offset for timing adjustment
            touchButtons: [],
            activeLongNotes: {},  // 현재 누르고 있는 롱노트 { lane: note }
            keyStates: {}  // 키 상태 추적
        };

        let GAME_WIDTH, GAME_HEIGHT, LANE_WIDTH, NOTE_HEIGHT, NOTE_SPEED, JUDGMENT_LINE_Y, BUTTON_HEIGHT;
        let lyricsData = [];
        let currentLyricIndex = -1;

        function calculateDimensions() {
            // Desktop/tablet: game area is 65% of screen width
            // Mobile: full width
            const isDesktop = window.innerWidth > 768;
            const availableWidth = isDesktop ? window.innerWidth * 0.65 : window.innerWidth;
            GAME_WIDTH = Math.min(availableWidth, 1200);

            // 실제 보이는 뷰포트 높이 사용 (모바일 주소창 제외)
            const viewportHeight = window.visualViewport ? window.visualViewport.height : window.innerHeight;
            GAME_HEIGHT = viewportHeight;
            LANE_WIDTH = GAME_WIDTH / LANES.length;
            NOTE_HEIGHT = Math.max(15, GAME_HEIGHT * 0.025);
            NOTE_SPEED = GAME_HEIGHT * 0.4;
            // 터치 버튼 높이를 화면 크기에 따라 조정 (태블릿/모바일 고려)
            BUTTON_HEIGHT = Math.min(Math.max(80, GAME_HEIGHT * 0.12), 120);
            // 판정선을 충분히 위로 올려서 터치 버튼에 가려지지 않도록
            JUDGMENT_LINE_Y = GAME_HEIGHT - BUTTON_HEIGHT - 60;
        }
        calculateDimensions();

        let app, gameContainer, uiContainer, notesContainer, particleContainer, beatGridContainer;
        let judgmentText, scoreText, comboText, healthBar, accuracyText;

        // File Inputs
        let chartFile = null;
        let audioFile = null;

        document.getElementById('chart-input').addEventListener('change', (e) => {
            chartFile = e.target.files[0];
            if (chartFile) {
                document.getElementById('chart-status').textContent = chartFile.name + ' 완료!';
                document.getElementById('chart-status').classList.add('loaded');
                checkFilesReady();
            }
        });

        document.getElementById('audio-input').addEventListener('change', (e) => {
            audioFile = e.target.files[0];
            if (audioFile) {
                document.getElementById('audio-status').textContent = audioFile.name + ' 완료!';
                document.getElementById('audio-status').classList.add('loaded');
                checkFilesReady();
            }
        });

        function checkFilesReady() {
            if (chartFile && audioFile) {
                document.getElementById('start-btn').disabled = false;
            }
        }

        document.getElementById('start-btn').addEventListener('click', async () => {
            await loadFiles();
        });

        async function loadFiles() {
            try {
                // Load chart JSON
                let chartText;
                if (typeof chartFile === 'string') {
                    // URL path (auto-load)
                    const response = await fetch(chartFile);
                    chartText = await response.text();
                } else {
                    // File object (user upload)
                    chartText = await chartFile.text();
                }
                gameState.chartData = JSON.parse(chartText);

                // Validate chart
                if (!gameState.chartData.notes || !Array.isArray(gameState.chartData.notes)) {
                    throw new Error('Invalid chart format: notes array not found');
                }

                // Load chart metadata
                gameState.offset = gameState.chartData.offset || 0;
                const title = gameState.chartData.title || 'Untitled';
                const difficulty = gameState.chartData.difficulty || 'Hard';
                const bpm = gameState.chartData.bpm || 120;
                const noteCount = gameState.chartData.notes.length;
                const nps = gameState.chartData.metadata?.nps || (noteCount / (gameState.chartData.duration || 1)).toFixed(2);
                const chartLanes = gameState.chartData.lanes;

                // 난이도에 맞게 레인 설정 (차트의 lanes 정보로 검증)
                LANES = DIFFICULTY_LANES[difficulty] || DIFFICULTY_LANES['Hard'];

                // 차트 파일의 lanes 정보와 난이도 기반 레인 수 검증
                if (chartLanes && chartLanes !== LANES.length) {
                    console.warn(`⚠️ Chart lanes mismatch: chart has ${chartLanes} lanes, but ${difficulty} difficulty expects ${LANES.length} lanes`);
                    console.log(`   Using chart's lane count: ${chartLanes}`);
                    // 차트 파일의 레인 수를 신뢰하고 해당하는 난이도 찾기
                    const difficultyByLanes = {
                        3: 'Easy',
                        4: 'Normal',
                        5: 'Hard'
                    };
                    const correctedDifficulty = difficultyByLanes[chartLanes] || difficulty;
                    LANES = DIFFICULTY_LANES[correctedDifficulty] || DIFFICULTY_LANES['Hard'];
                }

                console.log(`🎮 Player lanes: ${difficulty} (${LANES.length} lanes)`);

                console.log('📊 Chart loaded:');
                console.log(`   Title: ${title}`);
                console.log(`   Difficulty: ${difficulty}`);
                console.log(`   BPM: ${bpm}`);
                console.log(`   Offset: ${gameState.offset}s`);
                console.log(`   Notes: ${noteCount}`);
                console.log(`   NPS: ${nps}`);
                if (gameState.chartData.audioFileName) {
                    console.log(`   Audio: ${gameState.chartData.audioFileName}`);
                }
                if (gameState.chartData.metadata?.createdAt) {
                    console.log(`   Created: ${new Date(gameState.chartData.metadata.createdAt).toLocaleString()}`);
                }

                // Copy notes (롱노트 정보 포함)
                gameState.notes = gameState.chartData.notes.map(note => ({
                    time: note.time,
                    lane: note.lane,
                    type: note.type || 'normal',  // 롱노트 타입
                    endTime: note.endTime,  // 롱노트 종료 시간
                    hit: false,
                    missed: false
                }));

                // 롱노트 통계
                const longNotes = gameState.notes.filter(n => n.type === 'long').length;
                const normalNotes = gameState.notes.filter(n => n.type === 'normal').length;
                console.log(`   🎵 Note types: ${normalNotes} normal, ${longNotes} long`);

                // Load audio
                if (!gameState.audioContext) {
                    gameState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                let arrayBuffer;
                if (typeof audioFile === 'string') {
                    // URL path (auto-load)
                    const response = await fetch(audioFile);
                    arrayBuffer = await response.arrayBuffer();
                } else {
                    // File object (user upload)
                    arrayBuffer = await audioFile.arrayBuffer();
                }
                gameState.audioBuffer = await gameState.audioContext.decodeAudioData(arrayBuffer);

                console.log(`✅ Audio loaded: ${gameState.audioBuffer.duration.toFixed(2)}s`);

                // Hide menu and start game
                document.getElementById('menu').classList.add('hidden');
                await initGame();
            } catch (error) {
                console.error('Error loading files:', error);
                // 에러 발생 시 메뉴로 돌아가기
                document.getElementById('menu').classList.remove('hidden');
            }
        }

        async function initGame() {
            calculateDimensions();

            app = new PIXI.Application();
            await app.init({
                width: GAME_WIDTH,
                height: GAME_HEIGHT,
                backgroundColor: 0x2D3561,
                antialias: true,
                resolution: window.devicePixelRatio || 1
            });

            // Setup game layout
            const gameLayout = document.getElementById('game-layout');
            const gameArea = document.getElementById('game-area');

            // Show game layout (remove hidden class)
            gameLayout.classList.remove('hidden');

            // Add canvas to game area
            gameArea.innerHTML = '';
            gameArea.appendChild(app.canvas);

            gameContainer = new PIXI.Container();
            beatGridContainer = new PIXI.Container();
            notesContainer = new PIXI.Container();
            particleContainer = new PIXI.Container();
            uiContainer = new PIXI.Container();

            app.stage.addChild(gameContainer);
            app.stage.addChild(beatGridContainer);
            app.stage.addChild(notesContainer);
            app.stage.addChild(particleContainer);
            app.stage.addChild(uiContainer);

            drawLanes();
            drawJudgmentLine();
            createUI();
            setupInput();
            createTouchButtons();
            setupLyrics();

            app.ticker.add(gameLoop);
            playAudio();
        }

        function drawLanes() {
            for (let i = 0; i < LANES.length; i++) {
                const lane = new PIXI.Graphics();

                // Lane background (Dark gradient with color tint)
                lane.rect(i * LANE_WIDTH, 0, LANE_WIDTH, GAME_HEIGHT / 2);
                lane.fill({ color: 0x1a1e3a, alpha: 0.5 });

                lane.rect(i * LANE_WIDTH, GAME_HEIGHT / 2, LANE_WIDTH, GAME_HEIGHT / 2);
                lane.fill({ color: 0x252a4a, alpha: 0.6 });

                // Vibrant glow effect
                const glow3 = new PIXI.Graphics();
                glow3.moveTo(i * LANE_WIDTH, 0);
                glow3.lineTo(i * LANE_WIDTH, GAME_HEIGHT);
                glow3.stroke({ color: LANES[i].color, width: 15, alpha: 0.2 });
                gameContainer.addChild(glow3);

                const glow2 = new PIXI.Graphics();
                glow2.moveTo(i * LANE_WIDTH, 0);
                glow2.lineTo(i * LANE_WIDTH, GAME_HEIGHT);
                glow2.stroke({ color: LANES[i].color, width: 8, alpha: 0.3 });
                gameContainer.addChild(glow2);

                // Lane border with vibrant color
                lane.moveTo(i * LANE_WIDTH, 0);
                lane.lineTo(i * LANE_WIDTH, GAME_HEIGHT);
                lane.stroke({ color: LANES[i].color, width: 3, alpha: 0.8 });

                gameContainer.addChild(lane);
            }
        }

        function drawJudgmentLine() {
            // Outer glow
            const glow3 = new PIXI.Graphics();
            glow3.moveTo(0, JUDGMENT_LINE_Y);
            glow3.lineTo(GAME_WIDTH, JUDGMENT_LINE_Y);
            glow3.stroke({ color: 0xf093fb, width: 30, alpha: 0.2 });
            gameContainer.addChild(glow3);

            // Middle glow
            const glow2 = new PIXI.Graphics();
            glow2.moveTo(0, JUDGMENT_LINE_Y);
            glow2.lineTo(GAME_WIDTH, JUDGMENT_LINE_Y);
            glow2.stroke({ color: 0x4facfe, width: 15, alpha: 0.3 });
            gameContainer.addChild(glow2);

            // Inner glow
            const glow = new PIXI.Graphics();
            glow.moveTo(0, JUDGMENT_LINE_Y);
            glow.lineTo(GAME_WIDTH, JUDGMENT_LINE_Y);
            glow.stroke({ color: 0xffffff, width: 8, alpha: 0.4 });
            gameContainer.addChild(glow);

            // Main line (bright and clear)
            const line = new PIXI.Graphics();
            line.moveTo(0, JUDGMENT_LINE_Y);
            line.lineTo(GAME_WIDTH, JUDGMENT_LINE_Y);
            line.stroke({ color: 0xffffff, width: 4 });
            gameContainer.addChild(line);
        }

        function createUI() {
            // Score panel
            const scoreBg = new PIXI.Graphics();
            scoreBg.roundRect(20, 20, 250, 80, 20);
            scoreBg.fill({ color: 0x1a1e3a, alpha: 0.9 });
            scoreBg.stroke({ color: 0xff6b9d, width: 4, alpha: 0.9 });
            uiContainer.addChild(scoreBg);

            scoreText = new PIXI.Text({
                text: '0',
                style: {
                    fontSize: Math.max(36, GAME_HEIGHT * 0.045),
                    fill: 0xffffff,
                    fontWeight: 'bold',
                    fontFamily: 'Fredoka',
                    dropShadow: {
                        color: 0xff6b9d,
                        blur: 10,
                        distance: 3
                    }
                }
            });
            scoreText.x = 40;
            scoreText.y = 30;
            uiContainer.addChild(scoreText);

            const scoreLabel = new PIXI.Text({
                text: '점수',
                style: {
                    fontSize: Math.max(16, GAME_HEIGHT * 0.022),
                    fill: 0xf093fb,
                    fontFamily: 'Fredoka'
                }
            });
            scoreLabel.x = 40;
            scoreLabel.y = 70;
            uiContainer.addChild(scoreLabel);

            // Combo
            comboText = new PIXI.Text({
                text: '',
                style: {
                    fontSize: Math.max(56, GAME_HEIGHT * 0.09),
                    fill: 0xffffff,
                    fontWeight: 'bold',
                    fontFamily: 'Fredoka',
                    dropShadow: {
                        color: 0xf093fb,
                        blur: 20,
                        distance: 4
                    },
                    stroke: { color: 0xffd700, width: 5 }
                }
            });
            comboText.anchor.set(0.5);
            comboText.x = GAME_WIDTH / 2;
            comboText.y = GAME_HEIGHT / 2 - 150;
            uiContainer.addChild(comboText);

            // Judgment text
            judgmentText = new PIXI.Text({
                text: '',
                style: {
                    fontSize: Math.max(44, GAME_HEIGHT * 0.07),
                    fill: 0xFFFFFF,
                    fontWeight: 'bold',
                    fontFamily: 'Fredoka'
                }
            });
            judgmentText.anchor.set(0.5);
            judgmentText.x = GAME_WIDTH / 2;
            judgmentText.y = JUDGMENT_LINE_Y - 100;
            judgmentText.alpha = 0;
            uiContainer.addChild(judgmentText);

            // Health bar
            const healthBg = new PIXI.Graphics();
            healthBg.roundRect(GAME_WIDTH - 270, 20, 250, 30, 20);
            healthBg.fill({ color: 0x1a1e3a, alpha: 0.9 });
            healthBg.stroke({ color: 0xff6b9d, width: 4, alpha: 0.9 });
            uiContainer.addChild(healthBg);

            healthBar = new PIXI.Graphics();
            updateHealthBar();
            uiContainer.addChild(healthBar);

            const healthLabel = new PIXI.Text({
                text: '체력',
                style: {
                    fontSize: Math.max(16, GAME_HEIGHT * 0.022),
                    fill: 0xff6b9d,
                    fontFamily: 'Fredoka',
                    fontWeight: 'bold'
                }
            });
            healthLabel.x = GAME_WIDTH - 270;
            healthLabel.y = 55;
            uiContainer.addChild(healthLabel);

            // Accuracy
            accuracyText = new PIXI.Text({
                text: '정확도: 100%',
                style: {
                    fontSize: Math.max(18, GAME_HEIGHT * 0.028),
                    fill: 0xffffff,
                    fontFamily: 'Fredoka',
                    fontWeight: 'bold',
                    dropShadow: {
                        color: 0xffd700,
                        blur: 10,
                        distance: 3
                    }
                }
            });
            accuracyText.anchor.set(0.5, 0);
            accuracyText.x = GAME_WIDTH / 2;
            accuracyText.y = 20;
            uiContainer.addChild(accuracyText);

            // Chart info (Title & Difficulty)
            if (gameState.chartData) {
                const title = gameState.chartData.title || 'Untitled';
                const difficulty = gameState.chartData.difficulty || 'Unknown';

                const chartInfoBg = new PIXI.Graphics();
                chartInfoBg.roundRect(20, GAME_HEIGHT - 110, 300, 70, 20);
                chartInfoBg.fill({ color: 0x1a1e3a, alpha: 0.9 });
                chartInfoBg.stroke({ color: 0x4facfe, width: 4, alpha: 0.9 });
                uiContainer.addChild(chartInfoBg);

                const titleText = new PIXI.Text({
                    text: title,
                    style: {
                        fontSize: Math.max(20, GAME_HEIGHT * 0.03),
                        fill: 0xffffff,
                        fontWeight: 'bold',
                        fontFamily: 'Fredoka'
                    }
                });
                titleText.x = 40;
                titleText.y = GAME_HEIGHT - 95;
                uiContainer.addChild(titleText);

                // Difficulty color (Bright Theme)
                const difficultyColors = {
                    'Easy': 0x0bda51,
                    'Normal': 0x4facfe,
                    'Hard': 0xffd23f,
                    'Expert': 0xff6b9d
                };
                const diffColor = difficultyColors[difficulty] || 0xc77dff;

                const difficultyText = new PIXI.Text({
                    text: difficulty.toUpperCase(),
                    style: {
                        fontSize: Math.max(16, GAME_HEIGHT * 0.024),
                        fill: diffColor,
                        fontWeight: 'bold',
                        fontFamily: 'Fredoka'
                    }
                });
                difficultyText.x = 40;
                difficultyText.y = GAME_HEIGHT - 65;
                uiContainer.addChild(difficultyText);
            }
        }

        function updateHealthBar() {
            healthBar.clear();
            healthBar.roundRect(GAME_WIDTH - 270, 20, 250 * (gameState.health / 100), 30, 20);
            const healthColor = gameState.health > 50 ? 0x0bda51 : gameState.health > 25 ? 0xffd23f : 0xff6b9d;
            healthBar.fill({ color: healthColor });
        }

        function createTouchButtons() {
            // 기존 버튼 제거
            gameState.touchButtons.forEach(button => {
                if (button.parentNode) {
                    button.parentNode.removeChild(button);
                }
            });
            gameState.touchButtons = [];

            // 난이도에 맞게 버튼 생성
            for (let i = 0; i < LANES.length; i++) {
                const button = document.createElement('div');
                button.className = 'touch-button';
                button.style.left = (i * LANE_WIDTH) + 'px';
                button.style.width = LANE_WIDTH + 'px';
                button.style.height = BUTTON_HEIGHT + 'px';
                button.textContent = LANES[i].label;
                button.style.color = '#' + LANES[i].color.toString(16).padStart(6, '0');
                button.style.background = `rgba(${(LANES[i].color >> 16) & 255}, ${(LANES[i].color >> 8) & 255}, ${LANES[i].color & 255}, 0.2)`;

                button.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    button.classList.add('active');
                    handleKeyPress(i);
                    showKeyPress(i);
                }, { passive: false });

                button.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    button.classList.remove('active');
                    handleKeyRelease(i);  // 롱노트 종료 처리
                }, { passive: false });

                button.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    button.classList.add('active');
                    handleKeyPress(i);
                    showKeyPress(i);
                });

                button.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    button.classList.remove('active');
                    handleKeyRelease(i);  // 롱노트 종료 처리
                });

                button.addEventListener('mouseleave', () => {
                    button.classList.remove('active');
                    handleKeyRelease(i);  // 롱노트 종료 처리 (마우스가 버튼 밖으로 나갈 때)
                });

                // 게임 영역이 있으면 game-area에, 없으면 game-container에 추가
                const container = document.getElementById('game-area') || document.getElementById('game-container');
                container.appendChild(button);
                gameState.touchButtons.push(button);
            }
        }

        function setupInput() {
            window.addEventListener('keydown', (e) => {
                if (gameState.keyStates[e.code]) return;
                gameState.keyStates[e.code] = true;

                const lane = LANES.find(l => l.key === e.code);
                if (lane) {
                    handleKeyPress(lane.index);
                    showKeyPress(lane.index);
                    if (gameState.touchButtons[lane.index]) {
                        gameState.touchButtons[lane.index].classList.add('active');
                    }
                }
            });

            window.addEventListener('keyup', (e) => {
                gameState.keyStates[e.code] = false;
                const lane = LANES.find(l => l.key === e.code);
                if (lane) {
                    handleKeyRelease(lane.index);  // 롱노트 종료 처리
                    if (gameState.touchButtons[lane.index]) {
                        gameState.touchButtons[lane.index].classList.remove('active');
                    }
                }
            });
        }

        function showKeyPress(laneIndex) {
            const flash = new PIXI.Graphics();
            flash.rect(laneIndex * LANE_WIDTH, JUDGMENT_LINE_Y - 100, LANE_WIDTH, 200);
            flash.fill({ color: LANES[laneIndex].color, alpha: 0.4 });
            gameContainer.addChild(flash);

            let alpha = 0.4;
            const fadeOut = () => {
                alpha -= 0.04;
                flash.alpha = alpha;
                if (alpha <= 0) {
                    gameContainer.removeChild(flash);
                } else {
                    requestAnimationFrame(fadeOut);
                }
            };
            fadeOut();
        }

        function createHitParticles(x, y, color) {
            for (let i = 0; i < 10; i++) {
                const particle = new PIXI.Graphics();
                const size = Math.random() * 5 + 3;
                particle.circle(0, 0, size);
                particle.fill({ color: color, alpha: 1 });
                particle.x = x;
                particle.y = y;

                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;

                particleContainer.addChild(particle);

                let life = 1;
                const animate = () => {
                    particle.x += vx;
                    particle.y += vy;
                    life -= 0.02;
                    particle.alpha = life;

                    if (life > 0) {
                        requestAnimationFrame(animate);
                    } else {
                        particleContainer.removeChild(particle);
                    }
                };
                animate();
            }
        }

        function handleKeyPress(laneIndex) {
            const currentTime = gameState.audioContext.currentTime - gameState.startTime;

            let closestNote = null;
            let minTimeDiff = Infinity;

            for (const note of gameState.notes) {
                if (note.lane === laneIndex && !note.hit && !note.missed && !note.longNoteStarted) {
                    const timeDiff = Math.abs((note.time - currentTime) * 1000);
                    if (timeDiff < JUDGMENT.MISS.window && timeDiff < minTimeDiff) {
                        closestNote = note;
                        minTimeDiff = timeDiff;
                    }
                }
            }

            if (closestNote) {
                const isLongNote = closestNote.type === 'long' && closestNote.endTime;

                let judgment;
                if (minTimeDiff <= JUDGMENT.PERFECT.window) {
                    judgment = JUDGMENT.PERFECT;
                    gameState.perfect++;
                } else if (minTimeDiff <= JUDGMENT.GREAT.window) {
                    judgment = JUDGMENT.GREAT;
                    gameState.great++;
                } else if (minTimeDiff <= JUDGMENT.GOOD.window) {
                    judgment = JUDGMENT.GOOD;
                    gameState.good++;
                } else {
                    judgment = JUDGMENT.MISS;
                    gameState.miss++;
                }

                if (isLongNote) {
                    // 롱노트 시작
                    closestNote.longNoteStarted = true;
                    closestNote.startJudgment = judgment;
                    gameState.activeLongNotes[laneIndex] = closestNote;
                    console.log(`🎵 Long note started: Lane ${laneIndex}, judgment: ${judgment.text}`);
                } else {
                    // 일반 노트
                    closestNote.hit = true;
                    updateScore(judgment);
                    showJudgment(judgment);
                    showParticles(laneIndex);
                }
            }
        }

        function handleKeyRelease(laneIndex) {
            const activeLongNote = gameState.activeLongNotes[laneIndex];
            if (!activeLongNote) return;

            const currentTime = gameState.audioContext.currentTime - gameState.startTime;
            const releaseTimeDiff = Math.abs((activeLongNote.endTime - currentTime) * 1000);

            let endJudgment;
            if (releaseTimeDiff <= JUDGMENT.PERFECT.window) {
                endJudgment = JUDGMENT.PERFECT;
                gameState.perfect++;
            } else if (releaseTimeDiff <= JUDGMENT.GREAT.window) {
                endJudgment = JUDGMENT.GREAT;
                gameState.great++;
            } else if (releaseTimeDiff <= JUDGMENT.GOOD.window) {
                endJudgment = JUDGMENT.GOOD;
                gameState.good++;
            } else {
                endJudgment = JUDGMENT.MISS;
                gameState.miss++;
            }

            // 롱노트 완료 - 시작과 끝 판정의 평균 점수
            const avgScore = Math.floor((activeLongNote.startJudgment.score + endJudgment.score) / 2);
            const avgJudgment = {
                ...activeLongNote.startJudgment,
                score: avgScore
            };

            activeLongNote.hit = true;
            delete gameState.activeLongNotes[laneIndex];

            updateScore(avgJudgment);
            showJudgment(avgJudgment);
            showParticles(laneIndex);

            console.log(`✅ Long note completed: Lane ${laneIndex}, start: ${activeLongNote.startJudgment.text}, end: ${endJudgment.text}`);
        }

        function updateScore(judgment) {
            gameState.score += judgment.score;

            if (judgment !== JUDGMENT.MISS) {
                gameState.combo++;
                gameState.maxCombo = Math.max(gameState.maxCombo, gameState.combo);
            } else {
                gameState.combo = 0;
                gameState.health = Math.max(0, gameState.health - 5);
            }

            scoreText.text = gameState.score.toLocaleString();
            comboText.text = gameState.combo > 0 ? `${gameState.combo} 콤보!` : '';

            const totalHits = gameState.perfect + gameState.great + gameState.good + gameState.miss;
            if (totalHits > 0) {
                const accuracy = ((gameState.perfect * 100 + gameState.great * 70 + gameState.good * 40) / (totalHits * 100) * 100).toFixed(1);
                accuracyText.text = `정확도: ${accuracy}%`;
            }

            updateHealthBar();
        }

        function showJudgment(judgment) {
            judgmentText.text = judgment.text;
            judgmentText.style.fill = judgment.color;
            judgmentText.alpha = 1;
            judgmentText.scale.set(1.2);

            let alpha = 1;
            let scale = 1.2;
            const fadeOut = () => {
                alpha -= 0.03;
                scale -= 0.006;
                judgmentText.alpha = alpha;
                judgmentText.scale.set(Math.max(1, scale));
                if (alpha > 0) {
                    requestAnimationFrame(fadeOut);
                }
            };
            fadeOut();
        }

        function playAudio() {
            gameState.audioSource = gameState.audioContext.createBufferSource();
            gameState.audioSource.buffer = gameState.audioBuffer;
            gameState.audioSource.connect(gameState.audioContext.destination);

            // Start audio at offset position (skip the offset amount)
            // Note: chart offset represents when the first beat occurs in the audio
            // Since note times already include the offset, we don't need to skip
            gameState.audioSource.start(0);
            gameState.startTime = gameState.audioContext.currentTime;
            gameState.isPlaying = true;

            gameState.audioSource.onended = () => {
                endGame();
            };
        }

        function setupLyrics() {
            // Load lyrics from chart data
            if (gameState.chartData && gameState.chartData.lyrics) {
                lyricsData = gameState.chartData.lyrics;

                // Setup thumbnail
                if (gameState.chartData.thumbnail) {
                    const thumb = document.getElementById('lyrics-thumb');
                    thumb.src = gameState.chartData.thumbnail;
                    thumb.style.display = 'block';
                } else {
                    document.getElementById('lyrics-thumb').style.display = 'none';
                }

                // Initialize lyrics display
                updateLyrics(0);
            }
        }

        function updateLyrics(currentTime) {
            if (!lyricsData || lyricsData.length === 0) return;

            // Find current lyric index
            let newIndex = -1;
            for (let i = 0; i < lyricsData.length; i++) {
                if (currentTime >= lyricsData[i].time) {
                    newIndex = i;
                } else {
                    break;
                }
            }

            // Only update if index changed
            if (newIndex !== currentLyricIndex) {
                currentLyricIndex = newIndex;
                renderLyrics();
            }
        }

        function renderLyrics() {
            const container = document.getElementById('lyrics-content');
            const mobileLyric = document.getElementById('mobile-lyric');

            if (currentLyricIndex < 0) {
                container.innerHTML = '<div class="lyric-line">♪</div>';
                mobileLyric.textContent = '♪';
                return;
            }

            // Desktop sidebar: show previous, current, and next
            const lyrics = [];
            const startIdx = Math.max(0, currentLyricIndex - 1);
            const endIdx = Math.min(lyricsData.length - 1, currentLyricIndex + 2);

            for (let i = startIdx; i <= endIdx; i++) {
                const lyric = lyricsData[i];
                let className = 'lyric-line';
                if (i < currentLyricIndex) className += ' previous';
                else if (i === currentLyricIndex) className += ' current';
                else className += ' next';

                if (lyric.text.trim() === '') {
                    lyrics.push(`<div class="${className}">♪</div>`);
                } else {
                    lyrics.push(`<div class="${className}">${lyric.text}</div>`);
                }
            }

            container.innerHTML = lyrics.join('');

            // Mobile overlay: show only current
            const currentLyric = lyricsData[currentLyricIndex];
            mobileLyric.textContent = currentLyric.text.trim() === '' ? '♪' : currentLyric.text;
        }

        function gameLoop(ticker) {
            if (!gameState.isPlaying) return;

            const currentTime = gameState.audioContext.currentTime - gameState.startTime;

            // Update lyrics
            updateLyrics(currentTime);

            // Draw beat grid lines
            beatGridContainer.removeChildren();
            if (gameState.chartData && gameState.chartData.bpm) {
                const beatDuration = 60 / gameState.chartData.bpm;
                const visibleTime = GAME_HEIGHT / NOTE_SPEED;
                const startBeat = Math.floor((currentTime - gameState.offset) / beatDuration);
                const endBeat = Math.ceil((currentTime + visibleTime - gameState.offset) / beatDuration);

                for (let beat = startBeat; beat <= endBeat; beat++) {
                    const beatTime = beat * beatDuration + gameState.offset;
                    const timeDiff = beatTime - currentTime;
                    const lineY = JUDGMENT_LINE_Y - timeDiff * NOTE_SPEED;

                    if (lineY > -10 && lineY < GAME_HEIGHT + 10) {
                        const line = new PIXI.Graphics();

                        // Different colors for different beat types
                        if (beat % 4 === 0) {
                            // Measure line (white, thick)
                            line.moveTo(0, lineY);
                            line.lineTo(GAME_WIDTH, lineY);
                            line.stroke({ color: 0xFFFFFF, width: 2, alpha: 0.3 });
                        } else {
                            // Regular beat line (gray, thin)
                            line.moveTo(0, lineY);
                            line.lineTo(GAME_WIDTH, lineY);
                            line.stroke({ color: 0x888888, width: 1, alpha: 0.15 });
                        }

                        beatGridContainer.addChild(line);
                    }
                }
            }

            for (const note of gameState.notes) {
                if (note.hit || note.missed) continue;

                const isLongNote = note.type === 'long' && note.endTime;
                const isHolding = gameState.activeLongNotes[note.lane] === note;

                let noteY = JUDGMENT_LINE_Y - (note.time - currentTime) * NOTE_SPEED;
                let endNoteY = noteY;

                // 롱노트의 경우 끝 위치 계산
                if (isLongNote) {
                    endNoteY = JUDGMENT_LINE_Y - (note.endTime - currentTime) * NOTE_SPEED;
                } else if (isHolding) {
                    // 누르고 있는 롱노트는 판정선까지 연장
                    endNoteY = JUDGMENT_LINE_Y;
                }

                const maxY = Math.max(noteY, endNoteY);
                const minY = Math.min(noteY, endNoteY);

                if (maxY > -NOTE_HEIGHT && minY < GAME_HEIGHT) {
                    if (!note.sprite) {
                        note.sprite = new PIXI.Graphics();
                        notesContainer.addChild(note.sprite);
                    }

                    note.sprite.clear();

                    if (isLongNote || isHolding) {
                        // 롱노트 렌더링
                        const longNoteHeight = Math.abs(noteY - endNoteY);
                        const longNoteY = Math.min(noteY, endNoteY);
                        const noteWidth = LANE_WIDTH - 10;
                        const noteColor = LANES[note.lane].color;

                        // 1. 본체
                        note.sprite.roundRect(0, 0, noteWidth, longNoteHeight, 6);
                        note.sprite.fill({ color: noteColor, alpha: 0.5 });

                        // 2. 외곽 테두리
                        note.sprite.roundRect(0, 0, noteWidth, longNoteHeight, 6);
                        note.sprite.stroke({ color: isHolding ? 0x00FF00 : 0xFFFFFF, width: 4, alpha: 1.0 });

                        // 3. 헤드 (시작 부분)
                        const headHeight = NOTE_HEIGHT * 1.5;
                        note.sprite.roundRect(0, 0, noteWidth, headHeight, 6);
                        note.sprite.fill({ color: noteColor, alpha: 1.0 });
                        note.sprite.roundRect(0, 0, noteWidth, headHeight, 6);
                        note.sprite.stroke({ color: 0xFFFFFF, width: 2, alpha: 1.0 });

                        // 4. 테일 (끝 부분) - 완성된 롱노트만
                        if (isLongNote && !isHolding) {
                            const tailHeight = NOTE_HEIGHT * 1.5;
                            note.sprite.roundRect(0, longNoteHeight - tailHeight, noteWidth, tailHeight, 6);
                            note.sprite.fill({ color: noteColor, alpha: 1.0 });
                            note.sprite.roundRect(0, longNoteHeight - tailHeight, noteWidth, tailHeight, 6);
                            note.sprite.stroke({ color: 0xFFFFFF, width: 2, alpha: 1.0 });
                        }

                        note.sprite.x = note.lane * LANE_WIDTH + 5;
                        note.sprite.y = longNoteY;
                    } else {
                        // 일반 노트 렌더링
                        note.sprite.roundRect(0, 0, LANE_WIDTH - 10, NOTE_HEIGHT, 15);
                        note.sprite.fill({ color: LANES[note.lane].color });

                        note.sprite.x = note.lane * LANE_WIDTH + 5;
                        note.sprite.y = noteY;
                    }
                }

                // MISS 판정 (롱노트는 헤드만 체크)
                if (noteY > JUDGMENT_LINE_Y + JUDGMENT.MISS.window && !note.hit && !note.longNoteStarted) {
                    note.missed = true;
                    if (note.sprite) {
                        notesContainer.removeChild(note.sprite);
                        note.sprite = null;
                    }
                    gameState.miss++;
                    updateScore(JUDGMENT.MISS);
                    showJudgment(JUDGMENT.MISS);
                }
            }

            for (const note of gameState.notes) {
                if (note.hit && note.sprite) {
                    notesContainer.removeChild(note.sprite);
                    note.sprite = null;
                }
            }

            if (gameState.health <= 0) {
                endGame();
            }
        }

        function endGame() {
            gameState.isPlaying = false;

            if (gameState.audioSource) {
                try {
                    gameState.audioSource.stop();
                } catch (e) {}
            }

            const results = new PIXI.Container();

            const bg = new PIXI.Graphics();
            bg.rect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            bg.fill({ color: 0x000000, alpha: 0.85 });
            results.addChild(bg);

            const panel = new PIXI.Graphics();
            panel.roundRect(GAME_WIDTH / 2 - 300, GAME_HEIGHT / 2 - 250, 600, 500, 30);
            panel.fill({ color: 0x1a1e3a, alpha: 0.95 });
            panel.stroke({ color: 0xffd700, width: 5, alpha: 1 });

            // Outer glow
            const panelGlow2 = new PIXI.Graphics();
            panelGlow2.roundRect(GAME_WIDTH / 2 - 310, GAME_HEIGHT / 2 - 260, 620, 520, 35);
            panelGlow2.stroke({ color: 0xff6b9d, width: 6, alpha: 0.8 });
            results.addChild(panelGlow2);

            // Inner glow
            const panelGlow = new PIXI.Graphics();
            panelGlow.roundRect(GAME_WIDTH / 2 - 305, GAME_HEIGHT / 2 - 255, 610, 510, 32);
            panelGlow.stroke({ color: 0x4facfe, width: 4, alpha: 0.7 });
            results.addChild(panelGlow);

            results.addChild(panel);

            const titleText = new PIXI.Text({
                text: gameState.health > 0 ? '성공!' : '다시 도전!',
                style: {
                    fontSize: 64,
                    fill: gameState.health > 0 ? 0xffd700 : 0xff6b9d,
                    fontWeight: 'bold',
                    fontFamily: 'Fredoka',
                    dropShadow: {
                        color: gameState.health > 0 ? 0x0bda51 : 0xf093fb,
                        blur: 20,
                        distance: 5
                    },
                    stroke: { color: 0xffffff, width: 4, alpha: 0.8 }
                }
            });
            titleText.anchor.set(0.5);
            titleText.x = GAME_WIDTH / 2;
            titleText.y = GAME_HEIGHT / 2 - 200;
            results.addChild(titleText);

            // Chart info (Title & Difficulty)
            if (gameState.chartData) {
                const chartTitle = gameState.chartData.title || 'Untitled';
                const difficulty = gameState.chartData.difficulty || 'Unknown';

                const chartInfoText = new PIXI.Text({
                    text: `${chartTitle} [${difficulty}]`,
                    style: {
                        fontSize: 22,
                        fill: 0x4facfe,
                        fontFamily: 'Fredoka',
                        fontWeight: 'bold'
                    }
                });
                chartInfoText.anchor.set(0.5);
                chartInfoText.x = GAME_WIDTH / 2;
                chartInfoText.y = GAME_HEIGHT / 2 - 160;
                results.addChild(chartInfoText);
            }

            const totalHits = gameState.perfect + gameState.great + gameState.good + gameState.miss;
            const accuracy = totalHits > 0 ? ((gameState.perfect * 100 + gameState.great * 70 + gameState.good * 40) / (totalHits * 100) * 100).toFixed(1) : 0;

            const statsText = new PIXI.Text({
                text: `점수: ${gameState.score.toLocaleString()}\n최고 콤보: ${gameState.maxCombo}\n정확도: ${accuracy}%\n\nPERFECT: ${gameState.perfect}\nGREAT: ${gameState.great}\nGOOD: ${gameState.good}\nMISS: ${gameState.miss}`,
                style: {
                    fontSize: 26,
                    fill: 0xffffff,
                    align: 'center',
                    fontFamily: 'Fredoka',
                    fontWeight: '600',
                    lineHeight: 40
                }
            });
            statsText.anchor.set(0.5);
            statsText.x = GAME_WIDTH / 2;
            statsText.y = GAME_HEIGHT / 2;
            results.addChild(statsText);

            const restartText = new PIXI.Text({
                text: '화면을 터치하거나 R키를 눌러서 다시 시작',
                style: {
                    fontSize: 22,
                    fill: 0xffd700,
                    align: 'center',
                    fontFamily: 'Fredoka',
                    fontWeight: 'bold'
                }
            });
            restartText.anchor.set(0.5);
            restartText.x = GAME_WIDTH / 2;
            restartText.y = GAME_HEIGHT / 2 + 200;
            results.addChild(restartText);

            app.stage.addChild(results);

            const restartHandler = () => {
                location.reload();
            };

            results.eventMode = 'static';
            results.on('pointerdown', restartHandler);

            const keyHandler = (e) => {
                if (e.key === 'r' || e.key === 'R' || e.key === 'Escape') {
                    window.removeEventListener('keydown', keyHandler);
                    location.reload();
                }
            };
            window.addEventListener('keydown', keyHandler);
        }

        window.addEventListener('resize', () => {
            if (!gameState.isPlaying) {
                calculateDimensions();
                if (app) {
                    app.renderer.resize(GAME_WIDTH, GAME_HEIGHT);
                    gameContainer.removeChildren();
                    beatGridContainer.removeChildren();
                    drawLanes();
                    drawJudgmentLine();
                    createTouchButtons();
                }
            }
        });

        // 모바일 주소창 표시/숨김 처리 (게임 플레이 중에도 동작)
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', () => {
                const oldHeight = GAME_HEIGHT;
                calculateDimensions();

                // 게임 플레이 중이면 터치 버튼만 업데이트
                if (gameState.isPlaying && app) {
                    // 높이가 변경되었으면 터치 버튼 위치 재조정
                    if (Math.abs(oldHeight - GAME_HEIGHT) > 10) {
                        createTouchButtons();
                    }
                } else if (!gameState.isPlaying && app) {
                    // 메뉴 상태면 전체 재조정
                    app.renderer.resize(GAME_WIDTH, GAME_HEIGHT);
                    gameContainer.removeChildren();
                    beatGridContainer.removeChildren();
                    drawLanes();
                    drawJudgmentLine();
                    createTouchButtons();
                }
            });
        }

        document.addEventListener('touchmove', (e) => {
            if (gameState.isPlaying) {
                e.preventDefault();
            }
        }, { passive: false });

        // URL 파라미터 확인 및 자동 로드
        (async function checkAutoLoad() {
            if (autoLoadIndex === '0') {
                console.log('🎮 Auto-loading chart from URL parameter...');

                try {
                    // 파일 경로 설정
                    chartFile = 'assets/bookjam_intro_Normal_chart.json';
                    audioFile = 'assets/bookjam_intro.mp3';

                    // 차트와 오디오 미리 로드 (게임은 시작하지 않음)
                    const chartResponse = await fetch(chartFile);
                    const chartText = await chartResponse.text();
                    gameState.chartData = JSON.parse(chartText);

                    const audioResponse = await fetch(audioFile);
                    const arrayBuffer = await audioResponse.arrayBuffer();

                    // AudioContext는 사용자 제스처 후에 생성
                    if (!gameState.audioContext) {
                        gameState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    gameState.audioBuffer = await gameState.audioContext.decodeAudioData(arrayBuffer);

                    // 메타데이터 설정
                    gameState.offset = gameState.chartData.offset || 0;
                    const title = gameState.chartData.title || 'Untitled';
                    const difficulty = gameState.chartData.difficulty || 'Hard';
                    const chartLanes = gameState.chartData.lanes;

                    // 난이도에 맞게 레인 설정
                    LANES = DIFFICULTY_LANES[difficulty] || DIFFICULTY_LANES['Hard'];
                    if (chartLanes && chartLanes !== LANES.length) {
                        const difficultyByLanes = { 3: 'Easy', 4: 'Normal', 5: 'Hard' };
                        const correctedDifficulty = difficultyByLanes[chartLanes] || difficulty;
                        LANES = DIFFICULTY_LANES[correctedDifficulty] || DIFFICULTY_LANES['Hard'];
                    }

                    // 노트 복사
                    gameState.notes = gameState.chartData.notes.map(note => ({
                        time: note.time,
                        lane: note.lane,
                        type: note.type || 'normal',
                        endTime: note.endTime,
                        hit: false,
                        missed: false
                    }));

                    console.log(`✅ Chart and audio pre-loaded: ${title} (${difficulty})`);

                    // 메뉴 내용 변경
                    const menu = document.getElementById('menu');
                    const fileGroups = menu.querySelectorAll('.file-group');
                    fileGroups.forEach(group => group.style.display = 'none');

                    // 로고 이미지를 썸네일로 교체
                    const menuLogo = document.getElementById('menu-logo');
                    menuLogo.src = 'assets/thumbnail1.png';
                    menuLogo.style.maxWidth = '400px';
                    menuLogo.style.maxHeight = '300px';
                    menuLogo.style.width = 'auto';
                    menuLogo.style.height = 'auto';
                    menuLogo.style.borderRadius = '20px';
                    menuLogo.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.3)';

                    // 로고 아래 메시지 변경
                    const menuMessage = menu.querySelector('p');
                    menuMessage.textContent = `${title} - ${difficulty}`;
                    menuMessage.style.fontSize = '1.5em';
                    menuMessage.style.fontWeight = 'bold';
                    menuMessage.style.color = '#FF1493';
                    menuMessage.style.marginTop = '20px';

                    // 시작 버튼 교체 (기존 이벤트 리스너 제거)
                    const oldBtn = document.getElementById('start-btn');
                    const startBtn = oldBtn.cloneNode(true);
                    oldBtn.parentNode.replaceChild(startBtn, oldBtn);

                    startBtn.style.display = 'block';
                    startBtn.disabled = false;
                    startBtn.textContent = '🎮 게임 시작! 🎮';

                    // 버튼 클릭 시 AudioContext resume 후 게임 시작
                    startBtn.addEventListener('click', async () => {
                        // AudioContext resume (사용자 제스처 필요)
                        if (gameState.audioContext.state === 'suspended') {
                            await gameState.audioContext.resume();
                        }

                        // 메뉴 숨기고 게임 시작
                        menu.classList.add('hidden');
                        await initGame();
                    });

                } catch (error) {
                    console.error('❌ Auto-load failed:', error);
                    // 자동 로드 실패 시 일반 메뉴 표시
                }
            }
        })();
    </script>
</body>
</html>
